<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>linux | Bruno Messias</title><link>/category/linux/</link><atom:link href="/category/linux/index.xml" rel="self" type="application/rss+xml"/><description>linux</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en</language><lastBuildDate>Fri, 04 Feb 2022 08:31:00 -0300</lastBuildDate><image><url>/images/icon_hucd6a3d413e7b81060a1d462b35f64cf9_5018_512x512_fill_lanczos_center_3.png</url><title>linux</title><link>/category/linux/</link></image><item><title>Dissecating process and failures in Linux with lsof and strace: cases for MlOps and DevOps</title><link>/post/using_lsof_and_strace_to_investigate_process_and_failures/</link><pubDate>Fri, 04 Feb 2022 08:31:00 -0300</pubDate><guid>/post/using_lsof_and_strace_to_investigate_process_and_failures/</guid><description>&lt;h2>Table of Contents&lt;/h2>
&lt;nav id="TableOfContents">
&lt;ul>
&lt;li>&lt;a href="#everything-is-a-file-the-unix-mantra">“Everything is a file.” The UNIX mantra.&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#lsof">LSOF&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#system-calls-and-strace">System Calls and strace&lt;/a>&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>&lt;a href="#network-issues">Network issues&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#my-server-is-alive">My server is alive?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#my-process-is-stuck-waiting-someone-what-causes-hangs-anyway">My process is stuck waiting someone? What causes hangs anyway?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#investigating-database-connections">Investigating database connections&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#problems-with-regular-files">Problems with regular files&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#which-processes-are-attached-to-this-file">Which processes are attached to this file?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#i-made-a-mistake-deleted-an-important-file-how-can-i-recover-it">I made a mistake! Deleted an important file! How can I recover it?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#silent-errors-associated-with-files-and-permissions">Silent errors associated with files and permissions&lt;/a>&lt;/li>
&lt;li>&lt;a href="#this-process--is-using--a-cached-files-where-i-can-find-this-cache-">This process is using a cached files? Where I can find this cache ?&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#extras-related-with-files-proc-and-strace">Extras related with files (&lt;code>/proc/&lt;/code>) and &lt;code>strace&lt;/code>&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#creating-a-sys-call-summary--in-what-my-program-is-spending-most-of-the-time">Creating a SYS CALL summary: in what my program is spending most of the time?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#this-process-was-initiated-with-the-correct-enviroment-variables">This process was initiated with the correct enviroment variables?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#i-forgot-to-redirect-the-outputs-what-i-can-do-now">I forgot to redirect the outputs! What I can do now?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#how-this-program-has-been-called-what-is-the-working-dir-of-the-process">How this program has been called? What is the working dir of the process?&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#agradecimentos--sugestões">Agradecimentos &amp;amp; Sugestões&lt;/a>&lt;/li>
&lt;/ul>
&lt;/nav>
&lt;p>Linux não é um SO opaco. Ele não ser opaco significa que é fácil ver o que acontece por trás dos processos. O que permite identificar um problema ou pelo menos saber se você realmente tem um problema.&lt;/p>
&lt;p>Iniciei meu aprendizado em MlOps (&lt;em>Machine Learning Operations&lt;/em>). Embora tenha pouca experiência foi fácil aceitar que MlOps envolve um workflow extremamente intricado com muitos possíveis pontos de falhas. Tais pontos podem não estar relacionados com os operadores. Portanto, saber identificar se existe uma falha e o que está causando ela é de suma importância. Isso vai desde compreender o comportamento de um processo criado pelos próprios operadores ou o que o &lt;code>pip/conda&lt;/code> e demais dependências externas estão aprontando debaixo dos panos.&lt;/p>
&lt;p>The first step to understand a process is to analyze the output. But sometimes the output dosen’t gives to us enough information to use. Here I’ll talk about how we can extract useful information using the &lt;code>strace&lt;/code> and &lt;code>lsof&lt;/code> commands. To use those command is good that you know two concepts: The “Everything is a file ” mantra and the system call mechanism.&lt;/p>
&lt;h1 id="concepts">Concepts&lt;/h1>
&lt;h2 id="everything-is-a-file-the-unix-mantra">“Everything is a file.” The UNIX mantra.&lt;/h2>
&lt;p>&lt;img src="everthing_is_a_file.png" alt="everthing_is_a_file">&lt;/p>
&lt;p>What is comes to your mind when someone talks about files ? Maybe a jpeg or a CSV if you work as a data scientist. But in UNIX approach to do stuffs everything can be a file, even network connections. When a thing is not a file it has at least a file descriptor associated with it. Maybe you’re a thinking that I’m divagating about the topic of the post. &lt;em>How this stuff can help to improve our comprehension about a process or failure?&lt;/em> The answer is easy: if everything is a file we can use the same set of tools to list, read and interact (API) with files to analyze a process. Here is where &lt;code>lsof&lt;/code> appears.&lt;/p>
&lt;h3 id="lsof">LSOF&lt;/h3>
&lt;p>lsof is an acrononmy for &lt;strong>l&lt;/strong>ist &lt;strong>o&lt;/strong>pen &lt;strong>f&lt;/strong>iles. In simple terms Lsof is a command line tool that can be used to list open file descriptors in your machine. Lsof allows to use a set of different filters to give you filtreed list of opened files. Thus, we can list the open file descriptors of an user or process.&lt;/p>
&lt;p>Bellow it’s a simple example where all the open files obtained by lsof are putted in the &lt;code>lsof_everthing.txt&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-bash">username:/$ lsof &amp;gt; lsof_everthing.txt
&lt;/code>&lt;/pre>
&lt;p>The file &lt;code>lsof_everthing.txt&lt;/code> is huge and will look similar to this&lt;/p>
&lt;pre>&lt;code>COMMAND PID TID TASKCMD USER FD TYPE DEVICE SIZE/OFF NODE NAME
systemd 1 root cwd unknown /proc/1/cwd (readlink: Permission denied)
systemd 1 root rtd unknown /proc/1/root (readlink: Permission denied)
systemd 1 root txt unknown /proc/1/exe (readlink: Permission denied)
&lt;/code>&lt;/pre>
&lt;p>Take some time analyzing the output. The first lines are related to the &lt;code>root&lt;/code> user and you don’t have permission to gain information about those files which it’s good. Let’s remove this wasteful information filtering the SYS CALLs related with just your user&lt;/p>
&lt;pre>&lt;code class="language-bash">username:/$ lsof -u username &amp;gt; lsof_my.txt
&lt;/code>&lt;/pre>
&lt;p>The txt file stills big. Try to look into this file to see if you can found anything interesting like a webpage address.&lt;/p>
&lt;p>We have a lot of different columns in the file. But don’t be worried, I’ll show to you the columns that I believe are the most important ones.&lt;/p>
&lt;ul>
&lt;li>COMMAND
&lt;ul>
&lt;li>O nome do comando associado ao processo que abriu o arquivo&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>PID
&lt;ul>
&lt;li>Um número que identifica unicamente o processo. Você pode usar esse número para matar o processo usando &lt;code>pkill&lt;/code>, usar ele no &lt;code>strace&lt;/code> etc.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>TID
&lt;ul>
&lt;li>Se o arquivo foi aberto por uma thread de um processo. Quando não tem nada nessa coluna significa que a ação foi feita por um processo.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>USER
&lt;ul>
&lt;li>O usuário responsável pelo processo que efetuou a ação.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>TYPE
&lt;ul>
&lt;li>Essa coluna é bem útil. Tal coluna te diz o tipo de nó associado ao arquivo. Por exemplo, se o arquivo for associado com protocolos você vera aqui coisas do tipo: &lt;strong>IPV4, IPV6&lt;/strong>. Se for um arquivo normal haverá na coluna o identificador **REG. **Existem algumas dezenas de possibilidades de valores para essa coluna, eu nunca lembro o que elas significam, mas é fácil consultar online ou no &lt;code>man&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>NODE
&lt;ul>
&lt;li>O identificador do nó do arquivo. No caso desse arquivo envolver protocolos de internet haverá coisas como &lt;strong>TCP, UDP&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>NAME
&lt;ul>
&lt;li>Também bastante útil. Ele muda bastante dependendo do que o arquivo se refere. Pode ser o endereço do servidor (
&lt;a href="http://www.google.com" target="_blank" rel="noopener">www.google.com&lt;/a>, localhost:5000) assim como o endereço do arquivo.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>If you want a more deeply understanding of the columns just use &lt;code>man lsof&lt;/code> .&lt;/p>
&lt;h2 id="system-calls-and-strace">System Calls and strace&lt;/h2>
&lt;p>The SYSTEM_CALL is the mechanism that allows a program ask the kernel for some resources like the access a data stored in the disk. Therefore, if we have a tool to intercept those calls we can have a deep comprehension about what a program is doing or what it want’s to do it in our machine. A celebrated tool to intercept the system calls is the strace.&lt;/p>
&lt;p>If the strace command is not available in your system, install it. In apt-based distros just calling the following command should be enough&lt;/p>
&lt;pre>&lt;code class="language-bash">$ apt install strace
&lt;/code>&lt;/pre>
&lt;p>You can use &lt;code>strace&lt;/code> in two different ways. The first way is to use A primeira é usando o comando a ser interceptado como argumento do strace&lt;/p>
&lt;pre>&lt;code class="language-bash">$ strace ARGS COMANDO_A_SER_INTERCEPTADO
&lt;/code>&lt;/pre>
&lt;p>a segunda, bastante útil, é interceptando um processo já iniciado usando
o PID de tal processo,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ strace ARGS -p PID_DO_PROCESSO
&lt;/code>&lt;/pre>
&lt;p>To discover the PID of a given process you can use the command &lt;code>ps aux | grep -i '[p]rocess_name'&lt;/code>.&lt;/p>
&lt;p>Let’s see an example. We will ask to strace intercept any system call performed by the ls command and at same time we want to record the time that the system call was performed using the -t argument.&lt;/p>
&lt;pre>&lt;code class="language-bash">$ strace -t ls
&lt;/code>&lt;/pre>
&lt;p>The output will be something similar to this&lt;/p>
&lt;pre>&lt;code>18:02:23 execve(&amp;quot;/usr/bin/ls&amp;quot;, [&amp;quot;ls&amp;quot;], 0x7fffa727a418 /* 54 vars */) = 0
18:02:23 brk(NULL) = 0x55ebef60c000
18:02:23 access(&amp;quot;/etc/ld.so.preload&amp;quot;, R_OK) = -1 ENOENT (No such file or directory)
18:02:23 openat(AT_FDCWD, &amp;quot;/etc/ld.so.cache&amp;quot;, O_RDONLY|O_CLOEXEC) = 3
...
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>18:02:23 execve(&amp;quot;/usr/bin/ls&amp;quot;, [&amp;quot;ls&amp;quot;], 0x7fffa727a418 /* 54 vars */) = 0
18:02:23 brk(NULL) = 0x55ebef60c000
18:02:23 access(&amp;quot;/etc/ld.so.preload&amp;quot;, R_OK) = -1 ENOENT (No such file or directory)
18:02:23 openat(AT_FDCWD, &amp;quot;/etc/ld.so.cache&amp;quot;, O_RDONLY|O_CLOEXEC) = 3
...
&lt;/code>&lt;/pre>
&lt;p>Each line of the strace output represents a single SYSTEM CALL. It’s easy to see the following pattern&lt;/p>
&lt;p>&lt;strong>Name of the SYS CALL(Arguments to be used in the system call) = Result of the SYS CALL&lt;/strong>&lt;/p>
&lt;p>Yes, it’s hard to understand the output or impossible without using a manual. For each SYS CALL you can use man to get more information about what each line represents. For example, the see what &lt;code>openat&lt;/code> does and the meaning of each argument use the following command.&lt;/p>
&lt;pre>&lt;code class="language-bash">$ man 2 openat
&lt;/code>&lt;/pre>
&lt;p>&lt;code>openat&lt;/code> is a sys call responsible to request a file to be opened. The result of the last line in the output of ls comands, &lt;code> 3&lt;/code>, means a successfully SYS CALL.&lt;/p>
&lt;h1 id="a-deep-dive-into-failures">A deep dive into failures&lt;/h1>
&lt;p>We will saw here failures and issues related to files, connections etc. But don’t be affraid to explore other problems we are just scratching the surface of &lt;code>strace&lt;/code> and &lt;code>lsof&lt;/code>.&lt;/p>
&lt;h2 id="network-issues">Network issues&lt;/h2>
&lt;p>In DevOps or MlOps discovering what a process is doing now can save your system from a catastrophe. Although, sometimes we already in a failure. When those failures happens questions like:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;em>The process it’s hanging and we don’t know why!&lt;/em>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;em>Where is the cause of the problem?&lt;/em>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;em>Is a network issue?&lt;/em>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>…and so on and so forth&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Being able to answer those questions faster and with a precisely answer can save you or give you a promotion. I’ll show you some simple examples how those questions can be answered. Let’s dive.&lt;/p>
&lt;p>First, install the following packages&lt;/p>
&lt;pre>&lt;code class="language-bash">$ python -m pip install requests flask
&lt;/code>&lt;/pre>
&lt;p>Create a script &lt;code>server_mlops.py&lt;/code> which we will use to simulate a server with network issues&lt;/p>
&lt;pre>&lt;code class="language-python"># server_mlops.py
import time
import flask
app = flask.Flask(__name__)
@app.route('/')
def hello_world():
sleep_time = flask.request.args.get('sleep', default=10, type=int)
print('sleep_time:', sleep_time)
time.sleep(sleep_time)
return 'Hello World!'
if __name__ == '__main__':
app.run()
&lt;/code>&lt;/pre>
&lt;p>Starts the server&lt;/p>
&lt;pre>&lt;code class="language-bash">$ python server_mlops.py
&lt;/code>&lt;/pre>
&lt;p>GET The PID of the process&lt;/p>
&lt;pre>&lt;code class="language-bash">$ ps aux | grep -i '[s]erver_mlops.py'
&lt;/code>&lt;/pre>
&lt;p>You will see a output similar to this&lt;/p>
&lt;pre>&lt;code class="language-bash">devmess+ 19321 18.0 0.3 29716 24792 pts/5 S+ 14:27 0:00 python server_mlops.py
&lt;/code>&lt;/pre>
&lt;p>The number in front of the username (19321) is the &lt;code>PID&lt;/code> of the process&lt;/p>
&lt;h3 id="my-server-is-alive">My server is alive?&lt;/h3>
&lt;p>We must to use different set of filters to answer this question using the &lt;code>lsof&lt;/code>. Therefore, we should use the argument &lt;code>-a&lt;/code> which represents a &lt;code>AND&lt;/code> operator. The &lt;code>-i&lt;/code> argument asks to show just the files associated with connections and finally the argument &lt;code>-p INT&lt;/code> makes the &lt;code>losf&lt;/code> list just the files opened by the process with the PID &lt;code>INT&lt;/code>.&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lsof -a -i -p 19321
&lt;/code>&lt;/pre>
&lt;p>You will have a output similar to this&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>COMMAND&lt;/th>
&lt;th>PID&lt;/th>
&lt;th>USER&lt;/th>
&lt;th>FD&lt;/th>
&lt;th>TYPE&lt;/th>
&lt;th>DEVICE&lt;/th>
&lt;th>SIZE/OFF&lt;/th>
&lt;th>NODE&lt;/th>
&lt;th>NAME&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>python&lt;/td>
&lt;td>19321&lt;/td>
&lt;td>devmessias&lt;/td>
&lt;td>4u&lt;/td>
&lt;td>IPv4&lt;/td>
&lt;td>16108218&lt;/td>
&lt;td>0t0&lt;/td>
&lt;td>TCP&lt;/td>
&lt;td>localhost:5000 (LISTEN)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>The output shows that at least our serve is listening in the &lt;code>5000&lt;/code> port. Try to remove the &lt;code>-a&lt;/code> argument and see what happens..&lt;/p>
&lt;h3 id="my-process-is-stuck-waiting-someone-what-causes-hangs-anyway">My process is stuck waiting someone? What causes hangs anyway?&lt;/h3>
&lt;p>This can be happen in a myriad of cases. For example in your dependency management system like pip/conda. Thus, is a really good to know if you can answer fast if you have a problem on your side or not. Let’s create a simple simulation of this issue. To do so, create the &lt;code>client_mlops.py&lt;/code> using the following code&lt;/p>
&lt;pre>&lt;code class="language-python">#!/usr/bin/env python
#client_mlops.py
import requests
import argparse
parser = argparse.ArgumentParser()
parser.add_argument(
'--sleep', type=int, help='time to sleep', default=0)
args = parser.parse_args()
print('Ask for localhost:5000 to sleep for {} seconds'.format(args.sleep))
r = requests.get('http://localhost:5000', params={'sleep': int(args.sleep)})
print(r.text)
&lt;/code>&lt;/pre>
&lt;p>In the above code we have the sleep argument. This argument will ask for &lt;code>server_mlops&lt;/code> to wait for some couple of seconds before send the answer. Let’s see how this situations appears to us in the system call level&lt;/p>
&lt;p>Start the &lt;code>client_mlops.py&lt;/code> with the &lt;code>strace&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-bash">$ strace -e poll,select,connect,recvfrom,sendto python client_mlops.py --sleep=20
&lt;/code>&lt;/pre>
&lt;p>The &lt;code>-e&lt;/code> argument followed by &lt;code>poll,select,connect,recvfrom,sendto&lt;/code> asks to filter just the sys calls related with connections issues. The output of this fake failure will be something like this&lt;/p>
&lt;pre>&lt;code>connect(4, {sa_family=AF_INET, sin_port=htons(5000), sin_addr=inet_addr(&amp;quot;127.0.0.1&amp;quot;)}, 16) = 0
connect(4, {sa_family=AF_INET6, sin6_port=htons(5000), inet_pton(AF_INET6, &amp;quot;::1&amp;quot;, &amp;amp;sin6_addr), sin6_flowinfo=htonl(0), sin6_scope_id=0}, 28) = 0
connect(4, {sa_family=AF_INET6, sin6_port=htons(5000), inet_pton(AF_INET6, &amp;quot;::1&amp;quot;, &amp;amp;sin6_addr), sin6_flowinfo=htonl(0), sin6_scope_id=0}, 28) = -1 ECONNREFUSED (Connection refused)
connect(4, {sa_family=AF_INET, sin_port=htons(5000), sin_addr=inet_addr(&amp;quot;127.0.0.1&amp;quot;)}, 16) = 0
sendto(4, &amp;quot;GET /?sleep=10 HTTP/1.1\r\nHost: l&amp;quot;..., 154, 0, NULL, 0) = 154
recvfrom(4,
&lt;/code>&lt;/pre>
&lt;p>In the last line we can see an unfinished &lt;code>recvfrom&lt;/code> &lt;strong>SYS_CALL&lt;/strong> . You want to know more about &lt;code>recvfrom&lt;/code>? Execute &lt;code>man 2 recvfrom&lt;/code> in a terminal session. But what matters here? The point is that: &lt;code>strace&lt;/code> is telling us there is no problem with our client program, something is problematic in the server side.&lt;/p>
&lt;p>You can also use the &lt;code>lsof&lt;/code> to investigate this problem. Let’s simulate this.&lt;/p>
&lt;p>Starts a the client again&lt;/p>
&lt;pre>&lt;code class="language-bash">$ python client_mlops.py --sleep=100
&lt;/code>&lt;/pre>
&lt;p>Now, get the PID using &lt;code>ps aux | grep -i '[c]lient_mlops.py'&lt;/code> and execute the &lt;code>lsof&lt;/code> with the obtained PID&lt;/p>
&lt;pre>&lt;code class="language-bash">lsof -a -i -p 19321
&lt;/code>&lt;/pre>
&lt;p>the output will be something like this&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>COMMAND&lt;/th>
&lt;th>PID&lt;/th>
&lt;th>USER&lt;/th>
&lt;th>FD&lt;/th>
&lt;th>TYPE&lt;/th>
&lt;th>DEVICE&lt;/th>
&lt;th>SIZE/OFF&lt;/th>
&lt;th>NODE&lt;/th>
&lt;th>NAME&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>python&lt;/td>
&lt;td>31551&lt;/td>
&lt;td>devmessias&lt;/td>
&lt;td>4u&lt;/td>
&lt;td>IPv4&lt;/td>
&lt;td>16622065&lt;/td>
&lt;td>0t0&lt;/td>
&lt;td>TCP&lt;/td>
&lt;td>localhost:57314-&amp;gt;localhost:5000 (ESTABLISHED)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>What &lt;code>lsof&lt;/code> is telling us is that: ‘’&lt;em>You client seems fine. At least is connected with the server&lt;/em>“”. Note that this answer will not be so usefull whitout the strace.&lt;/p>
&lt;h3 id="investigating-database-connections">Investigating database connections&lt;/h3>
&lt;pre>&lt;code class="language-bash">$ lsof -a -iTCP -p 22157
COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME
python 22157 devmessias 4u IPv4 9474517 0t0 TCP localhost:35932-&amp;gt;localhost:mysql (ESTABLISHED)
python 22157 devmessias 5u IPv4 9474518 0t0 TCP localhost:35934-&amp;gt;localhost:mysql (ESTABLISHED)
python 22157 devmessias 6u IPv4 9475529 0t0 TCP localhost:37048-&amp;gt;localhost:5000 (ESTABLISHED)
&lt;/code>&lt;/pre>
&lt;p>sdfsd&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lsof -a -iTCP -p 22157 | grep 'mysql'
python 22157 devmessias 4u IPv4 9474517 0t0 TCP localhost:35932-&amp;gt;localhost:mysql (ESTABLISHED)
python 22157 devmessias 5u IPv4 9474518 0t0 TCP localhost:35934-&amp;gt;localhost:mysql (ESTABLISHED)
&lt;/code>&lt;/pre>
&lt;h2 id="problems-with-regular-files">Problems with regular files&lt;/h2>
&lt;p>Sometimes you can have a problem with regular files and you don’t know. Nothing is printed in the output. Some example a cache being used, a program which tries to access a file which it dosen’t have permission, a malicious or a bad writing process accessing/creating files in your system and etc.&lt;/p>
&lt;p>Here we will simulate some simple examples related with regular files. To do so, first copy a file to the &lt;code>tmp&lt;/code> folder or just call the following command&lt;/p>
&lt;pre>&lt;code class="language-bash">$ man strace &amp;gt; /tmp/dummy_file.txt
&lt;/code>&lt;/pre>
&lt;h3 id="which-processes-are-attached-to-this-file">Which processes are attached to this file?&lt;/h3>
&lt;p>Be able to answer this question can be quite usefully. For example, suppose that is a huge file in your disk almost filling up your system and you want to discover which process are creating it. Other scenarios is when you want to identify an undue access to a file. Let’s go into it.&lt;/p>
&lt;p>First create the following script&lt;/p>
&lt;pre>&lt;code class="language-python">#!/usr/bin/env python
# file_open.py
import time
f = open('/tmp/dummy_file.txt', 'r')
input('Press Enter to continue...')
&lt;/code>&lt;/pre>
&lt;p>Now open two different terminal sessions and perform the following command &lt;code>python file_open.py &lt;/code>. in each one.&lt;/p>
&lt;p>To find all the processs which are attached to &lt;code>dummy_file.txt&lt;/code> you just need to call &lt;code>lsof&lt;/code> like this&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lsof /tmp/dummy_file.txt
&lt;/code>&lt;/pre>
&lt;p>The output should be something similar to this&lt;/p>
&lt;pre>&lt;code>COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME
python 15411 devmessias 3r REG 8,2 0 2911031 /tmp/dummy_file.txt
python 20777 devmessias 3r REG 8,2 0 2911031 /tmp/dummy_file.txt
&lt;/code>&lt;/pre>
&lt;p>We have two distinct process, two different PIDs, using the same file.&lt;/p>
&lt;h3 id="i-made-a-mistake-deleted-an-important-file-how-can-i-recover-it">I made a mistake! Deleted an important file! How can I recover it?&lt;/h3>
&lt;p>Here the simulation will be more than one more process attached to a file and you accidentally perform some action which deletes the file.&lt;/p>
&lt;p>Create a file &lt;code>accident.txt&lt;/code>. Open a terminal session and perform the following command. &lt;strong>Don’t close the session!&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-bash">$ python -c 'f=open(&amp;quot;accident.txt&amp;quot;, &amp;quot;r&amp;quot;);input(&amp;quot;...&amp;quot;)'
&lt;/code>&lt;/pre>
&lt;p>In another session, perform the following commands&lt;/p>
&lt;pre>&lt;code class="language-bash">$ rm accident.txt
$ ls accident.txt
&lt;/code>&lt;/pre>
&lt;p>And it’s gone :(&lt;/p>
&lt;pre>&lt;code>ls: cannot access 'acidente.txt': No such file or directory
&lt;/code>&lt;/pre>
&lt;p>Don’t worry! Linux has a lot of cool aspects and one of them will help us to recover our file.&lt;/p>
&lt;p>In linux any process has a directory associated inside of the &lt;code>/proc&lt;/code> folder. And what these folders stores? I lot of things I’m assure you that you can be surprised. For example, these folders also stores the file descriptors associated with any process using &lt;code>accident.txt&lt;/code>. Let’s see if there are any process using this file&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lsof -u your_username | grep 'accident.txt'
&lt;/code>&lt;/pre>
&lt;p>In my case I’ve obtained the following output&lt;/p>
&lt;pre>&lt;code>python 22465 devmessias 3r REG 8,2 37599 14288174 caminho/accident.txt (deleted)
&lt;/code>&lt;/pre>
&lt;p>This is a really good news! We have a process PID &lt;code>22465&lt;/code> that still has a file descriptor associated with &lt;code>accident.txt&lt;/code>. Now can use a simple &lt;code>cp&lt;/code> command to recover the data. To do so we need to use the file descriptor number. In my case is &lt;code>3&lt;/code> which is the number in front of the &lt;code>r&lt;/code>character in the above output.&lt;/p>
&lt;pre>&lt;code class="language-bash">$ cp /proc/22465/fd/3 recovered.txt
&lt;/code>&lt;/pre>
&lt;p>Now just call &lt;code>nano recuperado.txt&lt;/code> and testify the result . This it’s not magic it’s how the &lt;strong>process pseudo-filesystem&lt;/strong> works!&lt;/p>
&lt;h3 id="silent-errors-associated-with-files-and-permissions">Silent errors associated with files and permissions&lt;/h3>
&lt;p>Em alguns casos você pode ter um processo criado por uma dependência externa que tenta acessar um arquivo com permissão errada ou mesmo não existente. Criaremos essas duas situações com o script &lt;code>file_404.py&lt;/code>.&lt;/p>
&lt;pre>&lt;code class="language-python">#!/usr/bin/env python
# file_404.py
import time
try:
f = open('/tmp/arquivo_404.csv', 'r')
except FileNotFoundError:
pass
try:
# um arquivo que vc nao tem permissao, crie como sudo e mude com chmod 700
f = open('/tmp/arquivo_permission.csv', 'r')
except PermissionError:
pass
input('Press Enter to continue...')
&lt;/code>&lt;/pre>
&lt;p>Execute ele com &lt;code>python file_404.py&lt;/code> veja que nenhum problema é informado.&lt;/p>
&lt;p>Para traquear as chamadas do sistema do tipo arquivo feitas por &lt;code>python file_404.py &lt;/code> basta digitar o comando abaixo no terminal&lt;/p>
&lt;pre>&lt;code class="language-bash">$ strace -f -e trace=file python file_404.py
&lt;/code>&lt;/pre>
&lt;p>o argumento &lt;code>-f&lt;/code> diz para o strace monitorar também qualquer processo filho criado. Em python, isso seria por exemplo os processos criados por &lt;code>os.fork&lt;/code>.&lt;/p>
&lt;p>A saída do exemplo será algo do tipo&lt;/p>
&lt;pre>&lt;code>lstat(&amp;quot;SEU DIRETORIO/file_404.py&amp;quot;, {st_mode=S_IFREG|0644, st_size=242, ...}) = 0
openat(AT_FDCWD, &amp;quot;file_404.py&amp;quot;, O_RDONLY) = 3
openat(AT_FDCWD, &amp;quot;/tmp/arquivo_404.csv&amp;quot;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &amp;quot;/tmp/arquivo_permission.csv&amp;quot;, O_RDONLY|O_CLOEXEC) = -1 EACCES (Permission denied)
&lt;/code>&lt;/pre>
&lt;p>Note que temos no output informações que não queremos investigar, mas nas últimas linhas os erros de permissão e ausência de arquivo apareceram.&lt;/p>
&lt;p>Uma maneira de filtrar o resultado e tornar sua vida mais fácil é usar o &lt;code>awk&lt;/code> redirecionado a saída do strace com o pipe &lt;code>|&lt;/code>.&lt;/p>
&lt;pre>&lt;code class="language-bash">$ strace -f -e trace=file python file_404.py 2&amp;gt;&amp;amp;1 | awk '/^open/ &amp;amp;&amp;amp; /= -1/ {print}'
&lt;/code>&lt;/pre>
&lt;p>O comando acima diz para mostrar apenas as linhas que começam com a string &lt;code>open&lt;/code> e em alguma parte da linha tenha o padrão &lt;code>= -1&lt;/code>.&lt;/p>
&lt;p>O comando com &lt;code>awk&lt;/code> concatenado produzirá um output mais limpo, veja só&lt;/p>
&lt;pre>&lt;code>openat(AT_FDCWD, &amp;quot;/home/devmessias/anaconda3/pyvenv.cfg&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &amp;quot;/tmp/arquivo_404.csv&amp;quot;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &amp;quot;/tmp/arquivo_permission.csv&amp;quot;, O_RDONLY|O_CLOEXEC) = -1 EACCES (Permission denied)
&lt;/code>&lt;/pre>
&lt;h3 id="this-process--is-using--a-cached-files-where-i-can-find-this-cache-">This process is using a cached files? Where I can find this cache ?&lt;/h3>
&lt;p>Talvez você queira monitorar o que uma dependência externa anda fazendo no seu sistema de arquivos. Outro problema que pode ocorrer é caso você delete um arquivo usado por uma dependência, contudo tal dependência fez um cache em algum lugar antes de você efetuar a remoção. O que te impede de &lt;em>ressetar&lt;/em> a dependência.&lt;/p>
&lt;p>Usando o mesmo comando anterior é possível buscar onde esses caches e arquivos estão&lt;/p>
&lt;pre>&lt;code class="language-bash">$ strace -f -e trace=file comando 2&amp;gt;&amp;amp;1 | awk '/^open/{print}'
&lt;/code>&lt;/pre>
&lt;p>se você quiser pegar apenas as chamadas que não retornaram em falha digite&lt;/p>
&lt;pre>&lt;code class="language-bash">$ strace -f -e trace=file comando 2&amp;gt;&amp;amp;1 | awk '/^open/ &amp;amp;&amp;amp; !/= -1/ {print}'
&lt;/code>&lt;/pre>
&lt;h2 id="extras-related-with-files-proc-and-strace">Extras related with files (&lt;code>/proc/&lt;/code>) and &lt;code>strace&lt;/code>&lt;/h2>
&lt;p>Usando problemas comuns envolvendo arquivos e conexões conversamos um pouco sobre o &lt;code>strace&lt;/code> e &lt;code>lsof&lt;/code>. Conceitos como SYS CALL e a pasta &lt;code>/proc/&lt;/code> também foram mencioandos. Darei alguns exemplos de algumas outras questões que podemos responder usando esses outros elementos.&lt;/p>
&lt;h3 id="creating-a-sys-call-summary--in-what-my-program-is-spending-most-of-the-time">Creating a SYS CALL summary: in what my program is spending most of the time?&lt;/h3>
&lt;p>Você pode sumarizar todas as sys call feitas por um processo usando o argumento &lt;code>-c&lt;/code>. Isso pode te ajudar a economizar tempo numa pre-análise.&lt;/p>
&lt;p>O comando abaixo retorna as sys calls efetuadas pelo comando &lt;code>make sync-env&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-bash">$ strace -c -e trace=!\wait4 make sync-env
&lt;/code>&lt;/pre>
&lt;p>outro argumento que foi alterado aqui é o operador &lt;code>!\&lt;/code> que diz para o strace ignorar as sys call do tipo &lt;code>wait4&lt;/code>. O ouput será algo do tipo:&lt;/p>
&lt;pre>&lt;code>% time seconds usecs/call calls errors syscall
------ ----------- ----------- --------- --------- ----------------
14,54 0,000209 6 33 13 openat
13,01 0,000187 17 11 vfork
12,32 0,000177 7 25 mmap
8,49 0,000122 3 31 close
8,42 0,000121 5 21 rt_sigprocmask
8,14 0,000117 6 17 read
6,89 0,000099 5 19 11 stat
5,85 0,000084 3 23 fstat
2,85 0,000041 8 5 mprotect
2,64 0,000038 9 4 write
2,51 0,000036 2 16 fcntl
2,02 0,000029 3 9 rt_sigaction
1,95 0,000028 14 2 readlink
1,95 0,000028 14 2 getdents64
1,25 0,000018 4 4 brk
1,25 0,000018 18 1 1 access
1,25 0,000018 3 5 pipe
1,11 0,000016 4 4 ioctl
0,84 0,000012 6 2 getcwd
0,70 0,000010 10 1 munmap
0,49 0,000007 7 1 lstat
0,49 0,000007 7 1 execve
0,49 0,000007 3 2 prlimit64
0,35 0,000005 5 1 chdir
0,21 0,000003 3 1 arch_prctl
------ ----------- ----------- --------- --------- ----------------
100.00 0,001437 241 25 total
&lt;/code>&lt;/pre>
&lt;p>A coluna time diz que &lt;code>make sync-env&lt;/code> gastou $14$% do tempo (com exceção do &lt;code>wait4&lt;/code>) em sys calls do tipo &lt;code>openat&lt;/code> e $13$ das $33$ chamadas não foram bem sucedidas.&lt;/p>
&lt;h3 id="this-process-was-initiated-with-the-correct-enviroment-variables">This process was initiated with the correct enviroment variables?&lt;/h3>
&lt;p>Os próximos exemplos envolvem situações em que um processo foi iniciado, mas você quer verificar algumas informações sobre o mesmo sem que seja necessário matar e reiniciar processo. Imagine fazer isso em produção? Ou com um modelo de ML que já gastou muitos &lt;strong>R$&lt;/strong> para chegar no estágio atual.&lt;/p>
&lt;p>Vamos continuar com o nosso &lt;code>server_mlops.py&lt;/code>. Suponha que o processo foi iniciado usando uma variável de ambiente extra, &lt;code>ANSWER&lt;/code>.&lt;/p>
&lt;pre>&lt;code class="language-bash">$ ANSWER=42 python server_mlops.py
&lt;/code>&lt;/pre>
&lt;p>Após o inicio do processo como saber com quais variáveis de ambiente ele está usando? Essa variáveis setam por exemplo bibliotecas de otimização(BLAS, LAPACK), env&amp;rsquo;s python etc.&lt;/p>
&lt;p>Como dito em um exemplo anterior, a pasta &lt;code>/proc&lt;/code> contêm arquivos representado o estado dos processos em execução. Supondo que o PID do processo é &lt;code>4031&lt;/code> você pode acessar as variáveis de ambiente do mesmo através de &lt;code>cat /proc/4031/environ&lt;/code>. Mas o output é meio feio, vamos usar &lt;code>tr&lt;/code> para trocar os caracteres nulos &lt;code>\0&lt;/code> por quebras de linhas, &lt;code>\n&lt;/code>.&lt;/p>
&lt;pre>&lt;code class="language-bash">$ tr '\0' '\n' &amp;lt; /proc/4031/environ
&lt;/code>&lt;/pre>
&lt;p>Você terá um output do tipo&lt;/p>
&lt;pre>&lt;code>ANSWER=42
SHELL=/bin/bash
LANGUAGE=en_US
JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64/bin/java
...more stuff
&lt;/code>&lt;/pre>
&lt;p>Se você quiser filtrar apenas linhas que comecem com a string CONDA faça&lt;/p>
&lt;pre>&lt;code class="language-bash">$ tr '\0' '\n' &amp;lt; /proc/4031/environ 2&amp;gt;&amp;amp;1 | awk '/^CONDA/ {print}'
&lt;/code>&lt;/pre>
&lt;p>o output no meu caso foi algo do tipo&lt;/p>
&lt;pre>&lt;code>CONDA_EXE=/home/devmessias/anaconda3/bin/conda
CONDA_PREFIX=/home/devmessias/anaconda3
CONDA_PROMPT_MODIFIER=(base)
CONDA_SHLVL=1
CONDA_PYTHON_EXE=/home/devmessias/anaconda3/bin/python
CONDA_DEFAULT_ENV=base
&lt;/code>&lt;/pre>
&lt;h3 id="i-forgot-to-redirect-the-outputs-what-i-can-do-now">I forgot to redirect the outputs! What I can do now?&lt;/h3>
&lt;p>Suponha que você iniciou um processo e não redirecionou os outputs para um arquivo de texto por esquecimento ou por subestimar problemas. Se reiniciar o processo não é uma opção você está com problemas. Felizmente é possível usar o &lt;code>strace&lt;/code> para interceptar os outputs e salva-los em um arquivo externo.&lt;/p>
&lt;p>A SYS CALL responsável por requisitar a &lt;em>escrita&lt;/em> no &lt;strong>stdin, stdout e stderr&lt;/strong> é a &lt;code>write&lt;/code> . Veja o manual dessa chamada&lt;/p>
&lt;pre>&lt;code class="language-bash">$ man 2 write
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>NAME
write - write to a file descriptor
SYNOPSIS
#include &amp;lt;unistd.h&amp;gt;
ssize_t write(int fd, const void *buf, size_t count);
&lt;/code>&lt;/pre>
&lt;p>O primeiro argumento é um inteiro que representa o file descriptor. Sendo que &lt;strong>fd=1&lt;/strong> implica que a chamada escreverá no &lt;strong>stdout&lt;/strong> e &lt;strong>fd=2&lt;/strong> no &lt;strong>stderr&lt;/strong> . Portanto, não existe nenhum segredo aqui. Se você quiser capturar os outputs basta filtrar as SYS CALL do tipo write e file descriptor &lt;strong>1&lt;/strong> ou &lt;strong>2&lt;/strong> e envia-las para o arquivo desejado. Temos que tomar cuidado só com as algumas coisas aqui. No manual do strace (&lt;code>man strace&lt;/code>) você vera que por padrão ele &lt;em>printa&lt;/em> apenas $32$ caracteres em uma string. Portanto, precisamos aumentar o limite com o argumento &lt;code>-s&lt;/code>. Também é interessante traquear os forks. No caso do &lt;code>server_mlops.py&lt;/code> por exemplo, qualquer print dentro de um método não será executado na main, então o &lt;code>-f&lt;/code> é obrigatório.&lt;/p>
&lt;p>O comando para redirecionar as saidas do stdout e stderr no arquivo &lt;code>out.txt&lt;/code> pode ser colocado da seguinte maneira com o log dos tempos (-t) opicional.&lt;/p>
&lt;pre>&lt;code class="language-bash">$ strace -f -t -etrace=write -s 666 -p PID_DO_PROCESSO 2&amp;gt;&amp;amp;1 | grep --line-buffered -e 'write(2, ' -e 'write(1, ' &amp;gt;&amp;gt; out.txt
&lt;/code>&lt;/pre>
&lt;p>O código abaixo tem uma alteração no &lt;code>server_mlops.py&lt;/code> , e execute ele assim como o &lt;code>client_mlops.py&lt;/code>. Pegando o PID do &lt;code>serve_mlops&lt;/code> você conseguirá explorar esse exemplo&lt;/p>
&lt;pre>&lt;code class="language-python"># server_mlops.py
import time
import flask
import sys
app = flask.Flask(__name__)
@app.route('/')
def hello_world():
sleep_time = flask.request.args.get('sleep', default=10, type=int)
print('sleep_time:', sleep_time)
for i in range(sleep_time):
print(f'INFO: {i} of sleep_time \n asdf \t ')
print(f'ERROR: Example msg {i}', file=sys.stderr)
time.sleep(1)
return 'Hello World!'
if __name__ == '__main__':
app.run()
&lt;/code>&lt;/pre>
&lt;h3 id="how-this-program-has-been-called-what-is-the-working-dir-of-the-process">How this program has been called? What is the working dir of the process?&lt;/h3>
&lt;p>Essa pergunta talvez não seja tão difícil de responder se você tem o &lt;code>htop&lt;/code> instalado. Mas supondo que você não lembra as informações sobre o comando que gerou o processo execute o comando abaixo&lt;/p>
&lt;pre>&lt;code class="language-bash">$ tr '\0' '\t' &amp;lt; /proc/PID_CLIENT_MLOPS/cmdline
&lt;/code>&lt;/pre>
&lt;p>o output será&lt;/p>
&lt;pre>&lt;code>python client_mlops.py --sleep 1000
&lt;/code>&lt;/pre>
&lt;p>Para descobrir o diretório do &lt;code>client_mlops.py&lt;/code> basta executar&lt;/p>
&lt;pre>&lt;code class="language-bash">$ readlink /proc/PID_CLIENT_MLOPS/cwd
&lt;/code>&lt;/pre>
&lt;h2 id="agradecimentos--sugestões">Agradecimentos &amp;amp; Sugestões&lt;/h2>
&lt;blockquote>
&lt;p>Achou um erro? Tem alguma sugestão ou dica? mande um email para
&lt;a href="mailto:devmessias@gmail.com">devmessias@gmail.com&lt;/a>.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>Obrigado
&lt;a href="https://www.linkedin.com/in/elisarma" target="_blank" rel="noopener">Elisa Ribeiro&lt;/a> por ter corrigido os typos da primeira versão do post.&lt;/li>
&lt;li>
&lt;a href="https://www.linkedin.com/in/reynaldoallanf" target="_blank" rel="noopener">Reynaldo Allan Fulin&lt;/a> pelas discussões sempre úteis sobre linux.&lt;/li>
&lt;/ul></description></item></channel></rss>