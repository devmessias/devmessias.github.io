<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>debugging | Bruno Messias</title>
    <link>/pt-br/tag/debugging/</link>
      <atom:link href="/pt-br/tag/debugging/index.xml" rel="self" type="application/rss+xml" />
    <description>debugging</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>pt-br</language><copyright>Bruno Messias</copyright><lastBuildDate>Fri, 08 Apr 2022 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/images/icon_hucd6a3d413e7b81060a1d462b35f64cf9_5018_512x512_fill_lanczos_center_2.png</url>
      <title>debugging</title>
      <link>/pt-br/tag/debugging/</link>
    </image>
    
    <item>
      <title>Going meta with python: manipulating ASTs to create an introspective decorator at runtime</title>
      <link>/pt-br/post/python_ast_and_decorators_with_locals/</link>
      <pubDate>Fri, 08 Apr 2022 00:00:00 +0000</pubDate>
      <guid>/pt-br/post/python_ast_and_decorators_with_locals/</guid>
      <description>&lt;details 
class=&#34;toc-inpage d-print-none d-none d-sm-block d-md-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;Lista de Conteúdos&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#intro-our-previous-problem&#34;&gt;Intro: our previous problem&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#asts-what-they-are&#34;&gt;ASTs: What they are?&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#python-interpreted-or-compiled&#34;&gt;Python: interpreted or compiled?&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#extracting-asts-and-interpreting-them&#34;&gt;Extracting ASTs and interpreting them&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#how-can-i-be-efficient-in-metaprogramming&#34;&gt;How can I be efficient in metaprogramming?&lt;/a&gt;
          &lt;ul&gt;
            &lt;li&gt;&lt;a href=&#34;#the-6-simple-steps&#34;&gt;The 6 simple steps&lt;/a&gt;&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#creating-our-metaprogramming-function&#34;&gt;Creating our metaprogramming function&lt;/a&gt;
          &lt;ul&gt;
            &lt;li&gt;&lt;a href=&#34;#first-six-steps-interaction&#34;&gt;First six-steps interaction&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&#34;#the-nodetransformer-class&#34;&gt;The NodeTransformer class&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&#34;#the-second-six-steps-interaction&#34;&gt;The second six-steps interaction&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&#34;#creating-a-new-function-at-runtime&#34;&gt;Creating a new function at runtime&lt;/a&gt;&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#integrating-the-ast-manipulation-with-a-decorator&#34;&gt;Integrating the AST manipulation with a decorator&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;h2 id=&#34;intro-our-previous-problem&#34;&gt;Intro: our previous problem&lt;/h2&gt;
&lt;p&gt;Don&amp;rsquo;t be afraid by the names on the title. Although they can seem scary or strange probably you already have been in touch with tools that work with this kind of stuff. For example, pytest and numba.&lt;/p&gt;
&lt;p&gt;In the previous post, I talked about python frames and inspection module. I&amp;rsquo;ve started showing how we can use the &lt;code&gt;inspect.signature&lt;/code&gt; to construct a decorator that validates arguments:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@math_validator()
def simple_method(x: &amp;quot;\in R&amp;quot;, y: &amp;quot;\in R_+&amp;quot;, z: float = 2) -&amp;gt; float:
    ...
simple_method(1, 0)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;simple_method((1, 2)) -&amp;gt; 1.5
---&amp;gt; 19 simple_method(1, 0)
...
&amp;lt;locals&amp;gt;.decorate.&amp;lt;locals&amp;gt;.decorated(*_args)
     11         continue
     13     if not MATH_SPACES[annotation][&amp;quot;validator&amp;quot;](_args[i]):
---&amp;gt; 14         raise ValueError(f&amp;quot;{k} doesn&#39;t belong to the {MATH_SPACES[annotation][&#39;name&#39;]}&amp;quot;)
     15 result = func(*_args)
     16 print(f&amp;quot;{func.__name__}({_args}) -&amp;gt; {result}&amp;quot;)

ValueError: y doesn&#39;t belong to the space of real numbers greater than zero
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And after that, I&amp;rsquo;ve combined the &lt;code&gt;inspect.singature&lt;/code&gt;+&lt;code&gt;sys.trace&lt;/code&gt;+&lt;code&gt;locals&lt;/code&gt; to construct a decorator that exposes the local variables of a decorated function. All this stuff allows us to do cool things like creating a generic report decorator that have access to the local variables of the decorated method&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@report(&#39;{arg.n_bananas} Monkey {gluttonous_monkey} ate too much bananas.  Num monkeys {num_monkeys}&#39;)
def feed_monkeys(n_bananas): 
    num_monkeys = 3
    monkeys = {
        f&amp;quot;monkey_{i}&amp;quot;: {&amp;quot;bananas&amp;quot;: 0}
        for i in range(num_monkeys)
    }
    while n_bananas &amp;gt; 0:
        if np.random.uniform() &amp;lt; 0.4:
            continue
        monkey = monkeys[np.random.choice(list(monkeys.keys()))]
        if n_bananas &amp;gt; 0:
            monkey[&amp;quot;bananas&amp;quot;] += 1
            n_bananas -= 1
    gluttonous_monkey = max(monkeys, key=lambda k: monkeys[k][&amp;quot;bananas&amp;quot;]) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These two examples can be found in real application scenarios. But at the end of my previous post I&amp;rsquo;ve told you some issues regarding the use of &lt;code&gt;sys.trace&lt;/code&gt;. I&amp;rsquo;ll put the code here of the previous solution:
&lt;div class=&#34;spoiler &#34; &gt;
  &lt;p&gt;
    &lt;a class=&#34;btn btn-primary&#34; data-toggle=&#34;collapse&#34; href=&#34;#spoiler-1&#34; role=&#34;button&#34; aria-expanded=&#34;false&#34; aria-controls=&#34;spoiler-1&#34;&gt;
      Click here to see the solution
    &lt;/a&gt;
  &lt;/p&gt;
  &lt;div class=&#34;collapse card &#34; id=&#34;spoiler-1&#34;&gt;
    &lt;div class=&#34;card-body&#34;&gt;
      &lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sys
import inspect
from types import SimpleNamespace


def call_and_extract_frame(func, *args, **kwargs):
    frame_var = None
    trace = sys.gettrace()
    def update_frame_var(stack_frame, event_name, arg_frame):
        &amp;quot;&amp;quot;&amp;quot;
        Args:
            stack_frame: (frame)
                The current stack frame.
            event_name: (str)
                The name of the event that triggered the call. 
                Can be &#39;call&#39;, &#39;line&#39;, &#39;return&#39; and &#39;exception&#39;.
            arg_frame: 
                Depends on the event. Can be a None type
        &amp;quot;&amp;quot;&amp;quot;
        nonlocal frame_var # nonlocal is a keyword which allows us to modify the outisde scope variable
        if event_name != &#39;call&#39;:
            return trace
        frame_var = stack_frame
        sys.settrace(trace)
        return trace
    sys.settrace(update_frame_var)
    try:
        func_result = func(*args, **kwargs)
    finally:
        sys.settrace(trace)
    return frame_var, func_result
def report(formater):
    def decorate(func):
        def decorated(*_args):
            sig = inspect.signature(func)
            named_args = {}
            num_args = len(_args)
            for i, (k, v) in enumerate(sig.parameters.items()):
                if i &amp;lt; num_args:
                    named_args[k] = repr(_args[i])
                else:
                    named_args[k] = repr(v.default)
            frame_func, _result = call_and_extract_frame(func, *_args)
            name = func.__name__
            result = repr(_result)
            
            args_dict = {
                &amp;quot;args&amp;quot;: SimpleNamespace(**named_args), 
                &amp;quot;args_repr&amp;quot;: repr(SimpleNamespace(**named_args)),
                **locals(),
                **frame_func.f_locals,
            }
            print(formater.format(**args_dict))
            # do other stuff here
            return _result 
        return decorated
    return decorate
&lt;/code&gt;&lt;/pre&gt;

    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;What are the problems with this solution?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A tracing always creates a cost. Thus, is expected that we will reduce the performance of our system. If you use this just for debugging purposes, it&amp;rsquo;s ok.&lt;/li&gt;
&lt;li&gt;This can create conflicts with other tools and libs that also trying to use the trace tool&lt;/li&gt;
&lt;li&gt;it seems dirty!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ok, maybe you&amp;rsquo;re asking yourself &lt;em&gt;&amp;ldquo;This guy is overthinking. Why he didn&amp;rsquo;t just do this?&amp;quot;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@report(&#39;stuff goes here&#39;)
def func(x, y):
    random_var = np.random.uniform()
    ... #more local vars
    result = (x+y)**random_var
    return result, locals 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&amp;rdquo;&amp;hellip;and then, inside of decorator change to this:&amp;quot;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;_result, local_vars = func(x, y)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The reason is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The main point of using this decorator is to avoid any change in other parts of the codebase. For example,
if in any part of the codebase &lt;code&gt;func&lt;/code&gt; has been called you will have to change to&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;result = func(x, y) # to 
result = func(x, y)[0]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If after you choose to remove the decorator from a function you will need to be rollback all the above changes.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You will increase the cognitive load in all members of the team who doesn&amp;rsquo;t care about what your decorator needs to do.&lt;/li&gt;
&lt;li&gt;If you propose this a solution is better just to create another function and face the consequences of this increase in complexity in the original codebase.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ok, maybe you&amp;rsquo;re now thinking: &amp;ldquo;&lt;em&gt;Right, this makes sense, but you&amp;rsquo;re avoiding theses issues creating issues in performance and debugging. Don&amp;rsquo;t sound good besides for just some special cases&lt;/em&gt;&amp;rdquo;. And I need to agree with you, &lt;strong&gt;it&amp;rsquo;s not a good solution for most of the cases!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Well, what we can do? The problem we&amp;rsquo;re facing is that python doesn&amp;rsquo;t have context managers that can deal with namespaces. Although there is an active discussion about this 
&lt;a href=&#34;https://mail.python.org/archives/list/python-ideas@python.org/thread/TAVHEKDZVYKJUGZKWSVZVAOGBPLZVKQG/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://mail.python.org/archives/list/python-ideas@python.org/&lt;/a&gt;. But don&amp;rsquo;t worry about this big name. The important point here is that:&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;strong&gt;If a language doesn&amp;rsquo;t have a feature that I need what can I do?&lt;/strong&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;In python we are fine with this because it&amp;rsquo;s a language that turns to be easy to manipulate what is called &lt;strong&gt;A&lt;/strong&gt;bstract &lt;strong&gt;S&lt;/strong&gt;yntax &lt;strong&gt;T&lt;/strong&gt;ree and recompile a function with the manipulated syntax tree. &lt;strong&gt;Doing that way we&amp;rsquo;re in the realm of metaprogramming. Writing code which writes code.&lt;/strong&gt; If t&amp;rsquo;s not clear I&amp;rsquo;ll try to be more clear now.&lt;em&gt;&amp;quot;&amp;hellip;and then, inside of decorator change to this:&amp;quot;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;_result, local_vars = func(x, y)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The reason is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The main point of using this decorator is to avoid any change in other parts of the codebase. For example,
if in any part of the codebase &lt;code&gt;func&lt;/code&gt; has been called you will have to change to&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;result = func(x, y) # to 
result = func(x, y)[0]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If after you choose to remove the decorator from a function you will need to be rollback all the above changes.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You will increase the cognitive load in all members of the team who doesn&amp;rsquo;t care about what your decorator needs to do.&lt;/li&gt;
&lt;li&gt;If you propose this a solution is better just to create another function and face the consequences of this increase of complexity in the original codebase.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ok, maybe you&amp;rsquo;re now thinking: &amp;ldquo;&lt;em&gt;Right, this makes sense, but you&amp;rsquo;re avoiding this issues creating issues in performance and debugging. Don&amp;rsquo;t sound good besides for just some special cases&lt;/em&gt;&amp;rdquo;. And I need to agree with you, &lt;strong&gt;it&amp;rsquo;s not a good solution for most of the cases!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Well, what we can do? The problem we&amp;rsquo;re facing is because python doesn&amp;rsquo;t have context managers that can deal with namespaces. Although there is an active discussion about this 
&lt;a href=&#34;https://mail.python.org/archives/list/python-ideas@python.org/thread/TAVHEKDZVYKJUGZKWSVZVAOGBPLZVKQG/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://mail.python.org/archives/list/python-ideas@python.org/&lt;/a&gt;. But don&amp;rsquo;t worry about this big name. The important point here is that:&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;strong&gt;If a language doesn&amp;rsquo;t have a feature that I need what can I do?&lt;/strong&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;In python we are fine with this because it&amp;rsquo;s a language that turns to be easy to manipulate what is called &lt;strong&gt;A&lt;/strong&gt;bstract &lt;strong&gt;S&lt;/strong&gt;yntax &lt;strong&gt;T&lt;/strong&gt;ree and recompile a function with the manipulated syntax tree. &lt;strong&gt;Doing that way we&amp;rsquo;re in the realm of metaprogramming. Writing code which writes code.&lt;/strong&gt; If t&amp;rsquo;s not clear I&amp;rsquo;ll try to be more clear now.&lt;/p&gt;
&lt;h2 id=&#34;asts-what-they-are&#34;&gt;ASTs: What they are?&lt;/h2&gt;
&lt;p&gt;A programming language obviously is at least a language. OK, &lt;strong&gt;but what is a language?
Do all the human languages share the same building blocks? How can we compare different sentences?&lt;/strong&gt;
These questions seem more proper to be answered by philosophers. Well, maybe this is true, but these questions can also be answered by mathematicians and computer scientists. Although, mathematicians and CS people usually prefer to talk using mathematical formalism rather than long debates about the meaning of the stuff. In essence, an &lt;strong&gt;AST&lt;/strong&gt; is a mathematical formalism that allows us to represent a sentence using a well-defined set of rules and structures represented by a tree.&lt;/p&gt;
&lt;h3&gt;How do you know that a sentence is grammatically correct?&lt;/h3&gt; 
&lt;p&gt;Intuitively, probably you remember  a set of rules that you learned during your life about how to organize and compose verbs, nouns, adjectives, adverbs, etc. This set of rules and guidelines is the &lt;em&gt;Syntax&lt;/em&gt; of a language. A &lt;strong&gt;S&lt;/strong&gt;yntax &lt;strong&gt;T&lt;/strong&gt;ree is a structure that helps us to understand a sentence.&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    After constructing the syntax tree we can look in the guidelines book of our language and check if this tree has a valid structure.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Take for example
the sentence: &lt;em&gt;&amp;ldquo;I drive a car to my college&amp;rdquo;&lt;/em&gt;, the syntax tree is the following:&lt;/p&gt;







  
  















&lt;figure id=&#34;figure-a-syntax-tree-for-the-sentence-i-drive-a-car-to-my-college-source-geeks-for-geekssyntax-tree--natural-language-processinghttpswwwgeeksforgeeksorgsyntax-tree-natural-language-processing&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/pt-br/post/python_ast_and_decorators_with_locals/ast_english_sentence_hue5b8d52ce962721ee6d0acb19268cb10_239788_0x400_resize_lanczos_2.png&#34; data-caption=&#34;A &amp;lt;strong&amp;gt;S&amp;lt;/strong&amp;gt;yntax &amp;lt;strong&amp;gt;T&amp;lt;/strong&amp;gt;ree for the sentence: &amp;lt;em&amp;gt;I drive a car to my college&amp;lt;/em&amp;gt;. &amp;lt;strong&amp;gt;Source&amp;lt;/strong&amp;gt;:&amp;lt;a href=&amp;#34;https://www.geeksforgeeks.org/syntax-tree-natural-language-processing/&amp;#34;&amp;gt; Geeks for Geeks:Syntax Tree – Natural Language Processing.&amp;lt;/a&amp;gt;&#34;&gt;


  &lt;img src=&#34;/pt-br/post/python_ast_and_decorators_with_locals/ast_english_sentence_hue5b8d52ce962721ee6d0acb19268cb10_239788_0x400_resize_lanczos_2.png&#34; alt=&#34;&#34;  height=&#34;400px&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    A &lt;strong&gt;S&lt;/strong&gt;yntax &lt;strong&gt;T&lt;/strong&gt;ree for the sentence: &lt;em&gt;I drive a car to my college&lt;/em&gt;. &lt;strong&gt;Source&lt;/strong&gt;:&lt;a href=&#34;https://www.geeksforgeeks.org/syntax-tree-natural-language-processing/&#34;&gt; Geeks for Geeks:Syntax Tree – Natural Language Processing.&lt;/a&gt;
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;What is the advantage of using ASTs? Notice that we don&amp;rsquo;t need to talk about how many spaces you&amp;rsquo;re using, we didn&amp;rsquo;t talk about your calligraphy and besides that, &lt;strong&gt;we have a hierarchy structure that allows us to analyze the validity of the sentence per level! If we want to change any element of the sentence we can directly manipulate the node which represents that element for a safe guarantee that the manipulated sentence is still grammatically correct!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s not a surprise that ASTs are also a common tool used in computer science to analyze the correctness of a piece of code and as a common part of the process of compiling/interpreting a code. Here we will extend the behavior of a python decorator manipulating the AST. But before that, I would like to ask you a question:&lt;/p&gt;
&lt;h5 class=&#34;text-center&#34;&gt;Is Python an interpreted language?&lt;/h5&gt;
&lt;h2 id=&#34;python-interpreted-or-compiled&#34;&gt;Python: interpreted or compiled?&lt;/h2&gt;
&lt;p&gt;Usually, when I meet a python hater (or even an enthusiast) they say phrases like that&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&amp;ldquo;Python is slow because it&amp;rsquo;s an interpreted language!&amp;quot;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&amp;ldquo;Python sucks because doesn&amp;rsquo;t have a compiler!&amp;quot;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Well, these assertions are not true. The important point is that: &lt;em&gt;when people refer to python commonly they are actually talking about the language python and the CPython virtual machine&lt;/em&gt;. Let&amp;rsquo;s talk more about these misconceptions.&lt;/p&gt;
&lt;p&gt;First, the distinction between interpreted and compiled languages is very blurry today.
Second, let&amp;rsquo;s see a nasty thing&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;hello_world = &amp;quot;print(&#39;Hello, world!&#39;)&amp;quot;
hello_world_obj = compile(hello_world, &#39;&amp;lt;string&amp;gt;&#39;, &#39;single&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Yeah, if you&amp;rsquo;re trying to defend that python is interpreted the things start to get more hard for you. &lt;strong&gt;Why is there a &lt;strong&gt;compile&lt;/strong&gt;  available?&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;exec(hello_world_obj)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Hello, world!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I&amp;rsquo;m executing a thing that has been compiled??? What is this hello_world_obj?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(f&amp;quot;Bad news for you:\n\tContent: {hello_world_obj.co_code}\n\tType: {type(hello_world_obj.co_code)}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Bad news for you:
	Content: b&#39;e\x00d\x00\x83\x01F\x00d\x01S\x00&#39;
	Type: &amp;lt;class &#39;bytes&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But what is this stuff?&lt;/p&gt;
&lt;p&gt;Is important to understand what happens behind the scenes.&lt;/p&gt;
&lt;p&gt;After you write a python code and call the python command, python starts a compiling phase creating the ASTs; generating the bytecotes that will be attached to &lt;strong&gt;code objects&lt;/strong&gt;, and then, these code objects will be interpreted by the CPython virtual machine. The diagram below is a simple representation of this process with some details hidden&lt;/p&gt;
&lt;div class=&#34;mermaid mermaidContainer&#34;&gt;
graph LR;
A[Source Code]--&gt;|parsing|B[Parse Tree];
B--&gt;C[AST];
C--&gt;E[Bytecode];
E--&gt;F[Code Object];
F--&gt;|execution by|G[CPython Virtual Machine];
&lt;/div&gt;
&lt;p&gt;The compilation phase are the firts steps of the above diagram&lt;/p&gt;
&lt;div class=&#34;mermaid mermaidContainer&#34;&gt;
graph LR;
A[Source Code]--&gt;|parsing|B[Parse Tree];
B--&gt;C[AST];
C--&gt;E[Bytecode];
E--&gt;F[Code Object];
&lt;/div&gt;
&lt;p&gt;But don&amp;rsquo;t worry about most of the big names above. The only concepts that will matter to us are the AST, bytecodes, and Code object.
&lt;strong&gt;Bytecodes are just a compact way to tell the interpreter what we want to do.
The code object is just a way to encapsulate the bytecodes extracted from the AST.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;But how does this help us?&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Our solution will involve the manipulation of the AST and after that generating a new code object with the related manipulated AST!
  &lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;extracting-asts-and-interpreting-them&#34;&gt;Extracting ASTs and interpreting them&lt;/h2&gt;
&lt;p&gt;Let&amp;rsquo;s see a simple example of a function and the extracted AST.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import inspect
import ast
import astor # install this for pretty printing
def example(a: float, b:float = 2) -&amp;gt; float:
    s = a+b
    return s

tree = ast.parse(inspect.getsource(example))
print(astor.dump(tree))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Module(
    body=[
        FunctionDef(name=&#39;example&#39;,
            args=arguments(posonlyargs=[],
                args=[arg(arg=&#39;a&#39;, annotation=Name(id=&#39;float&#39;), type_comment=None),
                    arg(arg=&#39;b&#39;, annotation=Name(id=&#39;float&#39;), type_comment=None)],
                vararg=None,
                kwonlyargs=[],
                kw_defaults=[],
                kwarg=None,
                defaults=[Constant(value=2, kind=None)]),
            body=[
                Assign(targets=[Name(id=&#39;s&#39;)],
                    value=BinOp(left=Name(id=&#39;a&#39;), op=Add, right=Name(id=&#39;b&#39;)),
                    type_comment=None),
                Return(value=Name(id=&#39;s&#39;))],
            decorator_list=[],
            returns=Name(id=&#39;float&#39;),
            type_comment=None)],
    type_ignores=[])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above output is our AST, take some time looking into it to see how all our code stuff is organized.
The image below shows the graph representation of the above output&lt;/p&gt;







  
  















&lt;figure &gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/pt-br/post/python_ast_and_decorators_with_locals/simple_ast_hudca446749283cbe6d28b67a245474890_120568_0x1000_resize_lanczos_2.png&#34; &gt;


  &lt;img src=&#34;/pt-br/post/python_ast_and_decorators_with_locals/simple_ast_hudca446749283cbe6d28b67a245474890_120568_0x1000_resize_lanczos_2.png&#34; alt=&#34;&#34;  height=&#34;400px&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;Each element in the above output with an upper case letter is a &lt;strong&gt;node&lt;/strong&gt; (Name, BinOp, FunctionDef, etc)  from the base class &lt;code&gt;ast.Node&lt;/code&gt;. One of the most important node types are the &lt;code&gt;ast.Name&lt;/code&gt;.
For example,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;value=BinOp(left=Name(id=&#39;a&#39;), op=Add, right=Name(id=&#39;b&#39;)),
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;the &lt;code&gt;ast.Name&lt;/code&gt; is used to refer a variable by the name, &lt;code&gt;id&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now let&amp;rsquo;s come back to our problem. Remember that one bad solution it was rewriting every function&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def func(x, y):
    random_var = np.random.uniform()
    ... #more local vars
    result = (x+y)**random_var
    return result
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;as&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def func_transformed(x, y):
    random_var = np.random.uniform()
    ... #more local vars
    result = (x+y)**random_var
    return result, locals 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The big stuff that we will do is to &lt;strong&gt;write a function that codes new functions for us! This is metaprogramming!&lt;/strong&gt; And at same time we will write a decorator that will avoid any change in our codebase!&lt;/p&gt;
&lt;h2 id=&#34;how-can-i-be-efficient-in-metaprogramming&#34;&gt;How can I be efficient in metaprogramming?&lt;/h2&gt;
&lt;p&gt;We must create a function that generates a new one similar to &lt;code&gt;func_transformed&lt;/code&gt;. How to get an idea of what we need to do?&lt;/p&gt;
&lt;h3 id=&#34;the-6-simple-steps&#34;&gt;The 6 simple steps&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Create an example function&lt;/li&gt;
&lt;li&gt;Code the transformed function from the example function&lt;/li&gt;
&lt;li&gt;Code a simple test to check if the transformed function is correct&lt;/li&gt;
&lt;li&gt;Extract the AST from the example and the transformed function&lt;/li&gt;
&lt;li&gt;Compare the ASTs. What is the difference? Annotate this difference somewhere
&lt;ul&gt;
&lt;li&gt;You can use the &lt;code&gt;difflib&lt;/code&gt; module that comes with python to diff strings&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Creates a new and more complex example function and repeats the process until you get a good  idea of what you need to do.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;After you have a good idea of what you need to do, you can start writing your metaprogramming function.&lt;/p&gt;
&lt;h2 id=&#34;creating-our-metaprogramming-function&#34;&gt;Creating our metaprogramming function&lt;/h2&gt;
&lt;h3 id=&#34;first-six-steps-interaction&#34;&gt;First six-steps interaction&lt;/h3&gt;
&lt;p&gt;Let&amp;rsquo;s start our first interaction writing one function, the expected transformed function and the test to check if it is correct.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def example_1(x, y):
    internal_var  =  222
    result = (x+y)**internal_var
    return result
def example_1_expected(x, y):
    internal_var = 222
    result = (x+y)**internal_var
    return result, locals()

def test_meta_example_1(meta_func, x, y):
    expected_result, expected_locals = example_1_expected(x, y)
    result, locals_dict = meta_func(x, y)
    assert result == expected_result
    assert expected_locals == locals_dict
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Everything looks fine. Now we will use the &lt;code&gt;difflib&lt;/code&gt; to see the differences between the two ASTs.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import difflib
from pprint import pprint

example_1_ast_str = astor.dump_tree(ast.parse(inspect.getsource(example_1)))
example_1_expected_str = astor.dump_tree(ast.parse(inspect.getsource(example_1_expected)))


pprint(
    list(
        difflib.unified_diff(example_1_ast_str.splitlines(), example_1_expected_str.splitlines(), n=0)
    )
)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[&#39;--- \n&#39;,
 &#39;+++ \n&#39;,
 &#39;@@ -3 +3 @@\n&#39;,
 &amp;quot;-        FunctionDef(name=&#39;example_1&#39;,&amp;quot;,
 &amp;quot;+        FunctionDef(name=&#39;example_1_expected&#39;,&amp;quot;,
 &#39;@@ -19 +19 @@\n&#39;,
 &amp;quot;-                Return(value=Name(id=&#39;result&#39;))],&amp;quot;,
 &amp;quot;+                Return(value=Tuple(elts=[Name(id=&#39;result&#39;), &amp;quot;
 &amp;quot;Call(func=Name(id=&#39;locals&#39;), args=[], keywords=[])]))],&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we know that we must change this Node in the AST&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Return(value=Name(id=&#39;result&#39;))],
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To this&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Return(value=Tuple(elts=[Name(id=&#39;result&#39;), Call(func=Name(id=&#39;locals&#39;), args=[], keywords=[])]))],
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;How we can do this? With the help of &lt;code&gt;NodeTransformer&lt;/code&gt; class&lt;/p&gt;
&lt;h3 id=&#34;the-nodetransformer-class&#34;&gt;The NodeTransformer class&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;ast.NodeTransformer&lt;/code&gt; allows us to create objects with a walker-like interface. The walker will visit each node in the AST and during each visit, the walker can remove, replace, modify or add nodes, and after that, he can continue to walk to the childreens of the node or stop there.&lt;/p&gt;
&lt;p&gt;How can we use this?
First, we start by creating a new class derived from &lt;code&gt;ast.NodeTransformer&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class ASTTransformer(ast.NodeTransformer):
    def visit_Return(self, node):
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you want to interact/change/delete a node of type &lt;code&gt;Something&lt;/code&gt; you must override the &lt;code&gt;visit_Something&lt;/code&gt; method. Thus, because we need to change the &lt;code&gt;Return&lt;/code&gt; node we override the &lt;code&gt;visit_Return&lt;/code&gt;. If we do just the following, our walker will not change our AST,&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class ASTTransformer(ast.NodeTransformer):
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&amp;rsquo;s start the modifications. We need to create a new node responsible to call the &lt;code&gt;locals&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class ASTTransformer(ast.NodeTransformer):
    def visit_Return(self, node):
        node_locals = ast.Call(
            func=ast.Name(id=&#39;locals&#39;, ctx=ast.Load()),
            args=[], keywords=[]
        )
        self.generic_visit(node)
        return node
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We used a &lt;code&gt;Name&lt;/code&gt; node to identify the &lt;code&gt;locals&lt;/code&gt; function. Now, according to the diff result our &lt;code&gt;Return&lt;/code&gt; node must be transformed into a &lt;code&gt;Return&lt;/code&gt; of a Tuple node&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class ASTTransformer(ast.NodeTransformer):
    def visit_Return(self, node):
        node_locals = ast.Call(
            func=ast.Name(id=&#39;locals&#39;, ctx=ast.Load()),
            args=[], keywords=[]
        )
        new_node.value = ast.Tuple(
            elts=[
                node.value,
                node_locals
            ],
            ctx=ast.Load()
        )
        self.generic_visit(new_node)
        return new_node
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A new thing appeared. The &lt;code&gt;elts&lt;/code&gt; argument. But don&amp;rsquo;t worry, this is just an argument which tells what is the list of other nodes &lt;code&gt;Tuple&lt;/code&gt; has. Whenever you have some doubt about AST stuff, you can check the &lt;code&gt;ast&lt;/code&gt; documentation 
&lt;a href=&#34;https://docs.python.org/3/library/ast.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;. The documentation is simple to understand because python is simple!&lt;/p&gt;
&lt;p&gt;Everything is almost done. The last thing is to fix our AST. Because when we change the Node we need to fill missing information like the line_number and column_offset. Thanks to python we just need to call &lt;code&gt;fix_missing_locations&lt;/code&gt;  to fill this for us.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
class ASTTransformer(ast.NodeTransformer):
    def visit_Return(self, node):
        new_node = node
        node_locals = ast.Call(
            func=ast.Name(id=&#39;locals&#39;, ctx=ast.Load()),
            args=[], keywords=[]
        )
        new_node.value = ast.Tuple(
            elts=[
                node.value,
                node_locals
            ],
            ctx=ast.Load()
        )
        ast.copy_location(new_node, node)
        ast.fix_missing_locations(new_node)
        self.generic_visit(new_node)
        return new_node
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ok, let&amp;rsquo;s see if is working. We must instantiate our transformer and call the &lt;code&gt;visit&lt;/code&gt; method that tells the walker to walk in the AST and do all the modification we&amp;rsquo;re asking&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tree_meta = ast.parse(inspect.getsource(example_1))
transformer = ASTTransformer()
transformer.visit(tree_meta)
example_1_meta_ast_str = astor.dump_tree(tree_meta)
example_1_expected_str = astor.dump_tree(ast.parse(inspect.getsource(example_1_expected)))


pprint(
    list(
        difflib.unified_diff(example_1_meta_ast_str.splitlines(), example_1_expected_str.splitlines(), n=0)
    )
)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[&#39;--- \n&#39;,
 &#39;+++ \n&#39;,
 &#39;@@ -3 +3 @@\n&#39;,
 &amp;quot;-        FunctionDef(name=&#39;example_1&#39;,&amp;quot;,
 &amp;quot;+        FunctionDef(name=&#39;example_1_expected&#39;,&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our first iteration was successful! Let&amp;rsquo;s try a more complex example.&lt;/p&gt;
&lt;h3 id=&#34;the-second-six-steps-interaction&#34;&gt;The second six-steps interaction&lt;/h3&gt;
&lt;p&gt;We&amp;rsquo;ll just add more complexity without any particular meaning, we can be creative!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def example_2(x, y):
    internal_var  =  222
    def sub(x, y):
        ommit_this_var = 1
        return x - y
    result = sub(x,y)**internal_var
    return (result, False)
def example_2_expected(x, y):
    internal_var  =  222
    def sub(x, y):
        ommit_this_var = 1
        return x - y
    result = sub(x,y)**internal_var
    return ((result, False), locals())
def test_meta_example_2(meta_func, x, y):
    expected_result, expected_locals = example_2_expected(x, y)
    result, locals_dict = meta_func(x, y)
    del locals_dict[&amp;quot;sub&amp;quot;]
    del expected_locals[&amp;quot;sub&amp;quot;]
    assert result == expected_result
    assert expected_locals == locals_dict
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;example_2_ast_str = astor.dump_tree(ast.parse(inspect.getsource(example_2)))
example_2_expected_str = astor.dump_tree(ast.parse(inspect.getsource(example_2_expected)))


pprint(
    list(
        difflib.unified_diff(example_2_ast_str.splitlines(), example_2_expected_str.splitlines(), n=0)
    )
)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[&#39;--- \n&#39;,
 &#39;+++ \n&#39;,
 &#39;@@ -3 +3 @@\n&#39;,
 &amp;quot;-        FunctionDef(name=&#39;example_2&#39;,&amp;quot;,
 &amp;quot;+        FunctionDef(name=&#39;example_2_expected&#39;,&amp;quot;,
 &#39;@@ -37 +37,4 @@\n&#39;,
 &amp;quot;-                Return(value=Tuple(elts=[Name(id=&#39;result&#39;), &amp;quot;
 &#39;Constant(value=False, kind=None)]))],&#39;,
 &#39;+                Return(&#39;,
 &#39;+                    value=Tuple(&#39;,
 &amp;quot;+                        elts=[Tuple(elts=[Name(id=&#39;result&#39;), &amp;quot;
 &#39;Constant(value=False, kind=None)]),&#39;,
 &amp;quot;+                            Call(func=Name(id=&#39;locals&#39;), args=[], &amp;quot;
 &#39;keywords=[])]))],&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, it&amp;rsquo;s time to cross the fingers and see if we need working more&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tree_meta = ast.parse(inspect.getsource(example_2))
transformer = ASTTransformer()
transformer.visit(tree_meta)
example_2_meta_ast_str = astor.dump_tree(tree_meta)
example_2_expected_str = astor.dump_tree(ast.parse(inspect.getsource(example_2_expected)))


pprint(
    list(
        difflib.unified_diff(example_2_meta_ast_str.splitlines(), example_2_expected_str.splitlines(), n=0)
    )
)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[&#39;--- \n&#39;,
 &#39;+++ \n&#39;,
 &#39;@@ -3 +3 @@\n&#39;,
 &amp;quot;-        FunctionDef(name=&#39;example_2&#39;,&amp;quot;,
 &amp;quot;+        FunctionDef(name=&#39;example_2_expected&#39;,&amp;quot;,
 &#39;@@ -27,4 +27 @@\n&#39;,
 &#39;-                        Return(&#39;,
 &#39;-                            value=Tuple(&#39;,
 &amp;quot;-                                elts=[BinOp(left=Name(id=&#39;x&#39;), op=Sub, &amp;quot;
 &amp;quot;right=Name(id=&#39;y&#39;)),&amp;quot;,
 &amp;quot;-                                    Call(func=Name(id=&#39;locals&#39;), args=[], &amp;quot;
 &#39;keywords=[])]))],&#39;,
 &amp;quot;+                        Return(value=BinOp(left=Name(id=&#39;x&#39;), op=Sub, &amp;quot;
 &amp;quot;right=Name(id=&#39;y&#39;)))],&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unfortunately, our &lt;code&gt;ASTTransformer&lt;/code&gt; was not able to deal with this crazy guy. What is the problem? If you check carefully you will notice that the inner function &lt;code&gt;def sub&lt;/code&gt; is the problem. We don&amp;rsquo;t want to change any &amp;ldquo;sub&amp;rdquo; function, so we need to tell our walker to avoid changing this kind of stuff. To do so, we will create a flag to tell if the walker is in a sub-function, and we will just override the &lt;code&gt;visit_FunctionDef&lt;/code&gt; method to check this flag&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class ASTTransformer(ast.NodeTransformer):
    def visit_FunctionDef(self, node):
        if self._sub:
            return node
        self._sub = True
        self.generic_visit(node)
        return node

    def visit_Module(self, node):
        self._sub = 0
        self.generic_visit(node)

    def visit_Return(self, node):
        new_node = node
        node_locals = ast.Call(
            func=ast.Name(id=&#39;locals&#39;, ctx=ast.Load()),
            args=[], keywords=[]
        )
        new_node.value = ast.Tuple(
            elts=[
                node.value,
                node_locals
            ],
            ctx=ast.Load()
        )
        ast.copy_location(new_node, node)
        ast.fix_missing_locations(new_node)
        self.generic_visit(new_node)
        return new_node 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tree_meta = ast.parse(inspect.getsource(example_2))
transformer = ASTTransformer()
transformer.visit(tree_meta)
example_2_meta_ast_str = astor.dump_tree(tree_meta)
example_2_expected_str = astor.dump_tree(ast.parse(inspect.getsource(example_2_expected)))


pprint(
    list(
        difflib.unified_diff(example_2_meta_ast_str.splitlines(), example_2_expected_str.splitlines(), n=0)
    )
)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[&#39;--- \n&#39;,
 &#39;+++ \n&#39;,
 &#39;@@ -3 +3 @@\n&#39;,
 &amp;quot;-        FunctionDef(name=&#39;example_2&#39;,&amp;quot;,
 &amp;quot;+        FunctionDef(name=&#39;example_2_expected&#39;,&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our new &lt;code&gt;ASTTransformer&lt;/code&gt; was able to deal with our new complicated example!&lt;/p&gt;
&lt;h3 id=&#34;creating-a-new-function-at-runtime&#34;&gt;Creating a new function at runtime&lt;/h3&gt;
&lt;p&gt;We have a &lt;code&gt;ASTTransformer&lt;/code&gt; , now we must compile the transformed &lt;code&gt;AST&lt;/code&gt; into a new function. In python, we can create a new function using the &lt;code&gt;FunctionType&lt;/code&gt;, see below&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from types import FunctionType, CodeType

def transform_and_compile(func: FunctionType)-&amp;gt;FunctionType:
    source = inspect.getsource(func)
    # we put this to remove the line from source code with the decorator
    source = &amp;quot;\n&amp;quot;.join([l for l in source.splitlines() if not l.startswith(&amp;quot;@&amp;quot;)])
    tree = ast.parse(source)
    transformer = ASTTransformer()
    transformer.visit(tree)
    code_obj = compile(tree, func.__code__.co_filename, &#39;exec&#39;)
    function_code = [c for c in code_obj.co_consts if isinstance(c, CodeType)][0]
    # we must to pass the globals context to the function
    transformed_func = FunctionType(function_code, func.__globals__)
    return transformed_func
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;test_meta_example_1(transform_and_compile(example_1), 4, 2)
test_meta_example_2(transform_and_compile(example_2), 1, 2)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;transform_and_compile&lt;/code&gt; was able to create new functions that passed in all the tests! We can now move further to the final and easy step which is just to integrate this function with our decorator!&lt;/p&gt;
&lt;h2 id=&#34;integrating-the-ast-manipulation-with-a-decorator&#34;&gt;Integrating the AST manipulation with a decorator&lt;/h2&gt;
&lt;p&gt;We will call the &lt;code&gt;transform_and_compile&lt;/code&gt; right after the &lt;code&gt;def decorate&lt;/code&gt; to avoid unnecessary compilations every time that the decorated function is called.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def report(fmt):
    def decorate(func):
        meta_func = transform_and_compile(func)
        ....
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Inside &lt;code&gt;def decorated&lt;/code&gt; we call the &lt;code&gt;meta_func&lt;/code&gt; and return just the result because we don&amp;rsquo;t want to change our codebase.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def report(fmt):
    def decorate(func):
        meta_func = transform_and_compile(func)
        ...
        def decorated(*_args):
            _result, internal_locals = meta_func(*_args)
            ....
            return _result
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With all the stuff we learned in the previous post our &lt;code&gt;report&lt;/code&gt; decorator with the above changes will be&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
def report(fmt):
    def decorate(func):
        meta_func = transform_and_compile(func)
        sig = inspect.signature(func)
        def decorated(*_args):
            _result, internal_locals = meta_func(*_args)
            named_args = {}
            num_args = len(_args)
            for i, (k, v) in enumerate(sig.parameters.items()):
                if i &amp;lt; num_args:
                    named_args[k] = repr(_args[i])
                else:
                    named_args[k] = repr(v.default)
            
            name = func.__name__
            result = repr(_result)
            args_dict = {
                **internal_locals,
                **locals(),
                **named_args
            }
            print(fmt.format(**args_dict))
            # store the information in some place
            return result
        return decorated 
    return decorate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&amp;rsquo;s see the result with a dummy function&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@report(fmt=&#39;{name}(a={a}, b={b}, c={c}); sum_ab {sum_ab}, diff_ab {dif_ab}; r={result}&#39;)
def dummy_example(a, b, c=2):
    sum_ab = a + b
    dif_ab = a - b
    r = sum_ab**c + dif_ab**c
    return r

r = dummy_example(2, 3, 1)
print(&amp;quot;r:&amp;quot;, r)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;dummy_example(a=2, b=3, c=1); sum_ab 5, diff_ab -1; r=4
r: 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I know this post is quite hard to read, but I think it&amp;rsquo;s worth to share it. I hope you enjoyed it!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>An introspective python decorator using  stack frames and the inspect module</title>
      <link>/pt-br/post/python_decorator_that_exposes_locals/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      <guid>/pt-br/post/python_decorator_that_exposes_locals/</guid>
      <description>&lt;details 
class=&#34;toc-inpage d-print-none d-none d-sm-block d-md-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;Lista de Conteúdos&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#gaining-a-deeper-understanding-about-the-execution-context-of-a-function&#34;&gt;Gaining a deeper understanding about the execution context of a function&lt;/a&gt;
          &lt;ul&gt;
            &lt;li&gt;&lt;a href=&#34;#the-fluent-python-book-example&#34;&gt;The Fluent Python Book example&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&#34;#current-issues-and-limitations&#34;&gt;Current issues and limitations&lt;/a&gt;&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#creating-an-introspective-code-with-the-inspect-module&#34;&gt;Creating an introspective code with the inspect module&lt;/a&gt;
          &lt;ul&gt;
            &lt;li&gt;&lt;a href=&#34;#a-decorator-that-validates-arguments-using-mathematical-notation&#34;&gt;A decorator that validates arguments using mathematical notation&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&#34;#going-back-to-the-fluent-python-example&#34;&gt;Going back to the Fluent python example&lt;/a&gt;&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#how-to-expose-the-locals-inside-of-a-decorator&#34;&gt;How to expose the locals() inside of a decorator?&lt;/a&gt;
          &lt;ul&gt;
            &lt;li&gt;&lt;a href=&#34;#call-stack-and-frames-in-python&#34;&gt;Call stack and frames in python&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&#34;#using-systrace-to-track-our-frames&#34;&gt;Using sys.trace to track our frames&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&#34;#lets-solve-our-problem&#34;&gt;Let&amp;rsquo;s solve our problem&lt;/a&gt;&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#conclusion-and-next-steps&#34;&gt;Conclusion and next steps&lt;/a&gt;
          &lt;ul&gt;
            &lt;li&gt;&lt;a href=&#34;#it-depends&#34;&gt;&amp;ldquo;&amp;hellip;it depends&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&#34;#the-next-step-we-dont-need-a-trace-we-can-do-better-using-ast-manipulation&#34;&gt;The next step: we don&amp;rsquo;t need a trace! We can do better using AST manipulation&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&#34;#simplenamespace-for-dictkey-instead-of-dictkey&#34;&gt;SimpleNamespace for dict.key instead of dict[&amp;ldquo;key]&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&#34;#want-to-know-more-about-call-stack--inspect-and-trace&#34;&gt;Want to know more about call stack , inspect and trace?&lt;/a&gt;&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.amazon.com.br/Fluent-Python-Luciano-Ramalho/dp/1491946008&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Fluent Python&lt;/a&gt; is the best resource to learn to use and love python. Some days ago I was reading a section of the chapter 7: &lt;em&gt;&amp;ldquo;Function Decorators and Closures&lt;/em&gt;&amp;rdquo;. This chapter has a lot of interesting and cool examples. Here I&amp;rsquo;ll discuss one of them and how I tried to put more shiny stuff in it.&lt;/p&gt;
&lt;h2 id=&#34;gaining-a-deeper-understanding-about-the-execution-context-of-a-function&#34;&gt;Gaining a deeper understanding about the execution context of a function&lt;/h2&gt;
&lt;h3 id=&#34;the-fluent-python-book-example&#34;&gt;The Fluent Python Book example&lt;/h3&gt;
&lt;p&gt;Ramalho’s book presents us with a &lt;code&gt;@clock&lt;/code&gt; decorator that can be used to decorate a method, measure the time it takes to execute, and print in a human-readable format the arguments and name of the method. The example is shown below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import time

DEFAULT_FMT = &#39;[{elapsed:0.8f}s] {name}({args}) -&amp;gt; {result}&#39;

def clock(fmt=DEFAULT_FMT):
    def decorate(func):
        def clocked(*_args):
            t0 = time.time()
            _result = func(*_args)
            elapsed = time.time() - t0
            name = func.__name__
            args = &#39;, &#39;.join(repr(arg) for arg in _args)
            result = repr(_result)
            log_string = fmt.format(**locals())
            # send to somewhere 
            # csv, ELK, etc
            print(log_string)
            return result
        return clocked
    return decorate

@clock(&#39;[{elapsed:0.8f}s] {name}({args})&#39;)
def snooze(seconds):
    time.sleep(seconds)
    return time.time()

for _ in range(3):
    snooze(.123)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[0.12315798s] snooze(0.123)
[0.12315822s] snooze(0.123)
[0.12317085s] snooze(0.123)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&amp;rsquo;t understand something in the above code I recommend that you take some time searching and reading about each aspect. There are many cool things being used there, for example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;repr&lt;/code&gt; which is a function that returns a string representation of an object.
&lt;ul&gt;
&lt;li&gt;This is essential because the &lt;code&gt;DEFAULT_FMT&lt;/code&gt; is a string, not a &lt;code&gt;f-string&lt;/code&gt;, we can&amp;rsquo;t just put a generic object to be printed in &lt;code&gt;DEFAULT_FMT&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;log_string = fmt.format(**locals())&lt;/code&gt;: instead of creating a repetitive code like &lt;code&gt;fmt.format(**{&amp;quot;result&amp;quot;:result, &amp;quot;args&amp;quot;:args, ...})&lt;/code&gt; we can just use the &lt;code&gt;locals()&lt;/code&gt; which is a dictionary that contains all the local variables of the current scope.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When I study something I always like to create a fresh problem with the stuff that I&amp;rsquo;ve learned and try to solve it. Sometimes there is no solution. But even if there is no solution, we still learn a lot trying to solve the problem.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;ve started by creating the following example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import numpy as np

@clock(&#39;[{elapsed:0.8f}s] {name}({args})&#39;)
def snooze_and_snore(seconds, snore_loud, min_prob_to_snore=0.4):
    time.sleep(seconds)
    to_snore = np.random.uniform() &amp;gt; min_prob_to_snore
    if to_snore:
        if snore_loud:
            pass
            # r.requets(wake_up_everyone)
        pass
    return time.time()

for _ in range(3):
    snooze_and_snore(.4, True, .1)
    snooze_and_snore(.4, False, .1)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[0.40229130s] snooze_and_snore(0.4, True, 0.1)
[0.40049720s] snooze_and_snore(0.4, False, 0.1)
[0.40058565s] snooze_and_snore(0.4, True, 0.1)
[0.40013075s] snooze_and_snore(0.4, False, 0.1)
[0.40052223s] snooze_and_snore(0.4, True, 0.1)
[0.40057564s] snooze_and_snore(0.4, False, 0.1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ok, what are the problems/issues/limitations that the above code showed  me?&lt;/p&gt;
&lt;h3 id=&#34;current-issues-and-limitations&#34;&gt;Current issues and limitations&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;We don&amp;rsquo;t have information about the names of the arguments passed to the method.
&lt;ul&gt;
&lt;li&gt;If the list of arguments is long, trying to understand what is happening becomes a hard task. Because we are increasing the amount of stuff that we must  keep in our mind. We are increasing the &lt;strong&gt;cognitive load&lt;/strong&gt; in the terms presented in the excelsior book: 
&lt;a href=&#34;https://linghao.io/notes/a-philosophy-of-software-design&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;A Philosophy of Software Design&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;A person who is not familiar with the codebase cannot understand what is happening by analyzing the outputs of the decorator. If these outputs are being stored in the ELK stack, this will be unproductive.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;We have the &lt;code&gt;locals()&lt;/code&gt; information from the decorator which is fed by the result of the decorated method. However, we can&amp;rsquo;t get any information about the &lt;code&gt;locals()&lt;/code&gt; of the decorated method. Why is this bad?
&lt;ul&gt;
&lt;li&gt;The final internal state of the method is commonly used to understand the execution of a method.&lt;/li&gt;
&lt;li&gt;Sometimes a method depends on random variables defined in the local context. Thus, the same set of arguments can give different executions. Until now, we don&amp;rsquo;t have a way to get the &lt;code&gt;locals()&lt;/code&gt; of the decorated method. For example, in the &lt;code&gt;snooze_and_snore&lt;/code&gt; we can&amp;rsquo;t know if the person snored or not.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We will attack the first issue using the inspect module. As I&amp;rsquo;ll show you, we can do cool things with this module.&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    If you know about &lt;code&gt;sys.trace&lt;/code&gt;, &lt;code&gt;call stack&lt;/code&gt; and &lt;code&gt;inspect.signatures&lt;/code&gt; I recommend
you go directly to the section &lt;a href=&#34;#lets_solve_our_problem&#34;&gt;Let&amp;rsquo;s solve our problem&lt;/a&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;creating-an-introspective-code-with-the-inspect-module&#34;&gt;Creating an introspective code with the inspect module&lt;/h2&gt;
&lt;p&gt;The 
&lt;a href=&#34;https://docs.python.org/3/library/inspect.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;inspect&lt;/a&gt; module is a Python standard library that provides several tools to help you to introspect and consequently learn about live objects like functions, modules, classes, instances, frame objects (I&amp;rsquo;ll talk about frames later in this post), etc. Well, what can you do with this? Really, a lot of things. You can use it to  automatically create  documentation, parse the docstrings, manipulate the AST, etc.&lt;/p&gt;
&lt;h3 id=&#34;a-decorator-that-validates-arguments-using-mathematical-notation&#34;&gt;A decorator that validates arguments using mathematical notation&lt;/h3&gt;
&lt;p&gt;In the last years, we have seen the development of the &lt;code&gt;typing&lt;/code&gt; module and the &lt;code&gt;mypy&lt;/code&gt; static analysis tool for python. This module and tool can be very useful sometimes. However, it is still doesn&amp;rsquo;t provide some features that are essential for proper validation. But at least in my experience creating code for my Ph.D., I usually don&amp;rsquo;t need so much sophisticated type theory and validation to be able to write a good code for a mathematical modeling tool. Most of the mathematical validation that I need is just checking if an argument still satisfies some constraints or lives in a proper subspace. If not, I need to raise an exception or perform some kind of regularization.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s create a decorator that will validate arguments using simple mathematical notation.&lt;/p&gt;
&lt;p&gt;We will create a dictionary that will contain the annotation as a key and the value will be a human-readable
description of the annotation and a method responsible for check if everything is right.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import inspect

MATH_SPACES = {
    &amp;quot;\in R&amp;quot;: {&amp;quot;name&amp;quot; : &amp;quot;real space&amp;quot;, &amp;quot;validator&amp;quot;: lambda x: isinstance(x, (int, float))},
    &amp;quot;\in R_+&amp;quot;: {&amp;quot;name&amp;quot;: &amp;quot;space of real numbers greater than zero&amp;quot;, &amp;quot;validator&amp;quot;: lambda x: isinstance(x, (int, float)) and x &amp;gt; 0},
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We will use the &lt;code&gt;inspect.signature&lt;/code&gt; to get the annotations of each argument of the decorated method.
For example, if the decorated method is &lt;code&gt;def foo(a: &#39;\in R&#39;, b)&lt;/code&gt; the &lt;code&gt;inspect.signature(foo)&lt;/code&gt; will return an object which we can use to extract an ordered dictionary with the arguments and the annotations. Like this&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def foo(a: &amp;quot;\in R&amp;quot;, b, c:int, d= 2):
    pass
for k, v in inspect.signature(foo).parameters.items():
    print(k, v, type(v._annotation), v.default)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;a a: &#39;\\in R&#39; &amp;lt;class &#39;str&#39;&amp;gt; &amp;lt;class &#39;inspect._empty&#39;&amp;gt;
b b &amp;lt;class &#39;type&#39;&amp;gt; &amp;lt;class &#39;inspect._empty&#39;&amp;gt;
c c: int &amp;lt;class &#39;type&#39;&amp;gt; &amp;lt;class &#39;inspect._empty&#39;&amp;gt;
d d=2 &amp;lt;class &#39;type&#39;&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&amp;rsquo;s create our decorator. It should be really simple. Just check if we should verify the argument and if so, check if the value respects the annotated mathematical space.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def math_validator():
    def decorate(func):
        def decorated(*_args):
            sig = inspect.signature(func)
            # sig parameters is an ordered dict
            for i, (k, v) in enumerate(sig.parameters.items()):
                annotation = v._annotation
                if not isinstance(annotation, str):
                    continue
                if not annotation in MATH_SPACES:
                    print(f&amp;quot;{annotation} is not implemented in Math Spaces&amp;quot;)
                    continue # skip if we didn&#39;t implement this space validation

                if not MATH_SPACES[annotation][&amp;quot;validator&amp;quot;](_args[i]):
                    raise ValueError(f&amp;quot;{k} doesn&#39;t belong to the {MATH_SPACES[annotation][&#39;name&#39;]}&amp;quot;)
            result = func(*_args)
            print(f&amp;quot;{func.__name__}({_args}) -&amp;gt; {result}&amp;quot;)
            return result 
        return decorated
    return decorate

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@math_validator()
def simple_method(x: &amp;quot;\in R&amp;quot;, y: &amp;quot;\in R_+&amp;quot;, z: float = 2) -&amp;gt; float:
    &amp;quot;&amp;quot;&amp;quot;Simple method to add two numbers together and 
    divide by the last number

    Args:
        x: The first number to add.
        y: The second number to add.
        z: it is a float number that will be the power of the result.
            This will not be checked for math spaces.
    Returns:
        float: result
    
    &amp;quot;&amp;quot;&amp;quot;
    result = (x+y)/y
    return result**z

simple_method(1, 2)
simple_method(1, 0)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;simple_method((1, 2)) -&amp;gt; 1.5
---&amp;gt; 19 simple_method(1, 0)
...
&amp;lt;locals&amp;gt;.decorate.&amp;lt;locals&amp;gt;.decorated(*_args)
     11         continue
     13     if not MATH_SPACES[annotation][&amp;quot;validator&amp;quot;](_args[i]):
---&amp;gt; 14         raise ValueError(f&amp;quot;{k} doesn&#39;t belong to the {MATH_SPACES[annotation][&#39;name&#39;]}&amp;quot;)
     15 result = func(*_args)
     16 print(f&amp;quot;{func.__name__}({_args}) -&amp;gt; {result}&amp;quot;)

ValueError: y doesn&#39;t belong to the space of real numbers greater than zero
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our decorator is quite simple but does the job. You can go deeper into this and use a more sophisticated mathematical notation, printing using latex, etc. But now, let&amp;rsquo;s go back to the Python Fluent example because the &lt;code&gt;inspect.signature&lt;/code&gt; already provides us with a way to solve the first limitation!&lt;/p&gt;
&lt;h3 id=&#34;going-back-to-the-fluent-python-example&#34;&gt;Going back to the Fluent python example&lt;/h3&gt;
&lt;p&gt;Let&amp;rsquo;s remember one thing that I&amp;rsquo;ve pointed out:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A person who is not familiar with the code base will not be able to understand what is happening just by analyzing the outputs of the decorator.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It&amp;rsquo;s obvious that we can overcome this issue by using the &lt;code&gt;inspect&lt;/code&gt; module. Let&amp;rsquo;s create a more elaborated example using monkeys and a zookeeper that must record and report the information about how the life of the monkeys are going.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;NUM_MONKEYS = 20
def feed_monkeys(n_bananas, n_apples=0): 
    monkeys = {
        f&amp;quot;monkey_{i}&amp;quot;: {&amp;quot;bananas&amp;quot;: 0, &amp;quot;apples&amp;quot;: 0}
        for i in range(NUM_MONKEYS)
    }
    while n_bananas &amp;gt; 0 and n_apples &amp;gt; 0:
        if np.random.uniform() &amp;lt; 0.4:
            continue
        monkey = monkey[np.random.choice(list(monkeys.keys()))]
        if n_bananas &amp;gt; 0:
            monkey[&amp;quot;bananas&amp;quot;] += 1
            n_bananas -= 1
        if n_apples &amp;gt; 0:
            monkey[&amp;quot;apples&amp;quot;] += 1
            n_apples -= 1
        if n_apples == 0 and n_bananas == 0:
            break
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;My solution is the &lt;code&gt;@report&lt;/code&gt; decorator presented below.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def report(fmt=DEFAULT_FMT):
    def decorate(func):
        def  decorated(*_args):
            sig = inspect.signature(func)
            named_args = {}
            num_args = len(_args)
            for i, (k, v) in enumerate(sig.parameters.items()):
                if i &amp;lt; num_args:
                    named_args[k] = repr(_args[i])
                else:
                    named_args[k] = repr(v.default)
            t0 = time.time()
            _result = func(*_args)
            elapsed = time.time() - t0
            name = func.__name__
            result = repr(_result)
            args_dict = {
            **locals(),
            **named_args}
            del args_dict[&#39;_args&#39;]
            print(fmt.format(**args_dict))
            # store the information in some place
            return result
        return decorated 
    return decorate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What is important here are the following statements:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sig = inspect.signature(func)
named_args = {}
num_args = len(_args)
for i, (k, v) in enumerate(sig.parameters.items()):
    if i &amp;lt; num_args:
        named_args[k] = repr(_args[i])
    else:
        named_args[k] = repr(v.default)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We are iterating over the signature parameters and checking if it have passed the value to &lt;code&gt;func&lt;/code&gt;. If not, we extract the default value from the signature.&lt;/p&gt;
&lt;p&gt;Using the &lt;code&gt;@report&lt;/code&gt; decorator in the &lt;code&gt;feed_monkeys&lt;/code&gt; we have this output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;NUM_MONKEYS = 20
@report(&#39;The zookeeper feeds the monkeys with {n_bananas} bananas and {n_apples} apples. Time to feed: {elapsed:0.4f}s&#39;)
def feed_monkeys(n_bananas, n_apples=0): 
    monkeys = {
        f&amp;quot;monkey_{i}&amp;quot;: {&amp;quot;bananas&amp;quot;: 0, &amp;quot;apples&amp;quot;: 0}
        for i in range(NUM_MONKEYS)
    }
    while n_bananas &amp;gt; 0 and n_apples &amp;gt; 0:
        if np.random.uniform() &amp;lt; 0.4:
            continue
        monkey = monkeys[np.random.choice(list(monkeys.keys()))]

        if n_bananas &amp;gt; 0:
            monkey[&amp;quot;bananas&amp;quot;] += 1
            n_bananas -= 1
        if n_apples &amp;gt; 0:
            monkey[&amp;quot;apples&amp;quot;] += 1
            n_apples -= 1
        if n_apples == 0 and n_bananas == 0:
            break

for _ in range(3):
    feed_monkeys(np.random.randint(10, 100))
    feed_monkeys(np.random.randint(10, 100), 10)

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;The zookeeper feeds the monkeys with 69 bananas and 0 apples. Time to feed: 0.0000s
The zookeeper feeds the monkeys with 92 bananas and 10 apples. Time to feed: 0.0011s
The zookeeper feeds the monkeys with 58 bananas and 0 apples. Time to feed: 0.0000s
The zookeeper feeds the monkeys with 53 bananas and 10 apples. Time to feed: 0.0048s
The zookeeper feeds the monkeys with 42 bananas and 0 apples. Time to feed: 0.0000s
The zookeeper feeds the monkeys with 51 bananas and 10 apples. Time to feed: 0.0025s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First issue solved! But our decorator is still not useful to the zookeeper and managers. We can’t know how good any monkey is doing or if there is any monkey that eats too much. You could already know that somehow we must have a way to access the monkeys&#39; dictionary inside our &lt;code&gt;def decorated&lt;/code&gt; method. Unfortunately, this is not a trivial task in python because it lacks namespaces decorators. But we also can overcome this with a little trick using a trace tool.&lt;/p&gt;
&lt;h2 id=&#34;how-to-expose-the-locals-inside-of-a-decorator&#34;&gt;How to expose the locals() inside of a decorator?&lt;/h2&gt;
&lt;p&gt;Now we just need to access the local variables of the decorated method. Let&amp;rsquo;s think more deeply about this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;After the execution of the decorated method, all the information about the local variables is lost. Fortunately, we don&amp;rsquo;t want irrelevant information occupying our system memory.&lt;/li&gt;
&lt;li&gt;The decorator will call the decorated method and will receive the return value. Thus, &lt;strong&gt;there is no way to extract the local variables because now there are no more local variables!&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;How to solve it? Well,  think first about where the local variables are been stored before being erased.&lt;/p&gt;
&lt;h3 id=&#34;call-stack-and-frames-in-python&#34;&gt;Call stack and frames in python&lt;/h3&gt;
&lt;p&gt;If you came from a non-CS background, maybe you don&amp;rsquo;t know about an important concept called  the 
&lt;a href=&#34;https://en.wikipedia.org/wiki/Call_stack&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;call stack&lt;/strong&gt;&lt;/a&gt;. A call stack is a data structure that stores information related to living things in our program.&lt;/p&gt;
&lt;p&gt;If you call a function in python, a new block of information (&lt;strong&gt;frame&lt;/strong&gt;) is pushed to the top of the call stack. After the function returns the value, this block of information is popped off the call stack. This comprehension can give insights into how to do things in python and how to create good or strange behaviors.&lt;/p&gt;
&lt;p&gt;Well, you can think. If the elements of the call stack are always added on the top if a function (inner) is called by another function (outer) &lt;strong&gt;can I access the values of the local variables from the outer function inside of the inner? Yes, you can!&lt;/strong&gt; Obviously, this is not always a good idea but it&amp;rsquo;s good to understand this concept. Because this approach can be  useful to deal with  rigid frameworks like Django.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;%%writefile test_stack.py
import inspect

N_BANANAS = 12

def outer_call(n_bananas):
    var_inside_outer_call = 2
    n_bananas += 1
    inner_call(n_bananas)

def inner_call(n_bananas):
    var_inside_inner_call = {&amp;quot;monkey&amp;quot;: 0}
    frame_infos = inspect.stack()
    n_frames = len(frame_infos)
    frames_var_values = {
        f.function: [(k, v) for k, v in f.frame.f_locals.items()] for f in frame_infos
    }
    
    for i, (function, frame_local) in enumerate(frames_var_values.items()):
        print(f&#39;\n\t {function} stack position: {n_frames - i}&#39;)
        for var_name, value in frame_local:
            print(f&#39;\t\t Name: {var_name:25s}Type: {type(value)}&#39;)
            if var_name in (&#39;n_bananas&#39;, &#39;N_BANANAS&#39;, &#39;var_inside_outer_call&#39;):
                print(f&#39;\t\t\t Value: {value}&#39;)

print(&amp;quot;\n Before outer_call() call&amp;quot;)
outer_call(N_BANANAS)

print(&amp;quot;\n After outer_call() call&amp;quot;)

frames = [
        [(k, v) for k, v in f.frame.f_locals.items()] 
        for f in inspect.stack()
]
for frame_local in frames:
    for var_name, value in frame_local:
        print(f&#39;\t\t Name: {var_name:25s}Type: {type(value)}&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Overwriting test_stack.py
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;!python test_stack.py
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; Before outer_call() call

	 inner_call stack position: 3
		 Name: n_bananas                Type: &amp;lt;class &#39;int&#39;&amp;gt;
			 Value: 13
		 Name: var_inside_inner_call    Type: &amp;lt;class &#39;dict&#39;&amp;gt;
		 Name: frame_infos              Type: &amp;lt;class &#39;list&#39;&amp;gt;
		 Name: n_frames                 Type: &amp;lt;class &#39;int&#39;&amp;gt;

	 outer_call stack position: 2
		 Name: n_bananas                Type: &amp;lt;class &#39;int&#39;&amp;gt;
			 Value: 13
		 Name: var_inside_outer_call    Type: &amp;lt;class &#39;int&#39;&amp;gt;
			 Value: 2

	 &amp;lt;module&amp;gt; stack position: 1
		 Name: __name__                 Type: &amp;lt;class &#39;str&#39;&amp;gt;
		 Name: __doc__                  Type: &amp;lt;class &#39;NoneType&#39;&amp;gt;
		 Name: __package__              Type: &amp;lt;class &#39;NoneType&#39;&amp;gt;
		 Name: __loader__               Type: &amp;lt;class &#39;_frozen_importlib_external.SourceFileLoader&#39;&amp;gt;
		 Name: __spec__                 Type: &amp;lt;class &#39;NoneType&#39;&amp;gt;
		 Name: __annotations__          Type: &amp;lt;class &#39;dict&#39;&amp;gt;
		 Name: __builtins__             Type: &amp;lt;class &#39;module&#39;&amp;gt;
		 Name: __file__                 Type: &amp;lt;class &#39;str&#39;&amp;gt;
		 Name: __cached__               Type: &amp;lt;class &#39;NoneType&#39;&amp;gt;
		 Name: inspect                  Type: &amp;lt;class &#39;module&#39;&amp;gt;
		 Name: N_BANANAS                Type: &amp;lt;class &#39;int&#39;&amp;gt;
			 Value: 12
		 Name: outer_call               Type: &amp;lt;class &#39;function&#39;&amp;gt;
		 Name: inner_call               Type: &amp;lt;class &#39;function&#39;&amp;gt;

 After outer_call() call
		 Name: __name__                 Type: &amp;lt;class &#39;str&#39;&amp;gt;
		 Name: __doc__                  Type: &amp;lt;class &#39;NoneType&#39;&amp;gt;
		 Name: __package__              Type: &amp;lt;class &#39;NoneType&#39;&amp;gt;
		 Name: __loader__               Type: &amp;lt;class &#39;_frozen_importlib_external.SourceFileLoader&#39;&amp;gt;
		 Name: __spec__                 Type: &amp;lt;class &#39;NoneType&#39;&amp;gt;
		 Name: __annotations__          Type: &amp;lt;class &#39;dict&#39;&amp;gt;
		 Name: __builtins__             Type: &amp;lt;class &#39;module&#39;&amp;gt;
		 Name: __file__                 Type: &amp;lt;class &#39;str&#39;&amp;gt;
		 Name: __cached__               Type: &amp;lt;class &#39;NoneType&#39;&amp;gt;
		 Name: inspect                  Type: &amp;lt;class &#39;module&#39;&amp;gt;
		 Name: N_BANANAS                Type: &amp;lt;class &#39;int&#39;&amp;gt;
		 Name: outer_call               Type: &amp;lt;class &#39;function&#39;&amp;gt;
		 Name: inner_call               Type: &amp;lt;class &#39;function&#39;&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, draw your attention here&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;outer_call stack position: 2
		 Name: n_bananas                Type: &amp;lt;class &#39;int&#39;&amp;gt;
			 Value: 13
		 Name: var_inside_outer_call    Type: &amp;lt;class &#39;int&#39;&amp;gt;
			 Value: 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Even if we don&amp;rsquo;t pass a  variable as an argument to the &lt;code&gt;inner_call&lt;/code&gt; function, this variable can be accessed because still lives in the call stack!&lt;/strong&gt; As I’ve told you, after the execution of &lt;code&gt;outer_call&lt;/code&gt; the call stack doesn&amp;rsquo;t have any information about what happened inside our functions. This discussion will help us to understand the limitations of our solution. Because &lt;strong&gt;our solution is just to watch the call stack and keep the frame before being popped off!&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;using-systrace-to-track-our-frames&#34;&gt;Using sys.trace to track our frames&lt;/h3&gt;
&lt;p&gt;Some time ago I&amp;rsquo;ve talked about how to dissect a  process using &lt;code&gt;lsof&lt;/code&gt; and &lt;code&gt;strace&lt;/code&gt;: 
&lt;a href=&#34;https://medium.com/@devmessias/dissecting-process-and-failures-in-linux-with-lsof-and-strace-cases-for-mlops-d7755b2ce6ca&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dissecting processes and failures in Linux with lsof and strace&lt;/a&gt;. The &lt;code&gt;strace&lt;/code&gt; is a tracing tool that intercepts and records in someplace any system call made by a process. Python has a built-in tool to do this kind of stuff. Thus, let&amp;rsquo;s use it to track our frames.&lt;/p&gt;
&lt;h3 id=&#34;lets-solve-our-problem&#34;&gt;Let&amp;rsquo;s solve our problem&lt;/h3&gt;
&lt;p&gt;We will ask our code to monitor any call made with the decorated function. To do so, we will create a new function that will do this and release the trace after the execution of the decorated function.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sys

def call_and_extract_frame(func, *args, **kwargs):
    frame_var = None
    trace = sys.gettrace()
    def update_frame_var(stack_frame, event_name, arg_frame):
        &amp;quot;&amp;quot;&amp;quot;
        Args:
            stack_frame: (frame)
                The current stack frame.
            event_name: (str)
                The name of the event that triggered the call. 
                Can be &#39;call&#39;, &#39;line&#39;, &#39;return&#39; and &#39;exception&#39;.
            arg_frame: 
                Depends on the event. Can be a None type
        &amp;quot;&amp;quot;&amp;quot;
        nonlocal frame_var # nonlocal is a keyword which allows us to change the variable in the outer scope
        if event_name != &#39;call&#39;:
            return trace
        frame_var = stack_frame
        sys.settrace(trace)
        return trace
    sys.settrace(update_frame_var)
    try:
        func_result = func(*args, **kwargs)
    finally:
        sys.settrace(trace)
    return frame_var, func_result


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now to use this trick, we just need to call the above function in our &lt;code&gt;@report&lt;/code&gt; decorator. Like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def report(formater):
    def decorate(func):
        def decorated(*_args):
            sig = inspect.signature(func)
            named_args = {}
            num_args = len(_args)
            for i, (k, v) in enumerate(sig.parameters.items()):
                if i &amp;lt; num_args:
                    named_args[k] = repr(_args[i])
                else:
                    named_args[k] = repr(v.default)
            
            ### Our modifications
            frame_func, _result = call_and_extract_frame(func, *_args)
            name = func.__name__
            result = repr(_result)
            args_dict = {
                **named_args, 
                **locals(),
                **frame_func.f_locals,
            }
            ###

            print(formater.format(**args_dict))
            # do other stuff here
            return _result 
        return decorated
    return decorate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&amp;rsquo;s see the results:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@report(&#39; Monkey {gluttonous_monkey} ate too much bananas.  Num monkeys {num_monkeys}&#39;)
def feed_monkeys(n_bananas): 
    num_monkeys = 3
    monkeys = {
        f&amp;quot;monkey_{i}&amp;quot;: {&amp;quot;bananas&amp;quot;: 0}
        for i in range(num_monkeys)
    }
    while n_bananas &amp;gt; 0:
        if np.random.uniform() &amp;lt; 0.4:
            continue
        monkey = monkeys[np.random.choice(list(monkeys.keys()))]
        if n_bananas &amp;gt; 0:
            monkey[&amp;quot;bananas&amp;quot;] += 1
            n_bananas -= 1
    gluttonous_monkey = max(monkeys, key=lambda k: monkeys[k][&amp;quot;bananas&amp;quot;]) 

for _ in range(3):
    feed_monkeys(np.random.randint(10, 100))

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; The monkey monkey_0 eat too much bananas.  Num monkeys 3
 The monkey monkey_1 eat too much bananas.  Num monkeys 3
 The monkey monkey_2 eat too much bananas.  Num monkeys 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;conclusion-and-next-steps&#34;&gt;Conclusion and next steps&lt;/h2&gt;
&lt;h3 id=&#34;it-depends&#34;&gt;&amp;ldquo;&amp;hellip;it depends&amp;rdquo;&lt;/h3&gt;
&lt;p&gt;Nice! It worked. But should you use it?&lt;/p&gt;







  
  















&lt;figure &gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/pt-br/post/python_decorator_that_exposes_locals/depends_hue4832d1f9bd8c3212ee44b9859787ce4_80720_0x400_resize_q90_lanczos.jpg&#34; &gt;


  &lt;img src=&#34;/pt-br/post/python_decorator_that_exposes_locals/depends_hue4832d1f9bd8c3212ee44b9859787ce4_80720_0x400_resize_q90_lanczos.jpg&#34; alt=&#34;&#34;  height=&#34;400px&#34;&gt;
&lt;/a&gt;



&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;We have drawbacks in our approach:
&lt;ul&gt;
&lt;li&gt;a tracing always creates a cost. Thus, is expected that we will reduce the performance of our system. If you use this just for debugging purposes, it&amp;rsquo;s ok.&lt;/li&gt;
&lt;li&gt;can have conflicts with other tools and libs that also trying to use the trace tool&lt;/li&gt;
&lt;li&gt;it seems dirty!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;the-next-step-we-dont-need-a-trace-we-can-do-better-using-ast-manipulation&#34;&gt;The next step: we don&amp;rsquo;t need a trace! We can do better using AST manipulation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Using the inspect module to get the argument names it&amp;rsquo;s ok but I&amp;rsquo;ve told you the trace tool can be problematic.  But we can replace the trace with another approach. Although, it&amp;rsquo;s more conceptually complex don&amp;rsquo;t require  dirty tricks and I believe it&amp;rsquo;s far more beautiful. &lt;strong&gt;The next post it&amp;rsquo;s about this!&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;simplenamespace-for-dictkey-instead-of-dictkey&#34;&gt;SimpleNamespace for dict.key instead of dict[&amp;ldquo;key]&lt;/h3&gt;
&lt;p&gt;We have a minor issue and point of improvement. If you&amp;rsquo;re an cautious developer, probably you notice a flaw here&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;args_dict = {
    **named_args, 
    **locals(),
    **frame_func.f_locals,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;if any of the dicts have common keys, one of them will overwrite the other. This is not what we want. You can use a simple solution like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;args_dict = {
    &amp;quot;args&amp;quot;: **named_args, 
    **locals(),
    &amp;quot;func_locals&amp;quot;: **frame_func.f_locals,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But this is still annoying because we can do this with a format string:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@report(fmt=&amp;quot;{args[&#39;n_bananas&#39;]} ...&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Well, how to solve it? Just use a SimpleNamespace to construct an object!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from types import SimpleNamespace


def report(formater):
    def decorate(func):
        def decorated(*_args):
            sig = inspect.signature(func)
            named_args = {}
            num_args = len(_args)
            for i, (k, v) in enumerate(sig.parameters.items()):
                if i &amp;lt; num_args:
                    named_args[k] = repr(_args[i])
                else:
                    named_args[k] = repr(v.default)
            
            ### Our modifications
            frame_func, _result = call_and_extract_frame(func, *_args)
            name = func.__name__
            result = repr(_result)
            args_dict = {
                &amp;quot;args&amp;quot;: SimpleNamespace(**named_args), 
                &amp;quot;args_repr&amp;quot;: repr(SimpleNamespace(**named_args)),
                **locals(),
                **frame_func.f_locals,
            }
            ###

            print(formater.format(**args_dict))
            # do other stuff here
            return _result 
        return decorated
    return decorate


@report(
    &amp;quot;&amp;quot;.join((
        &#39;The zookeeper feeds the monkeys with {args.n_bananas},&#39;, 
        &#39;bananas. We loost {n_bananas} bananas. Args {args_repr}&#39;
    ))
)
def feed_monkeys(n_bananas): 
    num_monkeys = 3
    monkeys = {
        f&amp;quot;monkey_{i}&amp;quot;: {&amp;quot;bananas&amp;quot;: 0}
        for i in range(num_monkeys)
    }
    while n_bananas &amp;gt; 0:
        if np.random.uniform() &amp;gt; .8:
            # &amp;quot;bananas rotted . Monkeys will not eat any banana any more&amp;quot;)
            break
        if np.random.uniform() &amp;lt; 0.4:
            continue
        monkey = monkeys[np.random.choice(list(monkeys.keys()))]
        if n_bananas &amp;gt; 0:
            monkey[&amp;quot;bananas&amp;quot;] += 1
            n_bananas -= 1
    gluttonous_monkey = max(monkeys, key=lambda k: monkeys[k][&amp;quot;bananas&amp;quot;]) 

for _ in range(3):
    feed_monkeys(np.random.randint(10, 100))

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;The zookeeper feeds the monkeys with 15,bananas. We loost 15 bananas. Args namespace(n_bananas=&#39;15&#39;)
The zookeeper feeds the monkeys with 80,bananas. We loost 77 bananas. Args namespace(n_bananas=&#39;80&#39;)
The zookeeper feeds the monkeys with 95,bananas. We loost 92 bananas. Args namespace(n_bananas=&#39;95&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;want-to-know-more-about-call-stack--inspect-and-trace&#34;&gt;Want to know more about call stack , inspect and trace?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Call stack and frames: 
&lt;a href=&#34;https://www.linkedin.com/in/reza-bagheri-71882a76/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Reza Bagheri&lt;/a&gt; explained 
&lt;a href=&#34;https://reza-bagheri79.medium.com/python-stack-frames-and-tail-call-optimization-4d0ea55b0542&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt; how to add a tail-call optimization in python using python stack frames.&lt;/li&gt;
&lt;li&gt;Fluent Python book by Luciano Ramalho&lt;/li&gt;
&lt;li&gt;Python documentation: 
&lt;a href=&#34;https://docs.python.org/3/library/traceback.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tracebak&lt;/a&gt;, 
&lt;a href=&#34;https://docs.python.org/3/library/inspect.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;inspect and stack&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://stackoverflow.com/questions/4214936/how-can-i-get-the-values-of-the-locals-of-a-function-after-it-has-been-executed/4249347#4249347&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Stackoverflow discussion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Dissecando processos e erros no Linux com o lsof e strace: casos para DevOps/MlOps</title>
      <link>/pt-br/post/investigando_processos_e_bugs_strace_lsof_no_linux/</link>
      <pubDate>Fri, 04 Feb 2022 08:31:00 -0300</pubDate>
      <guid>/pt-br/post/investigando_processos_e_bugs_strace_lsof_no_linux/</guid>
      <description>&lt;details 
class=&#34;toc-inpage d-print-none d-none d-sm-block d-md-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;Lista de Conteúdos&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#conceitos&#34;&gt;Conceitos&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#everything-is-a-file-mantra-unix&#34;&gt;“Everything is a file.” mantra UNIX&lt;/a&gt;
          &lt;ul&gt;
            &lt;li&gt;&lt;a href=&#34;#lsof&#34;&gt;LSOF&lt;/a&gt;&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#system-calls-e-strace&#34;&gt;System Calls e strace&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#investigando-problemas&#34;&gt;Investigando problemas&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#identificando-problemas-de-conexão&#34;&gt;Identificando problemas de conexão&lt;/a&gt;
          &lt;ul&gt;
            &lt;li&gt;&lt;a href=&#34;#o-meu-serviço-está-on&#34;&gt;O meu serviço está on?&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&#34;#o-pip-ou-um-cliente-qualquer-está-engasgado-esperando-uma-resposta-de-alguém&#34;&gt;O pip ou um cliente qualquer está engasgado esperando uma resposta de alguém?&lt;/a&gt;&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#problemas-com-arquivos&#34;&gt;Problemas com arquivos&lt;/a&gt;
          &lt;ul&gt;
            &lt;li&gt;&lt;a href=&#34;#quais-processos-estão-usando-esse-arquivo&#34;&gt;Quais processos estão usando esse arquivo?&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&#34;#deletei-o-csv-e-agora&#34;&gt;Deletei o csv e agora?&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&#34;#erros-silenciosos-arquivo-não-existente-ou-permissão&#34;&gt;Erros silenciosos: arquivo não existente ou permissão&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&#34;#esse-processo-está-salvando-algo-que-não-deveria-onde&#34;&gt;Esse processo está salvando algo que não deveria? Onde?&lt;/a&gt;&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#extras-envolvendo-arquivos-proc-e-strace&#34;&gt;Extras envolvendo arquivos (&lt;code&gt;/proc/&lt;/code&gt;) e &lt;code&gt;strace&lt;/code&gt;&lt;/a&gt;
          &lt;ul&gt;
            &lt;li&gt;&lt;a href=&#34;#gerando-um-sumário-de-sys-call&#34;&gt;Gerando um sumário de SYS CALL&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&#34;#o-processo-foi-iniciado-com-as-variáveis-de-ambiente-corretas&#34;&gt;O processo foi iniciado com as variáveis de ambiente corretas?&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&#34;#esqueci-de--redirecionar-os-outputs-do-processo-para-um-arquivo--o-que-fazer&#34;&gt;Esqueci de  redirecionar os outputs do processo para um arquivo.  O que fazer?&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&#34;#qual-comando-gerou-o-processo-e-onde-é-o-seu-working-dir&#34;&gt;Qual comando gerou o processo e onde é o seu working dir?&lt;/a&gt;&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#agradecimentos--sugestões&#34;&gt;Agradecimentos &amp;amp; Sugestões&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;p&gt;Linux não é um SO opaco. Ele não ser opaco significa que é fácil ver o que acontece por trás dos processos.  O que permite identificar um problema ou pelo menos saber se você realmente tem um problema.&lt;/p&gt;
&lt;p&gt;Iniciei meu aprendizado em MlOps (&lt;em&gt;Machine Learning Operations&lt;/em&gt;). Embora tenha pouca experiência foi fácil aceitar que  MlOps envolve um workflow extremamente intricado com muitos possíveis pontos de falhas. Tais pontos podem não estar relacionados com os operadores. Portanto, saber identificar se existe uma falha e o que está causando ela é de suma importância. Isso vai desde compreender o comportamento de um processo criado pelos próprios operadores ou o que o &lt;code&gt;pip/conda&lt;/code&gt; e demais dependências externas estão aprontando debaixo dos panos.&lt;/p&gt;
&lt;p&gt;O primeiro passo para entender um problema com um processo é analisar o output (a saída na sessão do seu terminal). Contudo, algumas vezes isso não te fornece a informação suficiente. Neste texto vou discorrer do básico sobre como debugar processos usando o &lt;code&gt;strace&lt;/code&gt; e &lt;code&gt;lsof&lt;/code&gt;. Iremos criar alguns exemplos patológicos usando python para simular problemas que podemos encontrar e como eles são dissecados pelo &lt;code&gt;strace&lt;/code&gt; e o &lt;code&gt;lsof&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id=&#34;conceitos&#34;&gt;Conceitos&lt;/h1&gt;
&lt;h2 id=&#34;everything-is-a-file-mantra-unix&#34;&gt;“Everything is a file.” mantra UNIX&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;everthing_is_a_file.png&#34; alt=&#34;everthing_is_a_file&#34;&gt;&lt;/p&gt;
&lt;p&gt;Quando você pensa em arquivo você talvez relacione com um &lt;em&gt;CSV&lt;/em&gt;, uma planilha ou imagem. Mas na abordagem UNIX de fazer SO o conceito de arquivo aparece em todos os lugares.  Por exemplo, até conexões de rede são associadas a um arquivo. Em  casos que um elemento  em si não é um arquivo tal elemento tem  a ele associado  um descritor de arquivo (&lt;em&gt;file descriptor&lt;/em&gt;). Como isso se relaciona com debugar processos? **Se tudo é um arquivo analisar um processo pode ser feito com o mesmo conjunto de ferramentas  e conceitos que usamos para listar,  compreender e comunicar com arquivo  inclusive com a mesma API. ** Aqui abordaremos uma ferramenta para listagem de arquivos, o   &lt;code&gt;lsof&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;lsof&#34;&gt;LSOF&lt;/h3&gt;
&lt;p&gt;A ferramenta &lt;strong&gt;lsof&lt;/strong&gt;   é um comando que pode ser usado para listar os &lt;em&gt;file descriptors&lt;/em&gt; abertos e os processos que  foram responsáveis por tal ação. Desta maneira você pode listar os file descriptors de um usuário  que estão  associados a uma  porta via conexão ou  processo.  O nome desse comando é um acrônimo para &lt;strong&gt;l&lt;/strong&gt;ist &lt;strong&gt;o&lt;/strong&gt;pen &lt;strong&gt;f&lt;/strong&gt;iles.&lt;/p&gt;
&lt;p&gt;O exemplo mais simples de uso jogando os resultados para um arquivo é esse&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;meuusuario:/$ lsof &amp;gt; lsof_tudo.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O comando acima irá criar uma tabela (imensa) dentro de &lt;code&gt;lsof_tudo.txt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Essa tabela será mais ou menos assim&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;COMMAND     PID   TID TASKCMD               USER   FD      TYPE             DEVICE  SIZE/OFF       NODE NAME
systemd       1                             root  cwd   unknown                                         /proc/1/cwd (readlink: Permission denied)
systemd       1                             root  rtd   unknown                                         /proc/1/root (readlink: Permission denied)
systemd       1                             root  txt   unknown                                         /proc/1/exe (readlink: Permission denied)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Se você olhar com cuidado verá que aparecem linhas de diferentes usuários. As primeiras são do &lt;code&gt;root&lt;/code&gt; e uma das colunas mostra que você não tem permissão para ler os &lt;em&gt;file descriptors&lt;/em&gt; desse usuário, ainda bem! Para pedir apenas a listagem  do seu usuário faça&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;meuusuario:/$ lsof -u meuusuario &amp;gt; lsof_meu.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O arquivo ainda é enorme, mas abra ele com seu editor de texto.  Tente procurar nomes de arquivos e processos que você esta usando agora.&lt;/p&gt;
&lt;p&gt;Temos muitas colunas no output, você pode ver o significado detalhado de cada uma digitando &lt;code&gt;man lsof&lt;/code&gt; . Mas eu acho mais  interessante você focar nas seguintes colunas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;COMAND
&lt;ul&gt;
&lt;li&gt;O nome do comando associado ao processo que abriu o arquivo&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PID
&lt;ul&gt;
&lt;li&gt;Um número que identifica unicamente o processo. Você pode usar esse número para matar o processo usando &lt;code&gt;pkill&lt;/code&gt;, usar ele no &lt;code&gt;strace&lt;/code&gt; etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TID
&lt;ul&gt;
&lt;li&gt;Se o arquivo foi aberto por uma thread de um processo. Quando não tem nada nessa coluna  significa que a ação foi feita por um processo.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;USER
&lt;ul&gt;
&lt;li&gt;O usuário responsável pelo processo que efetuou a ação.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TYPE
&lt;ul&gt;
&lt;li&gt;Essa coluna é bem útil. Tal coluna te diz o tipo de nó associado ao arquivo. Por exemplo, se o arquivo for associado com protocolos  você vera aqui coisas do tipo: &lt;strong&gt;IPV4, IPV6&lt;/strong&gt;. Se for um arquivo normal  haverá na coluna o identificador **REG. **Existem algumas dezenas de possibilidades de valores para essa coluna, eu nunca lembro o que elas significam, mas é fácil consultar online ou no &lt;code&gt;man&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NODE
&lt;ul&gt;
&lt;li&gt;O identificador  do nó do arquivo. No caso desse arquivo envolver protocolos de internet haverá coisas como &lt;strong&gt;TCP, UDP&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NAME
&lt;ul&gt;
&lt;li&gt;Também bastante útil. Ele muda bastante dependendo do que o arquivo se refere. Pode ser o endereço do servidor (&lt;a href=&#34;http://www.google.com&#34;&gt;www.google.com&lt;/a&gt;, localhost:5000) assim como o endereço do arquivo.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O &lt;code&gt;lsof&lt;/code&gt; tem muitos argumentos possíveis, veremos alguns utilizando alguns casos que eu acho interessante e que acontecem.&lt;/p&gt;
&lt;h2 id=&#34;system-calls-e-strace&#34;&gt;System Calls e strace&lt;/h2&gt;
&lt;p&gt;O system call é o mecanismo de comunicação entre processos e o kernel do seu SO.
Tal mecanismo permite que um processo requisite recursos do kernel disponibilizados pelo seu hardware. Para ler um arquivo armazenado em seu hardwre é necessário que ocorra antes um system call. Portanto, tendo uma maneira de interceptar essas chamadas entre um processo e o kernel temos como compreender o que tal processo está fazendo. Um comando que permite essa interceptação é o &lt;code&gt;strace&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ man strace
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Se o strace não estiver disponível instale&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ apt install strace
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O &lt;code&gt;strace&lt;/code&gt; pode ser executado de duas formas. A primeira é
usando o comando a ser interceptado como argumento do strace&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ strace ARGS COMANDO_A_SER_INTERCEPTADO
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;a segunda,  bastante útil,  é interceptando um processo já iniciado usando
o PID de tal processo,&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ strace ARGS -p PID_DO_PROCESSO
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para descobrir o PID de um processo use o &lt;code&gt;htop&lt;/code&gt; ou o seguinte comando &lt;code&gt;ps aux | grep -i &#39;[n]ome_do_processo&#39;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Veja um exemplo simples do strace e seu output&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ strace -t ls
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O resultado será algo do tipo&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;18:02:23 execve(&amp;quot;/usr/bin/ls&amp;quot;, [&amp;quot;ls&amp;quot;], 0x7fffa727a418 /* 54 vars */) = 0
18:02:23 brk(NULL)                      = 0x55ebef60c000
18:02:23 access(&amp;quot;/etc/ld.so.preload&amp;quot;, R_OK) = -1 ENOENT (No such file or directory)
18:02:23 openat(AT_FDCWD, &amp;quot;/etc/ld.so.cache&amp;quot;, O_RDONLY|O_CLOEXEC) = 3
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Cada linha representa uma system call e o seu respectivo resultado. O argumento &lt;code&gt;-t&lt;/code&gt; diz para imprimir na primeira coluna o instante de tempo que o system call foi chamado.&lt;/p&gt;
&lt;p&gt;De forma resumida o formato das linhas segue o padrão:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Nome  da SYS CALL(Argumentos usados na SYS CALL) = O resultado&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;O output é  difícil se não humanamente impossível de compreender tudo sem um guia externo. Um guia possível é o comando &lt;code&gt;man&lt;/code&gt;. O comando abaixo mostra a documentação do sys call &lt;code&gt;openat&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ man 2 openat
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O &lt;code&gt;openat&lt;/code&gt; é o sys call que requisita a abertura de um arquivo, o resultado na última linha (&lt;code&gt; O_RDONLY|O_CLOEXEC) = 3&lt;/code&gt;)  significa que a chamada do sistema foi bem sucedida. Caso fosse &lt;strong&gt;-1&lt;/strong&gt; alguma coisa teria dado errado quando o processo requisitou o recurso.&lt;/p&gt;
&lt;h1 id=&#34;investigando-problemas&#34;&gt;Investigando problemas&lt;/h1&gt;
&lt;p&gt;Veremos aqui problemas e falhas relacionados a arquivos regulares e conexões de rede. Contudo podemos usar as mesmas tecnicas para outros tipos de problemas.&lt;/p&gt;
&lt;h2 id=&#34;identificando-problemas-de-conexão&#34;&gt;Identificando problemas de conexão&lt;/h2&gt;
&lt;p&gt;O conda está travado?  O pip tá baixando os pacotes do servidor ou existe algum servidor engasgando? Para onde  minhas requisições estão indo? Antes de  tentar iniciar um modo verboso e ter que matar seu processo você pode usar o lsof para  responder essas perguntas.  Para começar nosso tutorial e realizar as simulações instale o flask e requests&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ python -m pip install requests flask
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Crie o arquivo &lt;code&gt;server_mlops.py&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# server_mlops.py
import time
import flask

app = flask.Flask(__name__)

@app.route(&#39;/&#39;)
def hello_world():
    sleep_time = flask.request.args.get(&#39;sleep&#39;, default=10, type=int)
    print(&#39;sleep_time:&#39;, sleep_time)
    time.sleep(sleep_time)
    return &#39;Hello World!&#39;

if __name__ == &#39;__main__&#39;:
    app.run()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Inicie duas sessões no terminal. Na primeira inicie o servidor&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ python server_mlops.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Na segunda execute&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ps aux | grep -i &#39;[s]erver_mlops.py&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;você vera um output do tipo&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;devmess+ 19321 18.0  0.3  29716 24792 pts/5    S+   14:27   0:00 python server_mlops.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O número na frente do seu username (19321) é o &lt;code&gt;PID&lt;/code&gt; do processo.&lt;/p&gt;
&lt;h3 id=&#34;o-meu-serviço-está-on&#34;&gt;O meu serviço está on?&lt;/h3&gt;
&lt;p&gt;O  argumento &lt;code&gt;-a&lt;/code&gt; pede que o &lt;code&gt;lsof&lt;/code&gt; use todos os argumentos de filtragem com o operador &lt;code&gt;AND&lt;/code&gt; isto é, todas as condições devem ser válidas. O argumento &lt;code&gt;-i&lt;/code&gt; pede para que ele filtre apenas arquivos associados a conexões e o argumento &lt;code&gt;-p 19321&lt;/code&gt; pede que use apena o processo com o &lt;code&gt;PID 19321&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ lsof -a -i -p 19321
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Você vera um output mais ou menos assim&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;COMMAND&lt;/th&gt;
&lt;th&gt;PID&lt;/th&gt;
&lt;th&gt;USER&lt;/th&gt;
&lt;th&gt;FD&lt;/th&gt;
&lt;th&gt;TYPE&lt;/th&gt;
&lt;th&gt;DEVICE&lt;/th&gt;
&lt;th&gt;SIZE/OFF&lt;/th&gt;
&lt;th&gt;NODE&lt;/th&gt;
&lt;th&gt;NAME&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;python&lt;/td&gt;
&lt;td&gt;19321&lt;/td&gt;
&lt;td&gt;devmessias&lt;/td&gt;
&lt;td&gt;4u&lt;/td&gt;
&lt;td&gt;IPv4&lt;/td&gt;
&lt;td&gt;16108218&lt;/td&gt;
&lt;td&gt;0t0&lt;/td&gt;
&lt;td&gt;TCP&lt;/td&gt;
&lt;td&gt;localhost:5000 (LISTEN)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Está tudo ok com o seu serviço. Tente remover um dos argumentos (remova o &lt;code&gt;-a&lt;/code&gt; por exemplo) ou usar eles isolados, veja como o output muda.&lt;/p&gt;
&lt;h3 id=&#34;o-pip-ou-um-cliente-qualquer-está-engasgado-esperando-uma-resposta-de-alguém&#34;&gt;O pip ou um cliente qualquer está engasgado esperando uma resposta de alguém?&lt;/h3&gt;
&lt;p&gt;Esse tipo de problema pode acontecer  quando estamos gerenciando uma dependência, requisitando algum tipo de dado de um servidor e em inúmeros outros casos em que não temos acesso a máquina que executa o serviço. Portanto,  precisamos analisar do nosso lado se o processo está travado por alguma falha nossa.&lt;/p&gt;
&lt;p&gt;Crie o arquivo &lt;code&gt;client_mlops.py&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
#client_mlops.py

import requests
import argparse

parser = argparse.ArgumentParser()
parser.add_argument(
    &#39;--sleep&#39;, type=int, help=&#39;time to sleep&#39;, default=0)
args = parser.parse_args()

print(&#39;Ask for localhost:5000 to sleep for {} seconds&#39;.format(args.sleep))
r = requests.get(&#39;http://localhost:5000&#39;, params={&#39;sleep&#39;: int(args.sleep)})
print(r.text)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;No código acima temos o argumento &lt;code&gt;sleep&lt;/code&gt; que pedira para o &lt;code&gt;server_mlops.py&lt;/code&gt; esperar alguns segundos antes de enviar a resposta.&lt;/p&gt;
&lt;p&gt;Simularemos um problema de um servidor preguiçoso. Pedindo que ele durma por 20 segundos.  Se você matou o processo do servidor inicie ele novamente.&lt;/p&gt;
&lt;p&gt;Execute o &lt;code&gt;client_mlops.py&lt;/code&gt; com o &lt;code&gt;strace&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ strace -e poll,select,connect,recvfrom,sendto python client_mlops.py --sleep=20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;aqui estamos pedindo para que o &lt;code&gt;strace&lt;/code&gt; nos mostre apenas chamadas do tipo &lt;code&gt;poll,select,connect,recvfrom&lt;/code&gt; e &lt;code&gt;sendto&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;O output será algo do tipo&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;connect(4, {sa_family=AF_INET, sin_port=htons(5000), sin_addr=inet_addr(&amp;quot;127.0.0.1&amp;quot;)}, 16) = 0
connect(4, {sa_family=AF_INET6, sin6_port=htons(5000), inet_pton(AF_INET6, &amp;quot;::1&amp;quot;, &amp;amp;sin6_addr), sin6_flowinfo=htonl(0), sin6_scope_id=0}, 28) = 0
connect(4, {sa_family=AF_INET6, sin6_port=htons(5000), inet_pton(AF_INET6, &amp;quot;::1&amp;quot;, &amp;amp;sin6_addr), sin6_flowinfo=htonl(0), sin6_scope_id=0}, 28) = -1 ECONNREFUSED (Connection refused)
connect(4, {sa_family=AF_INET, sin_port=htons(5000), sin_addr=inet_addr(&amp;quot;127.0.0.1&amp;quot;)}, 16) = 0
sendto(4, &amp;quot;GET /?sleep=10 HTTP/1.1\r\nHost: l&amp;quot;..., 154, 0, NULL, 0) = 154
recvfrom(4, 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note que temos uma &lt;strong&gt;SYS_CALL&lt;/strong&gt;  engasgada, &lt;code&gt;recvfrom&lt;/code&gt; (se você quiser obter mais informações sobre uma SYS_CALL digite &lt;code&gt;man 2 recvfrom&lt;/code&gt;) . Quem tá engasagando é  o servidor e não o cliente.&lt;/p&gt;
&lt;p&gt;Você pode também usar o &lt;code&gt;lsof&lt;/code&gt; para checar se você está com esse tipo de problema. Para isso, execute o cliente em uma sessão separada&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ python client_mlops.py --sleep=100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pegue o PID com &lt;code&gt;ps aux | grep -i &#39;[c]lient_mlops.py&#39;&lt;/code&gt; e execute o &lt;code&gt;lsof&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;lsof -a -i -p 19321
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O resultado será algo do tipo&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;COMMAND&lt;/th&gt;
&lt;th&gt;PID&lt;/th&gt;
&lt;th&gt;USER&lt;/th&gt;
&lt;th&gt;FD&lt;/th&gt;
&lt;th&gt;TYPE&lt;/th&gt;
&lt;th&gt;DEVICE&lt;/th&gt;
&lt;th&gt;SIZE/OFF&lt;/th&gt;
&lt;th&gt;NODE&lt;/th&gt;
&lt;th&gt;NAME&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;python&lt;/td&gt;
&lt;td&gt;31551&lt;/td&gt;
&lt;td&gt;devmessias&lt;/td&gt;
&lt;td&gt;4u&lt;/td&gt;
&lt;td&gt;IPv4&lt;/td&gt;
&lt;td&gt;16622065&lt;/td&gt;
&lt;td&gt;0t0&lt;/td&gt;
&lt;td&gt;TCP&lt;/td&gt;
&lt;td&gt;localhost:57314-&amp;gt;localhost:5000 (ESTABLISHED)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Note  que uma conexão foi estabelecida (coluna NAME). Se o serviço estivesse enviado a resposta não teríamos obtido nada na saída do &lt;code&gt;lsof&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;problemas-com-arquivos&#34;&gt;Problemas com arquivos&lt;/h2&gt;
&lt;p&gt;Vamos simular alguns problemas com arquivos regulares: csv, txt, bin, jpg etc. Copie um csv para pasta /tmp/, ou execute o comando abaixo  para criar um txt  dummy contendo o manual do comando strace.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ man strace &amp;gt; /tmp/arquivo.csv 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;quais-processos-estão-usando-esse-arquivo&#34;&gt;Quais processos estão usando esse arquivo?&lt;/h3&gt;
&lt;p&gt;O objetivo aqui é saber quais processos estão acessando um arquivo. Isto é útil quando queremos identificar processos que já deveriam ter &amp;ldquo;fechado&amp;rdquo; o arquivo ou inentificar acessos indenvidos. Também pode ser útil para descobrir qual processo está criando um arquivo gigantesco no seu sistema para que você possa dar um kill.&lt;/p&gt;
&lt;p&gt;Crie o script a seguir em uma pasta.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# file_open.py
import time

f = open(&#39;/tmp/arquivo.csv&#39;, &#39;r&#39;)
input(&#39;Press Enter to continue...&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Depois abra duas sessões no terminal e rode o comando &lt;code&gt;python file_open.py&lt;/code&gt;.  Agora basta listar os processos que estão com arquivo.csv abertos&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ lsof /tmp/arquivo.csv
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O output será algo do tipo&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;COMMAND   PID       USER   FD   TYPE DEVICE SIZE/OFF    NODE NAME
python  15411 devmessias    3r   REG    8,2        0 2911031 /tmp/arquivo.csv
python  20777 devmessias    3r   REG    8,2        0 2911031 /tmp/arquivo.csv
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Temos dois processos distintos (dois PID) utilizando nosso arquivo.&lt;/p&gt;
&lt;h3 id=&#34;deletei-o-csv-e-agora&#34;&gt;Deletei o csv e agora?&lt;/h3&gt;
&lt;p&gt;Suponha uma situação em que acidentalmente  um arquivo foi apagado. Contudo,  existe um processo que ainda está fazendo uso de tal recurso.&lt;/p&gt;
&lt;p&gt;Crie um arquivo qualquer, aqui vou chamar de &lt;code&gt;acidente.txt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Abra uma sessão no terminal e execute o comando a seguir. &lt;strong&gt;Não feche a sessão!&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ python -c &#39;f=open(&amp;quot;acidente.txt&amp;quot;, &amp;quot;r&amp;quot;);input(&amp;quot;...&amp;quot;)&#39;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Simularemos o acidente que outro processo remove o arquivo. Execute os comandos abaixo&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ rm acidente.txt
$ ls acidente.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nosso arquivo foi embora :(&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls: cannot access &#39;acidente.txt&#39;: No such file or directory
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mas não se preocupe! Uma coisa legal do linux: todos os processos do sistema tem a eles associados um diretório dentro da pasta &lt;code&gt;/proc&lt;/code&gt; (everthing is a file).  E o que tem nesses diretórios ? Muitas coisas, incluindo o &lt;code&gt;file descriptor&lt;/code&gt; do &lt;code&gt;acidente.txt&lt;/code&gt;. Utilizado pelo nosso processo python.  Para encontrar esse &lt;code&gt;file descriptor&lt;/code&gt; usaremos o &lt;code&gt;lsof&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ lsof -u nomedeusuario | grep &#39;acidente.txt&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;No meu caso obtive o seguinte output&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python    22465 devmessias    3r      REG                8,2     37599   14288174 caminho/acidente.txt (deleted)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Então o PID é &lt;code&gt;22465&lt;/code&gt; e o número que descreve o arquivo (file descriptor) é &lt;code&gt;3&lt;/code&gt; (o que vem antes do &lt;code&gt;r&lt;/code&gt; no output acima). Para obter uma cópia do acidente.txt deletado basta chamar  um simples &lt;code&gt;cp&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cp /proc/22465/fd/3 recuperado.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Abra o arquivo &lt;code&gt;recuperado.txt&lt;/code&gt; e veja que tudo está no seu devido lugar.  Não é mágica, procure por  &lt;strong&gt;process pseudo-filesystem&lt;/strong&gt; na web ou digite &lt;code&gt;man proc&lt;/code&gt; .&lt;/p&gt;
&lt;h3 id=&#34;erros-silenciosos-arquivo-não-existente-ou-permissão&#34;&gt;Erros silenciosos: arquivo não existente ou permissão&lt;/h3&gt;
&lt;p&gt;Em alguns casos você pode ter um processo criado por uma dependência externa que tenta acessar um arquivo com permissão errada ou mesmo não existente.  Criaremos essas duas situações com o script &lt;code&gt;file_404.py&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# file_404.py
import time

try:
    f = open(&#39;/tmp/arquivo_404.csv&#39;, &#39;r&#39;)
except FileNotFoundError:
    pass

try:
    # um arquivo que vc nao tem permissao, crie como sudo e mude com chmod 700
    f = open(&#39;/tmp/arquivo_permission.csv&#39;, &#39;r&#39;)
except PermissionError:
    pass

input(&#39;Press Enter to continue...&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Execute ele com &lt;code&gt;python file_404.py&lt;/code&gt; veja que nenhum problema é informado.&lt;/p&gt;
&lt;p&gt;Para  traquear as chamadas do sistema do tipo arquivo feitas  por  &lt;code&gt;python file_404.py &lt;/code&gt; basta digitar o comando abaixo no terminal&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ strace -f -e trace=file python file_404.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;o argumento &lt;code&gt;-f&lt;/code&gt; diz para o strace monitorar também qualquer processo filho criado. Em python, isso seria por exemplo os processos criados por &lt;code&gt;os.fork&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A saída do exemplo será algo do tipo&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lstat(&amp;quot;SEU DIRETORIO/file_404.py&amp;quot;, {st_mode=S_IFREG|0644, st_size=242, ...}) = 0
openat(AT_FDCWD, &amp;quot;file_404.py&amp;quot;, O_RDONLY) = 3
openat(AT_FDCWD, &amp;quot;/tmp/arquivo_404.csv&amp;quot;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &amp;quot;/tmp/arquivo_permission.csv&amp;quot;, O_RDONLY|O_CLOEXEC) = -1 EACCES (Permission denied)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note que temos no output informações que não queremos investigar,  mas  nas últimas linhas os erros de permissão e ausência de arquivo apareceram.&lt;/p&gt;
&lt;p&gt;Uma maneira de filtrar o resultado e tornar sua vida mais fácil é usar o &lt;code&gt;awk&lt;/code&gt; redirecionado a saída do strace com  o pipe &lt;code&gt;|&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ strace -f -e trace=file python file_404.py 2&amp;gt;&amp;amp;1 | awk &#39;/^open/ &amp;amp;&amp;amp; /= -1/ {print}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O comando acima diz para mostrar apenas as linhas que começam com a string &lt;code&gt;open&lt;/code&gt; e em alguma parte da linha tenha o padrão &lt;code&gt;= -1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;O comando com &lt;code&gt;awk&lt;/code&gt; concatenado produzirá um output mais limpo, veja só&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;openat(AT_FDCWD, &amp;quot;/home/devmessias/anaconda3/pyvenv.cfg&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &amp;quot;/tmp/arquivo_404.csv&amp;quot;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &amp;quot;/tmp/arquivo_permission.csv&amp;quot;, O_RDONLY|O_CLOEXEC) = -1 EACCES (Permission denied)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;esse-processo-está-salvando-algo-que-não-deveria-onde&#34;&gt;Esse processo está salvando algo que não deveria? Onde?&lt;/h3&gt;
&lt;p&gt;Talvez você queira monitorar o que uma dependência externa anda fazendo no seu sistema de arquivos. Outro problema que pode ocorrer é caso você delete um arquivo usado por uma dependência, contudo tal dependência fez um cache em algum lugar antes de você efetuar a remoção. O que te impede de &lt;em&gt;ressetar&lt;/em&gt; a dependência.&lt;/p&gt;
&lt;p&gt;Usando o mesmo comando anterior é possível buscar onde esses caches e arquivos estão&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ strace -f -e trace=file comando 2&amp;gt;&amp;amp;1 | awk &#39;/^open/{print}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;se você quiser pegar apenas as chamadas que não retornaram em falha digite&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ strace -f -e trace=file comando 2&amp;gt;&amp;amp;1 | awk &#39;/^open/ &amp;amp;&amp;amp; !/= -1/ {print}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;extras-envolvendo-arquivos-proc-e-strace&#34;&gt;Extras envolvendo arquivos (&lt;code&gt;/proc/&lt;/code&gt;) e &lt;code&gt;strace&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Usando problemas comuns envolvendo arquivos e conexões conversamos um pouco sobre o &lt;code&gt;strace&lt;/code&gt; e &lt;code&gt;lsof&lt;/code&gt;. Conceitos como SYS CALL e a pasta &lt;code&gt;/proc/&lt;/code&gt; também foram mencioandos.  Darei alguns exemplos de algumas outras questões que podemos responder usando esses outros elementos.&lt;/p&gt;
&lt;h3 id=&#34;gerando-um-sumário-de-sys-call&#34;&gt;Gerando um sumário de SYS CALL&lt;/h3&gt;
&lt;p&gt;Você pode sumarizar todas as sys call feitas por um processo usando o argumento &lt;code&gt;-c&lt;/code&gt;. Isso pode te ajudar a economizar tempo numa pre-análise.&lt;/p&gt;
&lt;p&gt;O comando abaixo retorna as sys calls efetuadas pelo comando &lt;code&gt;make sync-env&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ strace -c -e trace=!\wait4 make sync-env
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;outro argumento que foi alterado aqui é o operador &lt;code&gt;!\&lt;/code&gt; que diz para o strace ignorar as sys call do tipo &lt;code&gt;wait4&lt;/code&gt;. O ouput será algo do tipo:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 14,54    0,000209           6        33        13 openat
 13,01    0,000187          17        11           vfork
 12,32    0,000177           7        25           mmap
  8,49    0,000122           3        31           close
  8,42    0,000121           5        21           rt_sigprocmask
  8,14    0,000117           6        17           read
  6,89    0,000099           5        19        11 stat
  5,85    0,000084           3        23           fstat
  2,85    0,000041           8         5           mprotect
  2,64    0,000038           9         4           write
  2,51    0,000036           2        16           fcntl
  2,02    0,000029           3         9           rt_sigaction
  1,95    0,000028          14         2           readlink
  1,95    0,000028          14         2           getdents64
  1,25    0,000018           4         4           brk
  1,25    0,000018          18         1         1 access
  1,25    0,000018           3         5           pipe
  1,11    0,000016           4         4           ioctl
  0,84    0,000012           6         2           getcwd
  0,70    0,000010          10         1           munmap
  0,49    0,000007           7         1           lstat
  0,49    0,000007           7         1           execve
  0,49    0,000007           3         2           prlimit64
  0,35    0,000005           5         1           chdir
  0,21    0,000003           3         1           arch_prctl
------ ----------- ----------- --------- --------- ----------------
100.00    0,001437                   241        25 total
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A coluna time diz que &lt;code&gt;make sync-env&lt;/code&gt; gastou $14$% do tempo (com exceção do &lt;code&gt;wait4&lt;/code&gt;) em sys calls do tipo &lt;code&gt;openat&lt;/code&gt; e $13$ das $33$ chamadas não foram bem sucedidas.&lt;/p&gt;
&lt;h3 id=&#34;o-processo-foi-iniciado-com-as-variáveis-de-ambiente-corretas&#34;&gt;O processo foi iniciado com as variáveis de ambiente corretas?&lt;/h3&gt;
&lt;p&gt;Os próximos exemplos envolvem situações em que um processo foi iniciado, mas você quer verificar algumas informações sobre o mesmo sem que seja necessário matar e reiniciar processo.  Imagine fazer isso em produção? Ou com um modelo de ML que já gastou muitos &lt;strong&gt;R$&lt;/strong&gt; para chegar no estágio atual.&lt;/p&gt;
&lt;p&gt;Vamos continuar com o nosso &lt;code&gt;server_mlops.py&lt;/code&gt;. Suponha que o processo foi iniciado usando  uma variável de ambiente extra, &lt;code&gt;ANSWER&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ANSWER=42 python server_mlops.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Após o inicio do processo como saber com quais variáveis de ambiente ele está usando? Essa variáveis setam por exemplo bibliotecas de otimização(BLAS, LAPACK), env&amp;rsquo;s python etc.&lt;/p&gt;
&lt;p&gt;Como dito em um exemplo anterior, a pasta &lt;code&gt;/proc&lt;/code&gt;  contêm arquivos representado o estado dos processos em execução.  Supondo que o PID do processo é &lt;code&gt;4031&lt;/code&gt; você pode acessar as variáveis de ambiente do mesmo através de &lt;code&gt;cat /proc/4031/environ&lt;/code&gt;. Mas o output é meio feio, vamos usar &lt;code&gt;tr&lt;/code&gt; para trocar os caracteres nulos &lt;code&gt;\0&lt;/code&gt; por quebras de linhas, &lt;code&gt;\n&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ tr &#39;\0&#39; &#39;\n&#39; &amp;lt; /proc/4031/environ
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Você terá  um output do tipo&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ANSWER=42
SHELL=/bin/bash
LANGUAGE=en_US
JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64/bin/java
...more stuff
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Se você quiser filtrar apenas linhas que comecem com a string CONDA faça&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ tr &#39;\0&#39; &#39;\n&#39; &amp;lt; /proc/4031/environ 2&amp;gt;&amp;amp;1 | awk &#39;/^CONDA/ {print}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;o output no meu caso foi algo do tipo&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CONDA_EXE=/home/devmessias/anaconda3/bin/conda
CONDA_PREFIX=/home/devmessias/anaconda3
CONDA_PROMPT_MODIFIER=(base) 
CONDA_SHLVL=1
CONDA_PYTHON_EXE=/home/devmessias/anaconda3/bin/python
CONDA_DEFAULT_ENV=base
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;esqueci-de--redirecionar-os-outputs-do-processo-para-um-arquivo--o-que-fazer&#34;&gt;Esqueci de  redirecionar os outputs do processo para um arquivo.  O que fazer?&lt;/h3&gt;
&lt;p&gt;Suponha que você iniciou um processo e  não redirecionou  os outputs para um arquivo de texto por esquecimento ou por subestimar problemas. Se reiniciar o processo não é uma opção  você está com problemas.  Felizmente é possível usar o &lt;code&gt;strace&lt;/code&gt;  para interceptar os outputs e salva-los em um arquivo externo.&lt;/p&gt;
&lt;p&gt;A SYS CALL responsável por requisitar a &lt;em&gt;escrita&lt;/em&gt; no &lt;strong&gt;stdin, stdout e stderr&lt;/strong&gt; é a &lt;code&gt;write&lt;/code&gt; . Veja o manual dessa chamada&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ man 2 write
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;NAME
       write - write to a file descriptor
SYNOPSIS
       #include &amp;lt;unistd.h&amp;gt;
       ssize_t write(int fd, const void *buf, size_t count);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O primeiro argumento é um inteiro que representa o file descriptor. Sendo que &lt;strong&gt;fd=1&lt;/strong&gt; implica que a chamada escreverá no &lt;strong&gt;stdout&lt;/strong&gt; e &lt;strong&gt;fd=2&lt;/strong&gt; no &lt;strong&gt;stderr&lt;/strong&gt; . Portanto, não existe nenhum segredo aqui. Se você quiser capturar os outputs basta filtrar as SYS CALL do tipo write e file descriptor &lt;strong&gt;1&lt;/strong&gt; ou &lt;strong&gt;2&lt;/strong&gt; e envia-las para o arquivo desejado. Temos que tomar cuidado só com as algumas coisas aqui. No manual do strace (&lt;code&gt;man strace&lt;/code&gt;) você vera que por padrão ele &lt;em&gt;printa&lt;/em&gt; apenas $32$ caracteres em uma string. Portanto, precisamos aumentar o limite com o argumento &lt;code&gt;-s&lt;/code&gt;. Também é interessante traquear os forks. No caso do &lt;code&gt;server_mlops.py&lt;/code&gt; por exemplo, qualquer print dentro de um método não será executado na main, então o &lt;code&gt;-f&lt;/code&gt; é obrigatório.&lt;/p&gt;
&lt;p&gt;O comando para redirecionar as saidas do stdout e stderr no arquivo &lt;code&gt;out.txt&lt;/code&gt; pode ser colocado da seguinte maneira com o log dos tempos (-t) opicional.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ strace -f -t -etrace=write -s 666 -p PID_DO_PROCESSO 2&amp;gt;&amp;amp;1 | grep --line-buffered -e &#39;write(2, &#39; -e &#39;write(1, &#39; &amp;gt;&amp;gt; out.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O código abaixo tem uma alteração no &lt;code&gt;server_mlops.py&lt;/code&gt; ,  e execute ele assim como o &lt;code&gt;client_mlops.py&lt;/code&gt;. Pegando o PID do &lt;code&gt;serve_mlops&lt;/code&gt; você conseguirá explorar esse exemplo&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# server_mlops.py
import time
import flask
import sys

app = flask.Flask(__name__)

@app.route(&#39;/&#39;)
def hello_world():
    sleep_time = flask.request.args.get(&#39;sleep&#39;, default=10, type=int)
    print(&#39;sleep_time:&#39;, sleep_time)
    for i in range(sleep_time):
        print(f&#39;INFO: {i} of sleep_time \n asdf \t &#39;)
        print(f&#39;ERROR: Example msg {i}&#39;, file=sys.stderr) 
        time.sleep(1)
    return &#39;Hello World!&#39;


if __name__ == &#39;__main__&#39;:
    app.run()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;qual-comando-gerou-o-processo-e-onde-é-o-seu-working-dir&#34;&gt;Qual comando gerou o processo e onde é o seu working dir?&lt;/h3&gt;
&lt;p&gt;Essa pergunta talvez não seja tão difícil de responder se você tem o &lt;code&gt;htop&lt;/code&gt; instalado. Mas supondo que  você não lembra  as informações sobre o comando que gerou o processo execute o comando abaixo&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ tr &#39;\0&#39; &#39;\t&#39; &amp;lt; /proc/PID_CLIENT_MLOPS/cmdline
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;o output será&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python	client_mlops.py	--sleep	1000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para descobrir o diretório do &lt;code&gt;client_mlops.py&lt;/code&gt;  basta executar&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ readlink /proc/PID_CLIENT_MLOPS/cwd
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;agradecimentos--sugestões&#34;&gt;Agradecimentos &amp;amp; Sugestões&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Achou um erro? Tem alguma sugestão ou dica? mande um email para &lt;a href=&#34;mailto:devmessias@gmail.com&#34;&gt;devmessias@gmail.com&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Obrigado 
&lt;a href=&#34;https://www.linkedin.com/in/elisarma&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Elisa Ribeiro&lt;/a&gt; por ter corrigido os typos da primeira versão do post.&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://www.linkedin.com/in/reynaldoallanf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Reynaldo Allan Fulin&lt;/a&gt; pelas discussões sempre úteis sobre linux.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
