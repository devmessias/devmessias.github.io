<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>debugging | Bruno Messias</title><link>/pt-br/tag/debugging/</link><atom:link href="/pt-br/tag/debugging/index.xml" rel="self" type="application/rss+xml"/><description>debugging</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>pt-br</language><copyright>Bruno Messias</copyright><lastBuildDate>Mon, 11 Apr 2022 00:00:00 +0000</lastBuildDate><image><url>/images/icon_hucd6a3d413e7b81060a1d462b35f64cf9_5018_512x512_fill_lanczos_center_2.png</url><title>debugging</title><link>/pt-br/tag/debugging/</link></image><item><title>Metaprogram√ß√£o em Python com ASTs: criando um decorador com introspec√ß√£o</title><link>/pt-br/post/python_ast_metaprogramming_with_introspection_and_decorators/</link><pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate><guid>/pt-br/post/python_ast_metaprogramming_with_introspection_and_decorators/</guid><description>&lt;details
class="toc-inpage d-print-none d-none d-sm-block d-md-none " open>
&lt;summary class="font-weight-bold">Lista de Conte√∫dos&lt;/summary>
&lt;nav id="TableOfContents">
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>&lt;a href="#introdu√ß√£o">Introdu√ß√£o&lt;/a>&lt;/li>
&lt;li>&lt;a href="#asts-o-que-s√£o">ASTs: O que s√£o?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#python-√©--interpretado-ou-compilado">Python √© interpretado ou compilado?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#extraindo-e-interpretando-asts">Extraindo e interpretando ASTs&lt;/a>&lt;/li>
&lt;li>&lt;a href="#como-metaprogramar-de-forma-eficiente">Como metaprogramar de forma eficiente?&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#6-passos-simples">6 passos simples&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#criando-nossa-meta-fun√ß√£o">Criando nossa meta-fun√ß√£o&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#primeira-itera√ß√£o">Primeira itera√ß√£o&lt;/a>&lt;/li>
&lt;li>&lt;a href="#o-nodetransformer">O NodeTransformer&lt;/a>&lt;/li>
&lt;li>&lt;a href="#a-segunda-itera√ß√£o">A segunda itera√ß√£o&lt;/a>&lt;/li>
&lt;li>&lt;a href="#criando-uma-nova-fun√ß√£o-em-runtime">Criando uma nova fun√ß√£o em runtime&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#integrando-a-manipula√ß√£o-de-ast-com-um-decorador">Integrando a manipula√ß√£o de AST com um decorador&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/nav>
&lt;/details>
&lt;h2 id="introdu√ß√£o">Introdu√ß√£o&lt;/h2>
&lt;p>N√£o se assuste com as palavras no t√≠tulo. Embora elas podem ser estranhas para voc√™ provavelmente em algum momento voc√™ utilizou ferramentas que fazem uso de t√©cnicas de metaprograma√ß√£o ou inspe√ß√£o de AST. Pytest e Numba s√£o exemplos.&lt;/p>
&lt;p>No post anterior eu falei sobre python frames e inspection. Mostrei como podemos usar &lt;code>inspect.signautre&lt;/code> para criar um decorador que valide argumentos:&lt;/p>
&lt;pre>&lt;code class="language-python">@math_validator()
def simple_method(x: &amp;quot;\in R&amp;quot;, y: &amp;quot;\in R_+&amp;quot;, z: float = 2) -&amp;gt; float:
...
simple_method(1, 0)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>simple_method((1, 2)) -&amp;gt; 1.5
---&amp;gt; 19 simple_method(1, 0)
...
&amp;lt;locals&amp;gt;.decorate.&amp;lt;locals&amp;gt;.decorated(*_args)
11 continue
13 if not MATH_SPACES[annotation][&amp;quot;validator&amp;quot;](_args[i]):
---&amp;gt; 14 raise ValueError(f&amp;quot;{k} doesn't belong to the {MATH_SPACES[annotation]['name']}&amp;quot;)
15 result = func(*_args)
16 print(f&amp;quot;{func.__name__}({_args}) -&amp;gt; {result}&amp;quot;)
ValueError: y doesn't belong to the space of real numbers greater than zero
&lt;/code>&lt;/pre>
&lt;p>No outro exemplo mostrei como podemos combinar o &lt;code>signature&lt;/code> com &lt;code>sys.trace&lt;/code> para criar um decorador que exp√µe o &lt;code>locals&lt;/code> da fun√ß√£o decorada. O que nos permite fazer coisas legais tais como criar um decorador &lt;code>@report&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-python">@report('{arg.n_bananas} Monkey {gluttonous_monkey} ate too much bananas. Num monkeys {num_monkeys}')
def feed_monkeys(n_bananas):
num_monkeys = 3
monkeys = {
f&amp;quot;monkey_{i}&amp;quot;: {&amp;quot;bananas&amp;quot;: 0}
for i in range(num_monkeys)
}
while n_bananas &amp;gt; 0:
if np.random.uniform() &amp;lt; 0.4:
continue
monkey = monkeys[np.random.choice(list(monkeys.keys()))]
if n_bananas &amp;gt; 0:
monkey[&amp;quot;bananas&amp;quot;] += 1
n_bananas -= 1
gluttonous_monkey = max(monkeys, key=lambda k: monkeys[k][&amp;quot;bananas&amp;quot;])
&lt;/code>&lt;/pre>
&lt;p>Contudo, no final do post passado eu disse que essa solu√ß√£o tem alguns problemas&lt;/p>
&lt;p>&lt;div class="spoiler " >
&lt;p>
&lt;a class="btn btn-primary" data-toggle="collapse" href="#spoiler-1" role="button" aria-expanded="false" aria-controls="spoiler-1">
Click here to see the solution
&lt;/a>
&lt;/p>
&lt;div class="collapse card " id="spoiler-1">
&lt;div class="card-body">
&lt;pre>&lt;code class="language-python">import sys
import inspect
from types import SimpleNamespace
def call_and_extract_frame(func, *args, **kwargs):
frame_var = None
trace = sys.gettrace()
def update_frame_var(stack_frame, event_name, arg_frame):
&amp;quot;&amp;quot;&amp;quot;
Args:
stack_frame: (frame)
The current stack frame.
event_name: (str)
The name of the event that triggered the call.
Can be 'call', 'line', 'return' and 'exception'.
arg_frame:
Depends on the event. Can be a None type
&amp;quot;&amp;quot;&amp;quot;
nonlocal frame_var # nonlocal is a keyword which allows us to modify the outisde scope variable
if event_name != 'call':
return trace
frame_var = stack_frame
sys.settrace(trace)
return trace
sys.settrace(update_frame_var)
try:
func_result = func(*args, **kwargs)
finally:
sys.settrace(trace)
return frame_var, func_result
def report(formater):
def decorate(func):
def decorated(*_args):
sig = inspect.signature(func)
named_args = {}
num_args = len(_args)
for i, (k, v) in enumerate(sig.parameters.items()):
if i &amp;lt; num_args:
named_args[k] = repr(_args[i])
else:
named_args[k] = repr(v.default)
frame_func, _result = call_and_extract_frame(func, *_args)
name = func.__name__
result = repr(_result)
args_dict = {
&amp;quot;args&amp;quot;: SimpleNamespace(**named_args),
&amp;quot;args_repr&amp;quot;: repr(SimpleNamespace(**named_args)),
**locals(),
**frame_func.f_locals,
}
print(formater.format(**args_dict))
# do other stuff here
return _result
return decorated
return decorate
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
Quais s√£o os problemas?&lt;/p>
&lt;ul>
&lt;li>
&lt;p>√â esperado que o tracing reduza a performance do sistema. Se voc√™ usar a solu√ß√£o acima s√≥ para casos pontuais ou debug √© ok&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Pode criar conflitos com outras ferramentas e bibliotecas que tamb√©m est√£o usando a ferramenta de tracing, tais como debuggers.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Parece uma solu√ß√£o feia!&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Voc√™ pode se perguntar: &amp;ldquo;&lt;em>Overengineering! Era s√≥ esse fazer isso aqui:&lt;/em>&amp;rdquo;&lt;/p>
&lt;pre>&lt;code class="language-python">@report('stuff goes here')
def func(x, y):
random_var = np.random.uniform()
... #more local vars
result = (x+y)**random_var
return result, locals
&lt;/code>&lt;/pre>
&lt;p>&lt;em>&amp;quot;..e dentro do decorador ele mudar para isso&amp;quot;&lt;/em>&lt;/p>
&lt;pre>&lt;code class="language-python">_result, local_vars = func(x, y)
&lt;/code>&lt;/pre>
&lt;p>A raz√£o √©:&lt;/p>
&lt;p>O ponto de usar um decorador √© para evitar mudan√ßas em qualquer outra parte da nossa codebase. Por exemplo, se em qualquer outra parte da nossa codebase func est√° sendo chamada, eu teria que fazer mudan√ßas do tipo&lt;/p>
&lt;pre>&lt;code class="language-python">result = func(x, y) # to
result = func(x, y)[0]
&lt;/code>&lt;/pre>
&lt;p>E se futuramente eu quisesse remover o decorador de uma fun√ß√£o eu teria que desfazer todas as mudan√ßas acima&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Voc√™ ir√° aumentar o cognitive load de todos os membros do seu time que n√£o precisam saber sobre ou usar o decorador.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Se voc√™ est√° ok com fazer mudan√ßas em outros lugares do seu c√≥digo por que n√£o criar novas fun√ß√µes ao inv√©s de decoradores que funcionam mais ou menos?&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Ok, voc√™ pode estar pensando: &amp;ldquo;T√° , faz sentido n√£o fazer isso que sugeri, mas do que adianta evitar sujar sua codebase se voc√™ t√° criando problemas de desempenho e debug? N√£o parece uma boa solu√ß√£o na maioria dos casos. Eu tenho que concordar com voc√™!&amp;rdquo;&lt;/p>
&lt;p>Bom, ent√£o o que podemos fazer?? O problema que encontramos √© que em python n√£o temos context managers que podem lidar com namespaces
&lt;a href="https://mail.python.org/archives/list/python-ideas@python.org/thread/TAVHEKDZVYKJUGZKWSVZVAOGBPLZVKQG/" target="_blank" rel="noopener">https://mail.python.org/archives/list/python-ideas@python.org/&lt;/a>. Mas se desanime com essa limita√ß√£o, a quest√£o agora √©:&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
&lt;strong>Se uma linguagem n√£o tem uma feature que eu preciso o que eu posso fazer?&lt;/strong>
&lt;/div>
&lt;/div>
&lt;p>Em pyhton estamos bem com isso pois √© f√°cil manipular o que √© conhecido como &lt;strong>A&lt;/strong>bstract &lt;strong>S&lt;/strong>yntax &lt;strong>T&lt;/strong>ree (√°rvore sint√°tica abstrata) e compilar ela em uma nova fun√ß√£o em tempo de execu√ß√£o (runtime). ** Quando programamos desse jeito estamos no reino da metaprograma√ß√£o! Tentarei esclarecer esses pontos agora**&lt;/p>
&lt;h2 id="asts-o-que-s√£o">ASTs: O que s√£o?&lt;/h2>
&lt;p>Uma linguagem de programa√ß√£o √© obviamente, pelo menos uma linguagem&amp;hellip; OK, &lt;strong>mas o que √© uma linguagem? Todas as linguagens humanas compartilham uma estrutura em comum? Como podemos comparar senten√ßas diferentes na mesma linguagem?&lt;/strong> Essas quest√µes talvez pare√ßam ser mais adequadas para serem respondidas por fil√≥sofos. Contudo, tamb√©m √© tema de trabalho de matem√°ticos e computeiros&lt;/p>
&lt;p>A grande diferen√ßa √© que matem√°ticos e computeiros comumente preferem falar sobre coisas usando algum formalismo matem√°tico. Em ess√™ncia, &lt;strong>AST&lt;/strong> faz parte de um formalismo matem√°tico que permite isso. Uma &lt;strong>AST&lt;/strong> permite representar uma senten√ßa atrav√©s de um grafo direcionado do tipo √°rvore. Para isso usamos um conjunto de regras bem definidas em como construir essa √°rvore.&lt;/p>
&lt;h3>Como saber se uma senten√ßa est√° gramaticalmente correta?&lt;/h3>
&lt;p>Voc√™ provavelmente se lembra quase institivamente de um conjunto de regras que aprendeu durante sua vida ou acabou se acostumando sobre como organizar e compor verbos, substantivos, adjetivos, etc. Este conjunto de regras e guias √© a sintaxe da linguagem que voc√™ fala/escreve. &lt;em>AST&lt;/em>s permitem checar e compreender uma senten√ßa utilizando essas regras&lt;/p>
&lt;p>Pegue por exemplo a senten√ßa&lt;/p>
&lt;p>&lt;em>&amp;ldquo;I drive a car to my college&amp;rdquo;&lt;/em>, a AST √© a seguinte&lt;/p>
&lt;figure id="figure-fonte-geeks-for-geekssyntax-tree--natural-language-processinghttpswwwgeeksforgeeksorgsyntax-tree-natural-language-processing">
&lt;a data-fancybox="" href="/pt-br/post/python_ast_metaprogramming_with_introspection_and_decorators/ast_english_sentence_hue5b8d52ce962721ee6d0acb19268cb10_239788_0x400_resize_lanczos_2.png" data-caption="&amp;lt;strong&amp;gt;Fonte&amp;lt;/strong&amp;gt;:&amp;lt;a href=&amp;#34;https://www.geeksforgeeks.org/syntax-tree-natural-language-processing/&amp;#34;&amp;gt; Geeks for Geeks:Syntax Tree ‚Äì Natural Language Processing.&amp;lt;/a&amp;gt;">
&lt;img src="/pt-br/post/python_ast_metaprogramming_with_introspection_and_decorators/ast_english_sentence_hue5b8d52ce962721ee6d0acb19268cb10_239788_0x400_resize_lanczos_2.png" alt="" height="400px">
&lt;/a>
&lt;figcaption>
&lt;strong>Fonte&lt;/strong>:&lt;a href="https://www.geeksforgeeks.org/syntax-tree-natural-language-processing/"> Geeks for Geeks:Syntax Tree ‚Äì Natural Language Processing.&lt;/a>
&lt;/figcaption>
&lt;/figure>
&lt;p>Qual a vantagem de usar ASTs? Note que n√£o precisamos falar de espa√ßos, caligrafia ou estilo pessoal de organizar escrita para compreender uma senten√ßa e saber se ela est√° v√°lida. Al√©m disso, temos uma estrutura hier√°rquica que permite entender a senten√ßa por n√≠veis!&lt;/p>
&lt;p>N√£o √© uma surpresa que ASTs s√£o tamb√©m uma ferramenta comum em processos de analisar a validade de um c√≥digo ou na constru√ß√£o de um compilador/interpretador. Nesse post iremos manipular a AST! Mas antes disso quero fazer uma pergunta:&lt;/p>
&lt;h2 id="python-√©--interpretado-ou-compilado">Python √© interpretado ou compilado?&lt;/h2>
&lt;p>Geralmente, quando encontro um hater de python ou mesmo um entusiasta ou√ßo ou leio coisas do tipo:&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;&lt;em>Python √© lento pois √© uma linguagem interpretada&lt;/em>&amp;rdquo;&lt;/li>
&lt;li>&amp;ldquo;*Python √© legal pois n√£o tem chatice de compila√ß√£o&amp;rdquo;&lt;/li>
&lt;li>&lt;em>&amp;ldquo;Python √© ruim comparado a C pois n√£o tem um compilador&amp;rdquo;&lt;/em>&lt;/li>
&lt;/ul>
&lt;p>Bem, essas asser√ß√µes n√£o s√£o verdadeiras, pois est√£o usando conceitos errados! Outra confus√£o √© que geralmente quando se fala em python estamos nos referindo a linguagem (sintaxe, etc) python mais a m√°quina virtual do CPython. Vamos conversar um pouco mais sobre isso&lt;/p>
&lt;p>Dizer que uma linguagem hoje √© &lt;em>puramente compilada ou interpretada&lt;/em> √© confuso, pois essa divis√£o √© borrada. Veja o seguinte&lt;/p>
&lt;pre>&lt;code class="language-python">hello_world = &amp;quot;print('Hello, world!')&amp;quot;
hello_world_obj = compile(hello_world, '&amp;lt;string&amp;gt;', 'single')
&lt;/code>&lt;/pre>
&lt;p>Pois √©&amp;hellip; se voc√™ tentaria defender nos coment√°rios que python √© puramente interpretado as coisas est√£o mais dif√≠ceis para voc√™. Por que tem um &lt;code>compile&lt;/code> dispon√≠vel? O que ele faz?&lt;/p>
&lt;pre>&lt;code class="language-python">exec(hello_world_obj)
Hello, world!
&lt;/code>&lt;/pre>
&lt;p>O que ser√° que tem dentro desse &lt;code>hello_world_obj&lt;/code>?&lt;/p>
&lt;pre>&lt;code class="language-python">print(f&amp;quot;Bad news for you:\n\tContent: {hello_world_obj.co_code}\n\tType: {type(hello_world_obj.co_code)}&amp;quot;)
Bad news for you:
Content: b'e\x00d\x00\x83\x01F\x00d\x01S\x00'
Type: &amp;lt;class 'bytes'&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>Para entender os prints acima voc√™ precisa compreender o que acontece por tr√°s dos panos quando um c√≥digo python √© &amp;ldquo;&lt;em>interpretado&lt;/em>&amp;rdquo;.&lt;/p>
&lt;p>Ap√≥s voc√™ escrever um c√≥digo e chamar o comando python, o python inicia um processo de compila√ß√£o criando as ASTs, depois gerando bytecodes a partir das ASTs e esses √∫ltimos ser√£o encapsulados em &lt;code>code_object&lt;/code>s. Na √∫ltima etapa os code objects ser√£o interpretados pela m√°quina virtual do CPython. O diagrama √† baixo √© uma representa√ß√£o simples (com passos omitidos) do processo&lt;/p>
&lt;div class="mermaid mermaidContainer">
graph LR;
A[Source Code]-->|parsing|B[Parse Tree];
B-->C[AST];
C-->E[Bytecode];
E-->F[Code Object];
F-->|execution by|G[CPython Virtual Machine];
&lt;/div>
&lt;p>A fase de compila√ß√£o s√£o os primeiros passos do diagrama acima&lt;/p>
&lt;div class="mermaid mermaidContainer">
graph LR;
A[Source Code]-->|parsing|B[Parse Tree];
B-->C[AST];
C-->E[Bytecode];
E-->F[Code Object];
&lt;/div>
Se voc√™ n√£o conhece os conceitos dos nomes acima n√£o se preocupe, n√£o precisamos de tanto aprofundamento.
**Bytecodes s√£o apenas uma maneira compacta de dizer ao interpretador o que o c√≥digo quer que ele fa√ßa. Enquanto code objects s√£o coisas que encapsulam esses bytecodes.**
&lt;p>Ok, onde isso entra na minha solu√ß√£o? O que eu proponho fazer √© manipular a AST e compilar um novo code object que ser√° interpretado pelo cpython!&lt;/p>
&lt;blockquote>
&lt;p>Um hist√≥ria engra√ßada do Luciano Ramalho:
&lt;blockquote class="twitter-tweet">&lt;p lang="en" dir="ltr">In 2018 I told a CBP officer I was entering the US to speak at PyCon. He asked: &amp;quot;Is Python interpreted or compiled?&amp;quot; After a 2 second pause I said &amp;quot;Interpreted&amp;quot;. I didn&amp;#39;t give the correct answer because I didn&amp;#39;t want to extend the &amp;quot;pleasant&amp;quot; conversation. He let me in.&lt;/p>&amp;mdash; Luciano Ramalho ‚òî üêç ‚öó ‚ñ∂Ô∏èüò∑üíâüíâüíâ (@ramalhoorg) &lt;a href="https://twitter.com/ramalhoorg/status/1474044907585167362?ref_src=twsrc%5Etfw">December 23, 2021&lt;/a>&lt;/blockquote>
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script>
&lt;/p>
&lt;/blockquote>
&lt;h2 id="extraindo-e-interpretando-asts">Extraindo e interpretando ASTs&lt;/h2>
&lt;p>Veja o seguinte exemplo:&lt;/p>
&lt;pre>&lt;code class="language-python">import inspect
import ast
import astor # install this for pretty printing
def example(a: float, b:float = 2) -&amp;gt; float:
s = a+b
return s
tree = ast.parse(inspect.getsource(example))
print(astor.dump(tree))
astor.to_source(tree)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>Module(
body=[
FunctionDef(name='example',
args=arguments(posonlyargs=[],
args=[arg(arg='a', annotation=Name(id='float'), type_comment=None),
arg(arg='b', annotation=Name(id='float'), type_comment=None)],
vararg=None,
kwonlyargs=[],
kw_defaults=[],
kwarg=None,
defaults=[Constant(value=2, kind=None)]),
body=[
Assign(targets=[Name(id='s')],
value=BinOp(left=Name(id='a'), op=Add, right=Name(id='b')),
type_comment=None),
Return(value=Name(id='s'))],
decorator_list=[],
returns=Name(id='float'),
type_comment=None)],
type_ignores=[])
&lt;/code>&lt;/pre>
&lt;p>O output acima √© a AST da fun√ß√£o. Gaste algum tempo olhando essa sa√≠da e tente entender/inferir o que cada coisa significa e como ela √© organizada. A imagem abaixo √© a representa√ß√£o visual da sa√≠da acima&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="/pt-br/post/python_ast_metaprogramming_with_introspection_and_decorators/simple_ast_hudca446749283cbe6d28b67a245474890_120568_0x1000_resize_lanczos_2.png" >
&lt;img src="/pt-br/post/python_ast_metaprogramming_with_introspection_and_decorators/simple_ast_hudca446749283cbe6d28b67a245474890_120568_0x1000_resize_lanczos_2.png" alt="" height="400px">
&lt;/a>
&lt;/figure>
&lt;p>Cada elemento do output que inicia com uma letra mai√∫scula √© um n√≥, &lt;strong>node&lt;/strong>(Name, BinOp, FunctionDef, etc) derivado da classe &lt;code>ast.Node&lt;/code>. Um dos n√≥s mais importante √© o &lt;code>ast.Name&lt;/code>.
Por exemplo em&lt;/p>
&lt;pre>&lt;code>value=BinOp(left=Name(id='a'), op=Add, right=Name(id='b')),
&lt;/code>&lt;/pre>
&lt;p>o &lt;code>ast.Name(...&lt;/code> √© usado para referenciar as vari√°veis &lt;code>a&lt;/code> e &lt;code>b&lt;/code> da nossa fun√ß√£o.&lt;/p>
&lt;p>Ok, voltemos ao nosso problema. Lembre-se que uma solu√ß√£o ruim era reescrever cada fun√ß√£o que precisa ser decorada, por exemplo&lt;/p>
&lt;pre>&lt;code class="language-python">def func(x, y):
random_var = np.random.uniform()
... #more local vars
result = (x+y)**random_var
return result
&lt;/code>&lt;/pre>
&lt;p>como&lt;/p>
&lt;pre>&lt;code class="language-python">def func_transformed(x, y):
random_var = np.random.uniform()
... #more local vars
result = (x+y)**random_var
return result, locals
&lt;/code>&lt;/pre>
&lt;p>A coisa legal que faremos aqui √© &lt;strong>escrever uma fun√ß√£o que escrevera essas mudan√ßas para n√≥s! E depois colocaremos a compila√ß√£o dentro de um decorador para evitar que nossa codebase seja alterada.&lt;/strong>&lt;/p>
&lt;h2 id="como-metaprogramar-de-forma-eficiente">Como metaprogramar de forma eficiente?&lt;/h2>
&lt;p>Fazer um c√≥digo que fa√ßa as altera√ß√µes desejadas na nossa AST pode ser trabalhoso. Como come√ßar a ter uma ideia do que precisa ser feito? Eu penso em uma sucess√£o de 6 passos e ir iterando para melhorar&lt;/p>
&lt;h3 id="6-passos-simples">6 passos simples&lt;/h3>
&lt;ol>
&lt;li>Criar uma fun√ß√£o exemplo (A)&lt;/li>
&lt;li>Codar uma fun√ß√£o transformada do jeito que queremos que ela seja (B)&lt;/li>
&lt;li>Escrever um teste para que possa ser usado posteriormente para&lt;br>
checar se nossa fun√ß√£o transformada (B) bate com a fun√ß√£o gerada pela meta-programa√ß√£o (C)&lt;/li>
&lt;li>Extrair a AST de A e B&lt;/li>
&lt;li>Comparar as ASTs. O que elas diferem? Anote as diferen√ßas
&lt;ul>
&lt;li>Voc√™ pode usar a &lt;code>difflib&lt;/code> do python para fazer isso&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Criar uma nova e mais complexa fun√ß√£o exemplo (A) e repetir o processo at√© termos uma boa ideia das modifica√ß√µes necess√°rias na AST&lt;/li>
&lt;/ol>
&lt;h2 id="criando-nossa-meta-fun√ß√£o">Criando nossa meta-fun√ß√£o&lt;/h2>
&lt;h3 id="primeira-itera√ß√£o">Primeira itera√ß√£o&lt;/h3>
&lt;p>Come√ßaremos escrevendo uma fun√ß√£o incrivelmente simples&lt;/p>
&lt;pre>&lt;code class="language-python">def example_1(x, y):
internal_var = 222
result = (x+y)**internal_var
return result
def example_1_expected(x, y):
internal_var = 222
result = (x+y)**internal_var
return result, locals()
def test_meta_example_1(meta_func, x, y):
expected_result, expected_locals = example_1_expected(x, y)
result, locals_dict = meta_func(x, y)
assert result == expected_result
assert expected_locals == locals_dict
&lt;/code>&lt;/pre>
&lt;p>Agora usaseri a &lt;code>difflib&lt;/code> para entender as diferen√ßas entre as duas ASTs.&lt;/p>
&lt;pre>&lt;code class="language-python">import difflib
from pprint import pprint
example_1_ast_str = astor.dump_tree(ast.parse(inspect.getsource(example_1)))
example_1_expected_str = astor.dump_tree(ast.parse(inspect.getsource(example_1_expected)))
pprint(
list(
difflib.unified_diff(example_1_ast_str.splitlines(), example_1_expected_str.splitlines(), n=0)
)
)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>['--- \n',
'+++ \n',
'@@ -3 +3 @@\n',
&amp;quot;- FunctionDef(name='example_1',&amp;quot;,
&amp;quot;+ FunctionDef(name='example_1_expected',&amp;quot;,
'@@ -19 +19 @@\n',
&amp;quot;- Return(value=Name(id='result'))],&amp;quot;,
&amp;quot;+ Return(value=Tuple(elts=[Name(id='result'), &amp;quot;
&amp;quot;Call(func=Name(id='locals'), args=[], keywords=[])]))],&amp;quot;]
&lt;/code>&lt;/pre>
&lt;p>Com o output acima sabemos aogra que precisaremos mudar o seguinte n√≥ na AST&lt;/p>
&lt;pre>&lt;code>Return(value=Name(id='result'))],
&lt;/code>&lt;/pre>
&lt;p>para isto&lt;/p>
&lt;pre>&lt;code>Return(value=Tuple(elts=[Name(id='result'), Call(func=Name(id='locals'), args=[], keywords=[])]))],
&lt;/code>&lt;/pre>
&lt;p>Como alterar n√≥s na AST? Com a ajuda do &lt;code>NodeTransformer&lt;/code>&lt;/p>
&lt;h3 id="o-nodetransformer">O NodeTransformer&lt;/h3>
&lt;p>O &lt;code>ast.NodeTransformer&lt;/code> nos permite criar objetos com uma interface de caminhante. O caminhante visitar√° cada Node da AST e durante cada visita ele pode remover, substituir, modificar ou adicionar Nodes. Ap√≥s fazer essas altera√ß√µes o caminhante pode continuar sua caminhada nos filhos do Node ou apenas parar.&lt;/p>
&lt;p>Vamos iniciar criando uma classe derivada de &lt;code>ast.NodeTransformer&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-python">class ASTTransformer(ast.NodeTransformer):
def visit_Return(self, node):
&lt;/code>&lt;/pre>
&lt;p>Se queremos interagir com um n√≥ do tipo &lt;code>AlgumaCoisa&lt;/code> precisamos sobrescrever o m√©todo &lt;code>visit_AlgumaCoisa&lt;/code>.
Portanto, como sabemos que precisamos mudar o &lt;code>Return&lt;/code> iremos sobrescrever o &lt;code>visit_Return&lt;/code>. Precisaremos criar tamb√©m um n√≥ para pegar o &lt;code>locals&lt;/code>. Esse n√≥ √© o &lt;code>Call&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-python">class ASTTransformer(ast.NodeTransformer):
def visit_Return(self, node):
node_locals = ast.Call(
func=ast.Name(id='locals', ctx=ast.Load()),
args=[], keywords=[]
)
self.generic_visit(node)
return node
&lt;/code>&lt;/pre>
&lt;p>Veja que usamos o n√≥ &lt;code>Name&lt;/code> para identificar a fun√ß√£o &lt;code>locals&lt;/code>. Agora, de acordo com o resultado do nosso diff o resultado do &lt;code>Return&lt;/code> precisa ser uma n√≥ do tipo &lt;code>Tuple&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-python">class ASTTransformer(ast.NodeTransformer):
def visit_Return(self, node):
node_locals = ast.Call(
func=ast.Name(id='locals', ctx=ast.Load()),
args=[], keywords=[]
)
new_node.value = ast.Tuple(
elts=[
node.value,
node_locals
],
ctx=ast.Load()
)
self.generic_visit(new_node)
return new_node
&lt;/code>&lt;/pre>
&lt;p>Uma nova coisa apareceu. O argumento &lt;code>elts&lt;/code>. N√£o se preoucupe em entender tudo. Mas o &lt;code>elts&lt;/code> √© um arg que diz qual √© a lista de n√≥s que a Tupla deve conter. Toda vez que voc√™ quiser entender um pouco mais sobre ASTs e a gram√°tica do python voc√™ pode consultar a documenta√ß√£o oficial
&lt;a href="https://docs.python.org/3/library/ast.html" target="_blank" rel="noopener">aqui&lt;/a>.&lt;/p>
&lt;p>Quase tudo pronto. A √∫ltima coisa que precisamos fazer √© corrigir nossa AST. Pois ao alterar o Node precisamos preencher/corrigir as informa√ß√µes de line_number e column_offest. O python torna isso f√°cil com o m√©todo &lt;code>fix_missing_locations&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-python">
class ASTTransformer(ast.NodeTransformer):
def visit_Return(self, node):
new_node = node
node_locals = ast.Call(
func=ast.Name(id='locals', ctx=ast.Load()),
args=[], keywords=[]
)
new_node.value = ast.Tuple(
elts=[
node.value,
node_locals
],
ctx=ast.Load()
)
ast.copy_location(new_node, node)
ast.fix_missing_locations(new_node)
self.generic_visit(new_node)
return new_node
&lt;/code>&lt;/pre>
&lt;p>Ok, vamos ver se funcionou. Para isso, precisamos instanciar nosso transformer e chamar o m√©todo &lt;code>visit&lt;/code> que diz para o caminhante iniciar a caminhada e fazer as modifica√ß√µes pedidas&lt;/p>
&lt;pre>&lt;code class="language-python">tree_meta = ast.parse(inspect.getsource(example_1))
transformer = ASTTransformer()
transformer.visit(tree_meta)
example_1_meta_ast_str = astor.dump_tree(tree_meta)
example_1_expected_str = astor.dump_tree(ast.parse(inspect.getsource(example_1_expected)))
pprint(
list(
difflib.unified_diff(example_1_meta_ast_str.splitlines(), example_1_expected_str.splitlines(), n=0)
)
)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>['--- \n',
'+++ \n',
'@@ -3 +3 @@\n',
&amp;quot;- FunctionDef(name='example_1',&amp;quot;,
&amp;quot;+ FunctionDef(name='example_1_expected',&amp;quot;]
&lt;/code>&lt;/pre>
&lt;p>Funcionou! Vamos adicionar um pouco mais de complica√ß√£o para ver se o NodeTransformer continuar√° funcionando.&lt;/p>
&lt;h3 id="a-segunda-itera√ß√£o">A segunda itera√ß√£o&lt;/h3>
&lt;p>Seja criativo na hora de complicar, eu fiz isso aqui √© feio mais adiciona muita confus√£o para estressar o NodeTransformer.&lt;/p>
&lt;pre>&lt;code class="language-python">def example_2(x, y):
internal_var = 222
def sub(x, y):
ommit_this_var = 1
return x - y
result = sub(x,y)**internal_var
return (result, False)
def example_2_expected(x, y):
internal_var = 222
def sub(x, y):
ommit_this_var = 1
return x - y
result = sub(x,y)**internal_var
return ((result, False), locals())
def test_meta_example_2(meta_func, x, y):
expected_result, expected_locals = example_2_expected(x, y)
result, locals_dict = meta_func(x, y)
del locals_dict[&amp;quot;sub&amp;quot;]
del expected_locals[&amp;quot;sub&amp;quot;]
assert result == expected_result
assert expected_locals == locals_dict
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-python">example_2_ast_str = astor.dump_tree(ast.parse(inspect.getsource(example_2)))
example_2_expected_str = astor.dump_tree(ast.parse(inspect.getsource(example_2_expected)))
pprint(
list(
difflib.unified_diff(example_2_ast_str.splitlines(), example_2_expected_str.splitlines(), n=0)
)
)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>['--- \n',
'+++ \n',
'@@ -3 +3 @@\n',
&amp;quot;- FunctionDef(name='example_2',&amp;quot;,
&amp;quot;+ FunctionDef(name='example_2_expected',&amp;quot;,
'@@ -37 +37,4 @@\n',
&amp;quot;- Return(value=Tuple(elts=[Name(id='result'), &amp;quot;
'Constant(value=False, kind=None)]))],',
'+ Return(',
'+ value=Tuple(',
&amp;quot;+ elts=[Tuple(elts=[Name(id='result'), &amp;quot;
'Constant(value=False, kind=None)]),',
&amp;quot;+ Call(func=Name(id='locals'), args=[], &amp;quot;
'keywords=[])]))],']
&lt;/code>&lt;/pre>
&lt;p>Agora √© hora de cruzar os dedos e esperar que continue funcionando&lt;/p>
&lt;pre>&lt;code class="language-python">tree_meta = ast.parse(inspect.getsource(example_2))
transformer = ASTTransformer()
transformer.visit(tree_meta)
example_2_meta_ast_str = astor.dump_tree(tree_meta)
example_2_expected_str = astor.dump_tree(ast.parse(inspect.getsource(example_2_expected)))
pprint(
list(
difflib.unified_diff(example_2_meta_ast_str.splitlines(), example_2_expected_str.splitlines(), n=0)
)
)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>['--- \n',
'+++ \n',
'@@ -3 +3 @@\n',
&amp;quot;- FunctionDef(name='example_2',&amp;quot;,
&amp;quot;+ FunctionDef(name='example_2_expected',&amp;quot;,
'@@ -27,4 +27 @@\n',
'- Return(',
'- value=Tuple(',
&amp;quot;- elts=[BinOp(left=Name(id='x'), op=Sub, &amp;quot;
&amp;quot;right=Name(id='y')),&amp;quot;,
&amp;quot;- Call(func=Name(id='locals'), args=[], &amp;quot;
'keywords=[])]))],',
&amp;quot;+ Return(value=BinOp(left=Name(id='x'), op=Sub, &amp;quot;
&amp;quot;right=Name(id='y')))],&amp;quot;]
&lt;/code>&lt;/pre>
&lt;p>Falhou miseravelmente. Qual √© o problema? Se voc√™ olhar o &lt;code>diff&lt;/code> com cuidado ver√° que o &lt;code>NodeTransformer&lt;/code> alterou a fun√ß√£o interna. N√£o queremos isso. Portanto, diremos para o caminhante evitar modificar se estiver em uma fun√ß√£o interna. Para isso, precisamos sobrescrever o m√©todo &lt;code>visit_FunctionDef&lt;/code> e criar uma flag para marcar em que n√≠vel o caminhante est√°&lt;/p>
&lt;pre>&lt;code class="language-python">class ASTTransformer(ast.NodeTransformer):
def visit_FunctionDef(self, node):
if self._sub:
return node
self._sub = True
self.generic_visit(node)
return node
def visit_Module(self, node):
self._sub = 0
self.generic_visit(node)
def visit_Return(self, node):
new_node = node
node_locals = ast.Call(
func=ast.Name(id='locals', ctx=ast.Load()),
args=[], keywords=[]
)
new_node.value = ast.Tuple(
elts=[
node.value,
node_locals
],
ctx=ast.Load()
)
ast.copy_location(new_node, node)
ast.fix_missing_locations(new_node)
self.generic_visit(new_node)
return new_node
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-python">tree_meta = ast.parse(inspect.getsource(example_2))
transformer = ASTTransformer()
transformer.visit(tree_meta)
example_2_meta_ast_str = astor.dump_tree(tree_meta)
example_2_expected_str = astor.dump_tree(ast.parse(inspect.getsource(example_2_expected)))
pprint(
list(
difflib.unified_diff(example_2_meta_ast_str.splitlines(), example_2_expected_str.splitlines(), n=0)
)
)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>['--- \n',
'+++ \n',
'@@ -3 +3 @@\n',
&amp;quot;- FunctionDef(name='example_2',&amp;quot;,
&amp;quot;+ FunctionDef(name='example_2_expected',&amp;quot;]
&lt;/code>&lt;/pre>
&lt;p>Tudo ok! Pr√≥ximo passo: compilar nossa ast.&lt;/p>
&lt;h3 id="criando-uma-nova-fun√ß√£o-em-runtime">Criando uma nova fun√ß√£o em runtime&lt;/h3>
&lt;p>O que faremos agora √© compilar a AST transformada e associa-la com uma nova fun√ß√£o. Em python podemos fazer isso em tempo de execu√ß√£o com &lt;code>type.FunctionType&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-python">from types import FunctionType, CodeType
def transform_and_compile(func: FunctionType)-&amp;gt;FunctionType:
source = inspect.getsource(func)
# we put this to remove the line from source code with the decorator
source = &amp;quot;\n&amp;quot;.join([l for l in source.splitlines() if not l.startswith(&amp;quot;@&amp;quot;)])
tree = ast.parse(source)
transformer = ASTTransformer()
transformer.visit(tree)
code_obj = compile(tree, func.__code__.co_filename, 'exec')
function_code = [c for c in code_obj.co_consts if isinstance(c, CodeType)][0]
# we must to pass the globals context to the function
transformed_func = FunctionType(function_code, func.__globals__)
return transformed_func
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-python">test_meta_example_1(transform_and_compile(example_1), 4, 2)
test_meta_example_2(transform_and_compile(example_2), 1, 2)
&lt;/code>&lt;/pre>
&lt;p>Veja que &lt;code>transform_and_compile&lt;/code> foi capaz de criar novas fun√ß√µes que passaram nos testes que escrevemos nas itera√ß√µes anteriores! Agora √© o passo final e mais f√°cil desse post. Integrar com o decorador.&lt;/p>
&lt;h2 id="integrando-a-manipula√ß√£o-de-ast-com-um-decorador">Integrando a manipula√ß√£o de AST com um decorador&lt;/h2>
&lt;p>O que faremos √© chamar &lt;code>transform_and_compile&lt;/code> logo ap√≥s o &lt;code>def decorate&lt;/code> para evitar compila√ß√µes desnecess√°rias toda vez que chamarmos a fun√ß√£o decorada&lt;/p>
&lt;pre>&lt;code class="language-python">def report(fmt):
def decorate(func):
meta_func = transform_and_compile(func)
....
&lt;/code>&lt;/pre>
&lt;p>Agora, dentro de &lt;code>def decorated&lt;/code> podemos chamar a &lt;code>meta_func&lt;/code> e retornar s√≥ o resultado pois n√£o queremos mudar nossa codebase&lt;/p>
&lt;pre>&lt;code class="language-python">def report(fmt):
def decorate(func):
meta_func = transform_and_compile(func)
...
def decorated(*_args):
_result, internal_locals = meta_func(*_args)
....
return _result
&lt;/code>&lt;/pre>
&lt;p>Com todas as coisas que fizemos no post nosso decorador &lt;code>report&lt;/code> est√° pronto para ser usado&lt;/p>
&lt;pre>&lt;code class="language-python">
def report(fmt):
def decorate(func):
meta_func = transform_and_compile(func)
sig = inspect.signature(func)
def decorated(*_args):
_result, internal_locals = meta_func(*_args)
named_args = {}
num_args = len(_args)
for i, (k, v) in enumerate(sig.parameters.items()):
if i &amp;lt; num_args:
named_args[k] = repr(_args[i])
else:
named_args[k] = repr(v.default)
name = func.__name__
result = repr(_result)
args_dict = {
**internal_locals,
**locals(),
**named_args
}
print(fmt.format(**args_dict))
# store the information in some place
return result
return decorated
return decorate
&lt;/code>&lt;/pre>
&lt;p>Veja o resultado em uma fun√ß√£o bem simples&lt;/p>
&lt;pre>&lt;code class="language-python">@report(fmt='{name}(a={a}, b={b}, c={c}); sum_ab {sum_ab}, diff_ab {dif_ab}; r={result}')
def dummy_example(a, b, c=2):
sum_ab = a + b
dif_ab = a - b
r = sum_ab**c + dif_ab**c
return r
r = dummy_example(2, 3, 1)
print(&amp;quot;r:&amp;quot;, r)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code> dummy_example(a=2, b=3, c=1); sum_ab 5, diff_ab -1; r=4
r: 4
&lt;/code>&lt;/pre>
&lt;p>Eu sei que esse post pode ter sido dif√≠cil, se tiver d√∫vida voc√™ pode entrar em contato comigo pelos coment√°rios abaixo, twitter ou linkedin. Compartilhe se voc√™ gostou.&lt;/p></description></item><item><title>An introspective python decorator using stack frames and the inspect module</title><link>/pt-br/post/python_decorator_that_exposes_locals/</link><pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate><guid>/pt-br/post/python_decorator_that_exposes_locals/</guid><description>&lt;details
class="toc-inpage d-print-none d-none d-sm-block d-md-none " open>
&lt;summary class="font-weight-bold">Lista de Conte√∫dos&lt;/summary>
&lt;nav id="TableOfContents">
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>&lt;a href="#gaining-a-deeper-understanding-about-the-execution-context-of-a-function">Gaining a deeper understanding about the execution context of a function&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#the-fluent-python-book-example">The Fluent Python Book example&lt;/a>&lt;/li>
&lt;li>&lt;a href="#current-issues-and-limitations">Current issues and limitations&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#creating-an-introspective-code-with-the-inspect-module">Creating an introspective code with the inspect module&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#a-decorator-that-validates-arguments-using-mathematical-notation">A decorator that validates arguments using mathematical notation&lt;/a>&lt;/li>
&lt;li>&lt;a href="#going-back-to-the-fluent-python-example">Going back to the Fluent python example&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#how-to-expose-the-locals-inside-of-a-decorator">How to expose the locals() inside of a decorator?&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#call-stack-and-frames-in-python">Call stack and frames in python&lt;/a>&lt;/li>
&lt;li>&lt;a href="#using-systrace-to-track-our-frames">Using sys.trace to track our frames&lt;/a>&lt;/li>
&lt;li>&lt;a href="#lets-solve-our-problem">Let&amp;rsquo;s solve our problem&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#conclusion-and-next-steps">Conclusion and next steps&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#it-depends">&amp;ldquo;&amp;hellip;it depends&amp;rdquo;&lt;/a>&lt;/li>
&lt;li>&lt;a href="#the-next-step-we-dont-need-a-trace-we-can-do-better-using-ast-manipulation">The next step: we don&amp;rsquo;t need a trace! We can do better using AST manipulation&lt;/a>&lt;/li>
&lt;li>&lt;a href="#simplenamespace-for-dictkey-instead-of-dictkey">SimpleNamespace for dict.key instead of dict[&amp;ldquo;key]&lt;/a>&lt;/li>
&lt;li>&lt;a href="#want-to-know-more-about-call-stack--inspect-and-trace">Want to know more about call stack , inspect and trace?&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/nav>
&lt;/details>
&lt;p>
&lt;a href="https://www.amazon.com.br/Fluent-Python-Luciano-Ramalho/dp/1491946008" target="_blank" rel="noopener">Fluent Python&lt;/a> is the best resource to learn to use and love python. Some days ago I was reading a section of the chapter 7: &lt;em>&amp;ldquo;Function Decorators and Closures&lt;/em>&amp;rdquo;. This chapter has a lot of interesting and cool examples. Here I&amp;rsquo;ll discuss one of them and how I tried to put more shiny stuff in it.&lt;/p>
&lt;figure id="figure-a-book-that-every-python-programmer-should-read">
&lt;a data-fancybox="" href="/pt-br/post/python_decorator_that_exposes_locals/fluent_python_huae514437a1dc47e163345635da95e061_41082_0x200_resize_lanczos_2.png" data-caption="A book that every python programmer should read.">
&lt;img src="/pt-br/post/python_decorator_that_exposes_locals/fluent_python_huae514437a1dc47e163345635da95e061_41082_0x200_resize_lanczos_2.png" alt="" height="200px">
&lt;/a>
&lt;figcaption>
A book that every python programmer should read.
&lt;/figcaption>
&lt;/figure>
&lt;h2 id="gaining-a-deeper-understanding-about-the-execution-context-of-a-function">Gaining a deeper understanding about the execution context of a function&lt;/h2>
&lt;h3 id="the-fluent-python-book-example">The Fluent Python Book example&lt;/h3>
&lt;p>Ramalho‚Äôs book presents us with a &lt;code>@clock&lt;/code> decorator that can be used to decorate a method, measure the time it takes to execute, and print in a human-readable format the arguments and name of the method. The example is shown below:&lt;/p>
&lt;pre>&lt;code class="language-python">import time
DEFAULT_FMT = '[{elapsed:0.8f}s] {name}({args}) -&amp;gt; {result}'
def clock(fmt=DEFAULT_FMT):
def decorate(func):
def clocked(*_args):
t0 = time.time()
_result = func(*_args)
elapsed = time.time() - t0
name = func.__name__
args = ', '.join(repr(arg) for arg in _args)
result = repr(_result)
log_string = fmt.format(**locals())
# send to somewhere
# csv, ELK, etc
print(log_string)
return result
return clocked
return decorate
@clock('[{elapsed:0.8f}s] {name}({args})')
def snooze(seconds):
time.sleep(seconds)
return time.time()
for _ in range(3):
snooze(.123)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>[0.12315798s] snooze(0.123)
[0.12315822s] snooze(0.123)
[0.12317085s] snooze(0.123)
&lt;/code>&lt;/pre>
&lt;p>If you don&amp;rsquo;t understand something in the above code I recommend that you take some time searching and reading about each aspect. There are many cool things being used there, for example:&lt;/p>
&lt;ul>
&lt;li>&lt;code>repr&lt;/code> which is a function that returns a string representation of an object.
&lt;ul>
&lt;li>This is essential because the &lt;code>DEFAULT_FMT&lt;/code> is a string, not a &lt;code>f-string&lt;/code>, we can&amp;rsquo;t just put a generic object to be printed in &lt;code>DEFAULT_FMT&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>log_string = fmt.format(**locals())&lt;/code>: instead of creating a repetitive code like &lt;code>fmt.format(**{&amp;quot;result&amp;quot;:result, &amp;quot;args&amp;quot;:args, ...})&lt;/code> we can just use the &lt;code>locals()&lt;/code> which is a dictionary that contains all the local variables of the current scope.&lt;/li>
&lt;/ul>
&lt;p>When I study something I always like to create a fresh problem with the stuff that I&amp;rsquo;ve learned and try to solve it. Sometimes there is no solution. But even if there is no solution, we still learn other stuff.&lt;/p>
&lt;p>I&amp;rsquo;ve started by creating the following example:&lt;/p>
&lt;pre>&lt;code class="language-python">import numpy as np
@clock('[{elapsed:0.8f}s] {name}({args})')
def snooze_and_snore(seconds, snore_loud, min_prob_to_snore=0.4):
time.sleep(seconds)
to_snore = np.random.uniform() &amp;gt; min_prob_to_snore
if to_snore:
if snore_loud:
pass
# r.requets(wake_up_everyone)
pass
return time.time()
for _ in range(3):
snooze_and_snore(.4, True, .1)
snooze_and_snore(.4, False, .1)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>[0.40229130s] snooze_and_snore(0.4, True, 0.1)
[0.40049720s] snooze_and_snore(0.4, False, 0.1)
[0.40058565s] snooze_and_snore(0.4, True, 0.1)
[0.40013075s] snooze_and_snore(0.4, False, 0.1)
[0.40052223s] snooze_and_snore(0.4, True, 0.1)
[0.40057564s] snooze_and_snore(0.4, False, 0.1)
&lt;/code>&lt;/pre>
&lt;p>Ok, what are the problems/issues/limitations that the above code showed me?&lt;/p>
&lt;h3 id="current-issues-and-limitations">Current issues and limitations&lt;/h3>
&lt;ol>
&lt;li>We don&amp;rsquo;t have information about the names of the arguments passed to the method.
&lt;ul>
&lt;li>If the list of arguments is long, trying to understand what is happening becomes a hard task. Because we are increasing the amount of stuff that we must keep in our mind. We are increasing the &lt;strong>cognitive load&lt;/strong> in the terms presented in the excelsior book:
&lt;a href="https://linghao.io/notes/a-philosophy-of-software-design" target="_blank" rel="noopener">A Philosophy of Software Design&lt;/a>.&lt;/li>
&lt;li>A person who is not familiar with the codebase cannot understand what is happening by analyzing the outputs of the decorator. If these outputs are being stored in the ELK stack, this will be unproductive.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>We have the &lt;code>locals()&lt;/code> information from the decorator which is fed by the result of the decorated method. However, we can&amp;rsquo;t get any information about the &lt;code>locals()&lt;/code> of the decorated method. Why is this bad?
&lt;ul>
&lt;li>The final internal state of the method is commonly used to understand the execution of a method.&lt;/li>
&lt;li>Sometimes a method depends on random variables defined in the local context. Thus, the same set of arguments can give different executions. Until now, we don&amp;rsquo;t have a way to get the &lt;code>locals()&lt;/code> of the decorated method. For example, in the &lt;code>snooze_and_snore&lt;/code> we can&amp;rsquo;t know if the person snored or not.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>We will attack the first issue using the inspect module. As I&amp;rsquo;ll show you, we can do cool things with this module.&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
If you know about &lt;code>sys.trace&lt;/code>, &lt;code>call stack&lt;/code> and &lt;code>inspect.signatures&lt;/code> I recommend
you go directly to the section &lt;a href="#lets_solve_our_problem">Let&amp;rsquo;s solve our problem&lt;/a>
&lt;/div>
&lt;/div>
&lt;h2 id="creating-an-introspective-code-with-the-inspect-module">Creating an introspective code with the inspect module&lt;/h2>
&lt;p>The
&lt;a href="https://docs.python.org/3/library/inspect.html" target="_blank" rel="noopener">inspect&lt;/a> module is a Python standard library that provides several tools to help you to introspect and consequently learn about live objects like functions, modules, classes, instances, frame objects (I&amp;rsquo;ll talk about frames later in this post), etc. Well, what can you do with this? Really, a lot of things. You can use it to automatically create documentation, parse the docstrings, manipulate the AST, etc.&lt;/p>
&lt;h3 id="a-decorator-that-validates-arguments-using-mathematical-notation">A decorator that validates arguments using mathematical notation&lt;/h3>
&lt;p>In the last years, we have seen the development of the &lt;code>typing&lt;/code> module and the &lt;code>mypy&lt;/code> static analysis tool for python. This module and tool can be very useful sometimes. However, it doesn&amp;rsquo;t provide some features that are essential for proper validation. But at least in my experience creating code for my Ph.D., I usually don&amp;rsquo;t need so much sophisticated type theory and validation to be able to write a good code for a mathematical modeling tool. Most of the mathematical validation that I need is just checking if an argument still satisfies some constraints or lives in a proper subspace. If not, I need to raise an exception or perform some kind of regularization.&lt;/p>
&lt;p>Let&amp;rsquo;s create a decorator that will validate arguments using simple mathematical notation.&lt;/p>
&lt;p>We will create a dictionary that will contain the annotation as a key and the value will be a human-readable
description of the annotation and a method responsible for check if everything is right.&lt;/p>
&lt;pre>&lt;code class="language-python">import inspect
MATH_SPACES = {
&amp;quot;\in R&amp;quot;: {&amp;quot;name&amp;quot; : &amp;quot;real space&amp;quot;, &amp;quot;validator&amp;quot;: lambda x: isinstance(x, (int, float))},
&amp;quot;\in R_+&amp;quot;: {&amp;quot;name&amp;quot;: &amp;quot;space of real numbers greater than zero&amp;quot;, &amp;quot;validator&amp;quot;: lambda x: isinstance(x, (int, float)) and x &amp;gt; 0},
}
&lt;/code>&lt;/pre>
&lt;p>We will use the &lt;code>inspect.signature&lt;/code> to get the annotations of each argument of the decorated method.
For example, if the decorated method is &lt;code>def foo(a: '\in R', b)&lt;/code> the &lt;code>inspect.signature(foo)&lt;/code> will return an object which we can use to extract an ordered dictionary with the arguments and the annotations. Like this&lt;/p>
&lt;pre>&lt;code class="language-python">def foo(a: &amp;quot;\in R&amp;quot;, b, c:int, d= 2):
pass
for k, v in inspect.signature(foo).parameters.items():
print(k, v, type(v._annotation), v.default)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>a a: '\\in R' &amp;lt;class 'str'&amp;gt; &amp;lt;class 'inspect._empty'&amp;gt;
b b &amp;lt;class 'type'&amp;gt; &amp;lt;class 'inspect._empty'&amp;gt;
c c: int &amp;lt;class 'type'&amp;gt; &amp;lt;class 'inspect._empty'&amp;gt;
d d=2 &amp;lt;class 'type'&amp;gt; 2
&lt;/code>&lt;/pre>
&lt;p>Let&amp;rsquo;s create our decorator. It should be really simple. Just check if we should verify the argument and if so, check if the value respects the annotated mathematical space.&lt;/p>
&lt;pre>&lt;code class="language-python">def math_validator():
def decorate(func):
def decorated(*_args):
sig = inspect.signature(func)
# sig parameters is an ordered dict
for i, (k, v) in enumerate(sig.parameters.items()):
annotation = v._annotation
if not isinstance(annotation, str):
continue
if not annotation in MATH_SPACES:
print(f&amp;quot;{annotation} is not implemented in Math Spaces&amp;quot;)
continue # skip if we didn't implement this space validation
if not MATH_SPACES[annotation][&amp;quot;validator&amp;quot;](_args[i]):
raise ValueError(f&amp;quot;{k} doesn't belong to the {MATH_SPACES[annotation]['name']}&amp;quot;)
result = func(*_args)
print(f&amp;quot;{func.__name__}({_args}) -&amp;gt; {result}&amp;quot;)
return result
return decorated
return decorate
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-python">@math_validator()
def simple_method(x: &amp;quot;\in R&amp;quot;, y: &amp;quot;\in R_+&amp;quot;, z: float = 2) -&amp;gt; float:
&amp;quot;&amp;quot;&amp;quot;Simple method to add two numbers together and
divide by the last number
Args:
x: The first number to add.
y: The second number to add.
z: it is a float number that will be the power of the result.
This will not be checked for math spaces.
Returns:
float: result
&amp;quot;&amp;quot;&amp;quot;
result = (x+y)/y
return result**z
simple_method(1, 2)
simple_method(1, 0)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>simple_method((1, 2)) -&amp;gt; 1.5
---&amp;gt; 19 simple_method(1, 0)
...
&amp;lt;locals&amp;gt;.decorate.&amp;lt;locals&amp;gt;.decorated(*_args)
11 continue
13 if not MATH_SPACES[annotation][&amp;quot;validator&amp;quot;](_args[i]):
---&amp;gt; 14 raise ValueError(f&amp;quot;{k} doesn't belong to the {MATH_SPACES[annotation]['name']}&amp;quot;)
15 result = func(*_args)
16 print(f&amp;quot;{func.__name__}({_args}) -&amp;gt; {result}&amp;quot;)
ValueError: y doesn't belong to the space of real numbers greater than zero
&lt;/code>&lt;/pre>
&lt;p>Our decorator is quite simple but does the job. You can go deeper into this and use a more sophisticated mathematical notation, printing using latex, etc. But now, let&amp;rsquo;s go back to the Python Fluent example because the &lt;code>inspect.signature&lt;/code> already provides us with a way to solve the first limitation!&lt;/p>
&lt;h3 id="going-back-to-the-fluent-python-example">Going back to the Fluent python example&lt;/h3>
&lt;p>Let&amp;rsquo;s remember one thing that I&amp;rsquo;ve pointed out:&lt;/p>
&lt;blockquote>
&lt;p>A person who is not familiar with the code base will not be able to understand what is happening just by analyzing the outputs of the decorator.&lt;/p>
&lt;/blockquote>
&lt;p>It&amp;rsquo;s obvious that we can overcome this issue by using the &lt;code>inspect&lt;/code> module. Let&amp;rsquo;s create a more elaborated example using monkeys and a zookeeper that must record and report the information about how the life of the monkeys are going.&lt;/p>
&lt;pre>&lt;code class="language-python">NUM_MONKEYS = 20
def feed_monkeys(n_bananas, n_apples=0):
monkeys = {
f&amp;quot;monkey_{i}&amp;quot;: {&amp;quot;bananas&amp;quot;: 0, &amp;quot;apples&amp;quot;: 0}
for i in range(NUM_MONKEYS)
}
while n_bananas &amp;gt; 0 and n_apples &amp;gt; 0:
if np.random.uniform() &amp;lt; 0.4:
continue
monkey = monkey[np.random.choice(list(monkeys.keys()))]
if n_bananas &amp;gt; 0:
monkey[&amp;quot;bananas&amp;quot;] += 1
n_bananas -= 1
if n_apples &amp;gt; 0:
monkey[&amp;quot;apples&amp;quot;] += 1
n_apples -= 1
if n_apples == 0 and n_bananas == 0:
break
&lt;/code>&lt;/pre>
&lt;p>My solution is the &lt;code>@report&lt;/code> decorator presented below.&lt;/p>
&lt;pre>&lt;code class="language-python">def report(fmt=DEFAULT_FMT):
def decorate(func):
def decorated(*_args):
sig = inspect.signature(func)
named_args = {}
num_args = len(_args)
for i, (k, v) in enumerate(sig.parameters.items()):
if i &amp;lt; num_args:
named_args[k] = repr(_args[i])
else:
named_args[k] = repr(v.default)
t0 = time.time()
_result = func(*_args)
elapsed = time.time() - t0
name = func.__name__
result = repr(_result)
args_dict = {
**locals(),
**named_args}
del args_dict['_args']
print(fmt.format(**args_dict))
# store the information in some place
return result
return decorated
return decorate
&lt;/code>&lt;/pre>
&lt;p>What is important here are the following statements:&lt;/p>
&lt;pre>&lt;code class="language-python">sig = inspect.signature(func)
named_args = {}
num_args = len(_args)
for i, (k, v) in enumerate(sig.parameters.items()):
if i &amp;lt; num_args:
named_args[k] = repr(_args[i])
else:
named_args[k] = repr(v.default)
&lt;/code>&lt;/pre>
&lt;p>We are iterating over the signature parameters and checking if it passed the value to &lt;code>func&lt;/code>. If not, we extract the default value from the signature.&lt;/p>
&lt;p>Using the &lt;code>@report&lt;/code> decorator in the &lt;code>feed_monkeys&lt;/code> we have this output:&lt;/p>
&lt;pre>&lt;code class="language-python">NUM_MONKEYS = 20
@report('The zookeeper feeds the monkeys with {n_bananas} bananas and {n_apples} apples. Time to feed: {elapsed:0.4f}s')
def feed_monkeys(n_bananas, n_apples=0):
monkeys = {
f&amp;quot;monkey_{i}&amp;quot;: {&amp;quot;bananas&amp;quot;: 0, &amp;quot;apples&amp;quot;: 0}
for i in range(NUM_MONKEYS)
}
while n_bananas &amp;gt; 0 and n_apples &amp;gt; 0:
if np.random.uniform() &amp;lt; 0.4:
continue
monkey = monkeys[np.random.choice(list(monkeys.keys()))]
if n_bananas &amp;gt; 0:
monkey[&amp;quot;bananas&amp;quot;] += 1
n_bananas -= 1
if n_apples &amp;gt; 0:
monkey[&amp;quot;apples&amp;quot;] += 1
n_apples -= 1
if n_apples == 0 and n_bananas == 0:
break
for _ in range(3):
feed_monkeys(np.random.randint(10, 100))
feed_monkeys(np.random.randint(10, 100), 10)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>The zookeeper feeds the monkeys with 69 bananas and 0 apples. Time to feed: 0.0000s
The zookeeper feeds the monkeys with 92 bananas and 10 apples. Time to feed: 0.0011s
The zookeeper feeds the monkeys with 58 bananas and 0 apples. Time to feed: 0.0000s
The zookeeper feeds the monkeys with 53 bananas and 10 apples. Time to feed: 0.0048s
The zookeeper feeds the monkeys with 42 bananas and 0 apples. Time to feed: 0.0000s
The zookeeper feeds the monkeys with 51 bananas and 10 apples. Time to feed: 0.0025s
&lt;/code>&lt;/pre>
&lt;p>First issue solved! But our decorator is still not useful to the zookeeper and managers. We can‚Äôt know how good any monkey is doing or if there is any monkey that eats too much. You could already know that somehow we must have a way to access the monkeys' dictionary inside our &lt;code>def decorated&lt;/code> method. Unfortunately, this is not a trivial task in python because it lacks namespaces decorators. But we also can overcome this with a little trick using a trace tool.&lt;/p>
&lt;h2 id="how-to-expose-the-locals-inside-of-a-decorator">How to expose the locals() inside of a decorator?&lt;/h2>
&lt;p>Now we just need to access the local variables of the decorated method. Let&amp;rsquo;s think more deeply about this:&lt;/p>
&lt;ul>
&lt;li>After the execution of the decorated method, all the information about the local variables is lost. Fortunately, we don&amp;rsquo;t want irrelevant information occupying our system memory.&lt;/li>
&lt;li>The decorator will call the decorated method and will receive the return value. Thus, &lt;strong>there is no way to extract the local variables because now there are no more local variables!&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>How to solve it? Well, think first about where the local variables have been stored before being erased.&lt;/p>
&lt;h3 id="call-stack-and-frames-in-python">Call stack and frames in python&lt;/h3>
&lt;p>If you came from a non-CS background, maybe you don&amp;rsquo;t know about an important concept called the
&lt;a href="https://en.wikipedia.org/wiki/Call_stack" target="_blank" rel="noopener">&lt;strong>call stack&lt;/strong>&lt;/a>. A call stack is a data structure that stores information related to living things in our program.&lt;/p>
&lt;p>If you call a function in python, a new block of information (&lt;strong>frame&lt;/strong>) is pushed to the top of the call stack. After the function returns the value, this block of information is popped off the call stack. This comprehension can give insights into how to do things in python and how to create good or strange behaviors.&lt;/p>
&lt;p>Well, you can think. If the elements of the call stack are always added on the top if a function (inner) is called by another function (outer) &lt;strong>can I access the values of the local variables from the outer function inside of the inner? Yes, you can!&lt;/strong> Obviously, this is not always a good idea, but it&amp;rsquo;s good to understand this concept. Because this approach can be useful to deal with rigid frameworks like Django.&lt;/p>
&lt;pre>&lt;code class="language-python">%%writefile test_stack.py
import inspect
N_BANANAS = 12
def outer_call(n_bananas):
var_inside_outer_call = 2
n_bananas += 1
inner_call(n_bananas)
def inner_call(n_bananas):
var_inside_inner_call = {&amp;quot;monkey&amp;quot;: 0}
frame_infos = inspect.stack()
n_frames = len(frame_infos)
frames_var_values = {
f.function: [(k, v) for k, v in f.frame.f_locals.items()] for f in frame_infos
}
for i, (function, frame_local) in enumerate(frames_var_values.items()):
print(f'\n\t {function} stack position: {n_frames - i}')
for var_name, value in frame_local:
print(f'\t\t Name: {var_name:25s}Type: {type(value)}')
if var_name in ('n_bananas', 'N_BANANAS', 'var_inside_outer_call'):
print(f'\t\t\t Value: {value}')
print(&amp;quot;\n Before outer_call() call&amp;quot;)
outer_call(N_BANANAS)
print(&amp;quot;\n After outer_call() call&amp;quot;)
frames = [
[(k, v) for k, v in f.frame.f_locals.items()]
for f in inspect.stack()
]
for frame_local in frames:
for var_name, value in frame_local:
print(f'\t\t Name: {var_name:25s}Type: {type(value)}')
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>Overwriting test_stack.py
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-python">!python test_stack.py
&lt;/code>&lt;/pre>
&lt;pre>&lt;code> Before outer_call() call
inner_call stack position: 3
Name: n_bananas Type: &amp;lt;class 'int'&amp;gt;
Value: 13
Name: var_inside_inner_call Type: &amp;lt;class 'dict'&amp;gt;
Name: frame_infos Type: &amp;lt;class 'list'&amp;gt;
Name: n_frames Type: &amp;lt;class 'int'&amp;gt;
outer_call stack position: 2
Name: n_bananas Type: &amp;lt;class 'int'&amp;gt;
Value: 13
Name: var_inside_outer_call Type: &amp;lt;class 'int'&amp;gt;
Value: 2
&amp;lt;module&amp;gt; stack position: 1
Name: __name__ Type: &amp;lt;class 'str'&amp;gt;
Name: __doc__ Type: &amp;lt;class 'NoneType'&amp;gt;
Name: __package__ Type: &amp;lt;class 'NoneType'&amp;gt;
Name: __loader__ Type: &amp;lt;class '_frozen_importlib_external.SourceFileLoader'&amp;gt;
Name: __spec__ Type: &amp;lt;class 'NoneType'&amp;gt;
Name: __annotations__ Type: &amp;lt;class 'dict'&amp;gt;
Name: __builtins__ Type: &amp;lt;class 'module'&amp;gt;
Name: __file__ Type: &amp;lt;class 'str'&amp;gt;
Name: __cached__ Type: &amp;lt;class 'NoneType'&amp;gt;
Name: inspect Type: &amp;lt;class 'module'&amp;gt;
Name: N_BANANAS Type: &amp;lt;class 'int'&amp;gt;
Value: 12
Name: outer_call Type: &amp;lt;class 'function'&amp;gt;
Name: inner_call Type: &amp;lt;class 'function'&amp;gt;
After outer_call() call
Name: __name__ Type: &amp;lt;class 'str'&amp;gt;
Name: __doc__ Type: &amp;lt;class 'NoneType'&amp;gt;
Name: __package__ Type: &amp;lt;class 'NoneType'&amp;gt;
Name: __loader__ Type: &amp;lt;class '_frozen_importlib_external.SourceFileLoader'&amp;gt;
Name: __spec__ Type: &amp;lt;class 'NoneType'&amp;gt;
Name: __annotations__ Type: &amp;lt;class 'dict'&amp;gt;
Name: __builtins__ Type: &amp;lt;class 'module'&amp;gt;
Name: __file__ Type: &amp;lt;class 'str'&amp;gt;
Name: __cached__ Type: &amp;lt;class 'NoneType'&amp;gt;
Name: inspect Type: &amp;lt;class 'module'&amp;gt;
Name: N_BANANAS Type: &amp;lt;class 'int'&amp;gt;
Name: outer_call Type: &amp;lt;class 'function'&amp;gt;
Name: inner_call Type: &amp;lt;class 'function'&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>First, draw your attention here&lt;/p>
&lt;pre>&lt;code>outer_call stack position: 2
Name: n_bananas Type: &amp;lt;class 'int'&amp;gt;
Value: 13
Name: var_inside_outer_call Type: &amp;lt;class 'int'&amp;gt;
Value: 2
&lt;/code>&lt;/pre>
&lt;p>&lt;strong>Even if we don&amp;rsquo;t pass a variable as an argument to the &lt;code>inner_call&lt;/code> function, this variable can be accessed because still lives in the call stack!&lt;/strong> As I‚Äôve told you, after the execution of &lt;code>outer_call&lt;/code> the call stack doesn&amp;rsquo;t have any information about what happened inside our functions. This discussion will help us to understand the limitations of our solution. Because &lt;strong>our solution is just to watch the call stack and keep the frame before being popped off!&lt;/strong>&lt;/p>
&lt;h3 id="using-systrace-to-track-our-frames">Using sys.trace to track our frames&lt;/h3>
&lt;p>Some time ago I&amp;rsquo;ve talked about how to dissect a process using &lt;code>lsof&lt;/code> and &lt;code>strace&lt;/code>:
&lt;a href="https://medium.com/@devmessias/dissecting-process-and-failures-in-linux-with-lsof-and-strace-cases-for-mlops-d7755b2ce6ca" target="_blank" rel="noopener">Dissecting processes and failures in Linux with lsof and strace&lt;/a>. The &lt;code>strace&lt;/code> is a tracing tool that intercepts and records in someplace any system call made by a process. Python has a built-in tool to do this kind of stuff. Thus, let&amp;rsquo;s use it to track our frames.&lt;/p>
&lt;h3 id="lets-solve-our-problem">Let&amp;rsquo;s solve our problem&lt;/h3>
&lt;p>We will ask our code to monitor any call made with the decorated function. To do so, we will create a new function that will do this and release the trace after the execution of the decorated function.&lt;/p>
&lt;pre>&lt;code class="language-python">import sys
def call_and_extract_frame(func, *args, **kwargs):
frame_var = None
trace = sys.gettrace()
def update_frame_var(stack_frame, event_name, arg_frame):
&amp;quot;&amp;quot;&amp;quot;
Args:
stack_frame: (frame)
The current stack frame.
event_name: (str)
The name of the event that triggered the call.
Can be 'call', 'line', 'return' and 'exception'.
arg_frame:
Depends on the event. Can be a None type
&amp;quot;&amp;quot;&amp;quot;
nonlocal frame_var # nonlocal is a keyword which allows us to change the variable in the outer scope
if event_name != 'call':
return trace
frame_var = stack_frame
sys.settrace(trace)
return trace
sys.settrace(update_frame_var)
try:
func_result = func(*args, **kwargs)
finally:
sys.settrace(trace)
return frame_var, func_result
&lt;/code>&lt;/pre>
&lt;p>Now to use this trick, we just need to call the above function in our &lt;code>@report&lt;/code> decorator. Like this:&lt;/p>
&lt;pre>&lt;code class="language-python">def report(formater):
def decorate(func):
def decorated(*_args):
sig = inspect.signature(func)
named_args = {}
num_args = len(_args)
for i, (k, v) in enumerate(sig.parameters.items()):
if i &amp;lt; num_args:
named_args[k] = repr(_args[i])
else:
named_args[k] = repr(v.default)
### Our modifications
frame_func, _result = call_and_extract_frame(func, *_args)
name = func.__name__
result = repr(_result)
args_dict = {
**named_args,
**locals(),
**frame_func.f_locals,
}
###
print(formater.format(**args_dict))
# do other stuff here
return _result
return decorated
return decorate
&lt;/code>&lt;/pre>
&lt;p>Let&amp;rsquo;s see the results:&lt;/p>
&lt;pre>&lt;code class="language-python">@report(' Monkey {gluttonous_monkey} ate too much bananas. Num monkeys {num_monkeys}')
def feed_monkeys(n_bananas):
num_monkeys = 3
monkeys = {
f&amp;quot;monkey_{i}&amp;quot;: {&amp;quot;bananas&amp;quot;: 0}
for i in range(num_monkeys)
}
while n_bananas &amp;gt; 0:
if np.random.uniform() &amp;lt; 0.4:
continue
monkey = monkeys[np.random.choice(list(monkeys.keys()))]
if n_bananas &amp;gt; 0:
monkey[&amp;quot;bananas&amp;quot;] += 1
n_bananas -= 1
gluttonous_monkey = max(monkeys, key=lambda k: monkeys[k][&amp;quot;bananas&amp;quot;])
for _ in range(3):
feed_monkeys(np.random.randint(10, 100))
&lt;/code>&lt;/pre>
&lt;pre>&lt;code> The monkey monkey_0 eat too much bananas. Num monkeys 3
The monkey monkey_1 eat too much bananas. Num monkeys 3
The monkey monkey_2 eat too much bananas. Num monkeys 3
&lt;/code>&lt;/pre>
&lt;h2 id="conclusion-and-next-steps">Conclusion and next steps&lt;/h2>
&lt;h3 id="it-depends">&amp;ldquo;&amp;hellip;it depends&amp;rdquo;&lt;/h3>
&lt;p>Nice! It worked. But should you use it?&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="/pt-br/post/python_decorator_that_exposes_locals/depends_hue4832d1f9bd8c3212ee44b9859787ce4_80720_0x400_resize_q90_lanczos.jpg" >
&lt;img src="/pt-br/post/python_decorator_that_exposes_locals/depends_hue4832d1f9bd8c3212ee44b9859787ce4_80720_0x400_resize_q90_lanczos.jpg" alt="" height="400px">
&lt;/a>
&lt;/figure>
&lt;ul>
&lt;li>We have drawbacks in our approach:
&lt;ul>
&lt;li>a tracing always creates a cost. Thus, is expected that we will reduce the performance of our system. If you use this just for debugging purposes, it&amp;rsquo;s ok.&lt;/li>
&lt;li>can have conflicts with other tools and libs that also trying to use the trace tool&lt;/li>
&lt;li>it seems dirty!&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="the-next-step-we-dont-need-a-trace-we-can-do-better-using-ast-manipulation">The next step: we don&amp;rsquo;t need a trace! We can do better using AST manipulation&lt;/h3>
&lt;ul>
&lt;li>Using the inspect module to get the argument names it&amp;rsquo;s ok but I&amp;rsquo;ve told you the trace tool can be problematic. But we can replace the trace with another approach. Although, it&amp;rsquo;s more conceptually complex don&amp;rsquo;t require dirty tricks and I believe it&amp;rsquo;s far more beautiful. &lt;strong>The next post it&amp;rsquo;s about this!&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="simplenamespace-for-dictkey-instead-of-dictkey">SimpleNamespace for dict.key instead of dict[&amp;ldquo;key]&lt;/h3>
&lt;p>We have a minor issue and point of improvement. If you&amp;rsquo;re an cautious developer, probably you notice a flaw here&lt;/p>
&lt;pre>&lt;code class="language-python">args_dict = {
**named_args,
**locals(),
**frame_func.f_locals,
}
&lt;/code>&lt;/pre>
&lt;p>if any of the dicts have common keys, one of them will overwrite the other. This is not what we want. You can use a simple solution like this:&lt;/p>
&lt;pre>&lt;code class="language-python">args_dict = {
&amp;quot;args&amp;quot;: **named_args,
**locals(),
&amp;quot;func_locals&amp;quot;: **frame_func.f_locals,
}
&lt;/code>&lt;/pre>
&lt;p>But this is still annoying because we can do this with a format string:&lt;/p>
&lt;pre>&lt;code>@report(fmt=&amp;quot;{args['n_bananas']} ...&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>Well, how to solve it? Just use a SimpleNamespace to construct an object!&lt;/p>
&lt;pre>&lt;code class="language-python">from types import SimpleNamespace
def report(formater):
def decorate(func):
def decorated(*_args):
sig = inspect.signature(func)
named_args = {}
num_args = len(_args)
for i, (k, v) in enumerate(sig.parameters.items()):
if i &amp;lt; num_args:
named_args[k] = repr(_args[i])
else:
named_args[k] = repr(v.default)
### Our modifications
frame_func, _result = call_and_extract_frame(func, *_args)
name = func.__name__
result = repr(_result)
args_dict = {
&amp;quot;args&amp;quot;: SimpleNamespace(**named_args),
&amp;quot;args_repr&amp;quot;: repr(SimpleNamespace(**named_args)),
**locals(),
**frame_func.f_locals,
}
###
print(formater.format(**args_dict))
# do other stuff here
return _result
return decorated
return decorate
@report(
&amp;quot;&amp;quot;.join((
'The zookeeper feeds the monkeys with {args.n_bananas},',
'bananas. We loost {n_bananas} bananas. Args {args_repr}'
))
)
def feed_monkeys(n_bananas):
num_monkeys = 3
monkeys = {
f&amp;quot;monkey_{i}&amp;quot;: {&amp;quot;bananas&amp;quot;: 0}
for i in range(num_monkeys)
}
while n_bananas &amp;gt; 0:
if np.random.uniform() &amp;gt; .8:
# &amp;quot;bananas rotted . Monkeys will not eat any banana any more&amp;quot;)
break
if np.random.uniform() &amp;lt; 0.4:
continue
monkey = monkeys[np.random.choice(list(monkeys.keys()))]
if n_bananas &amp;gt; 0:
monkey[&amp;quot;bananas&amp;quot;] += 1
n_bananas -= 1
gluttonous_monkey = max(monkeys, key=lambda k: monkeys[k][&amp;quot;bananas&amp;quot;])
for _ in range(3):
feed_monkeys(np.random.randint(10, 100))
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>The zookeeper feeds the monkeys with 15,bananas. We loost 15 bananas. Args namespace(n_bananas='15')
The zookeeper feeds the monkeys with 80,bananas. We loost 77 bananas. Args namespace(n_bananas='80')
The zookeeper feeds the monkeys with 95,bananas. We loost 92 bananas. Args namespace(n_bananas='95')
&lt;/code>&lt;/pre>
&lt;h3 id="want-to-know-more-about-call-stack--inspect-and-trace">Want to know more about call stack , inspect and trace?&lt;/h3>
&lt;ul>
&lt;li>Call stack and frames:
&lt;a href="https://www.linkedin.com/in/reza-bagheri-71882a76/" target="_blank" rel="noopener">Reza Bagheri&lt;/a> explained
&lt;a href="https://reza-bagheri79.medium.com/python-stack-frames-and-tail-call-optimization-4d0ea55b0542" target="_blank" rel="noopener">here&lt;/a> how to add a tail-call optimization in python using python stack frames.&lt;/li>
&lt;li>Fluent Python book by Luciano Ramalho&lt;/li>
&lt;li>Python documentation:
&lt;a href="https://docs.python.org/3/library/traceback.html" target="_blank" rel="noopener">tracebak&lt;/a>,
&lt;a href="https://docs.python.org/3/library/inspect.html" target="_blank" rel="noopener">inspect and stack&lt;/a>.&lt;/li>
&lt;li>
&lt;a href="https://stackoverflow.com/questions/4214936/how-can-i-get-the-values-of-the-locals-of-a-function-after-it-has-been-executed/4249347#4249347" target="_blank" rel="noopener">Stackoverflow discussion&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Dissecando processos e erros no Linux com o lsof e strace: casos para DevOps/MlOps</title><link>/pt-br/post/investigando_processos_e_bugs_strace_lsof_no_linux/</link><pubDate>Fri, 04 Feb 2022 08:31:00 -0300</pubDate><guid>/pt-br/post/investigando_processos_e_bugs_strace_lsof_no_linux/</guid><description>&lt;details
class="toc-inpage d-print-none d-none d-sm-block d-md-none " open>
&lt;summary class="font-weight-bold">Lista de Conte√∫dos&lt;/summary>
&lt;nav id="TableOfContents">
&lt;ul>
&lt;li>&lt;a href="#conceitos">Conceitos&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#everything-is-a-file-mantra-unix">‚ÄúEverything is a file.‚Äù mantra UNIX&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#lsof">LSOF&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#system-calls-e-strace">System Calls e strace&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#investigando-problemas">Investigando problemas&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#identificando-problemas-de-conex√£o">Identificando problemas de conex√£o&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#o-meu-servi√ßo-est√°-on">O meu servi√ßo est√° on?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#o-pip-ou-um-cliente-qualquer-est√°-engasgado-esperando-uma-resposta-de-algu√©m">O pip ou um cliente qualquer est√° engasgado esperando uma resposta de algu√©m?&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#problemas-com-arquivos">Problemas com arquivos&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#quais-processos-est√£o-usando-esse-arquivo">Quais processos est√£o usando esse arquivo?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#deletei-o-csv-e-agora">Deletei o csv e agora?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#erros-silenciosos-arquivo-n√£o-existente-ou-permiss√£o">Erros silenciosos: arquivo n√£o existente ou permiss√£o&lt;/a>&lt;/li>
&lt;li>&lt;a href="#esse-processo-est√°-salvando-algo-que-n√£o-deveria-onde">Esse processo est√° salvando algo que n√£o deveria? Onde?&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#extras-envolvendo-arquivos-proc-e-strace">Extras envolvendo arquivos (&lt;code>/proc/&lt;/code>) e &lt;code>strace&lt;/code>&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#gerando-um-sum√°rio-de-sys-call">Gerando um sum√°rio de SYS CALL&lt;/a>&lt;/li>
&lt;li>&lt;a href="#o-processo-foi-iniciado-com-as-vari√°veis-de-ambiente-corretas">O processo foi iniciado com as vari√°veis de ambiente corretas?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#esqueci-de--redirecionar-os-outputs-do-processo-para-um-arquivo--o-que-fazer">Esqueci de redirecionar os outputs do processo para um arquivo. O que fazer?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#qual-comando-gerou-o-processo-e-onde-√©-o-seu-working-dir">Qual comando gerou o processo e onde √© o seu working dir?&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#agradecimentos--sugest√µes">Agradecimentos &amp;amp; Sugest√µes&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/nav>
&lt;/details>
&lt;p>Linux n√£o √© um SO opaco. Ele n√£o ser opaco significa que √© f√°cil ver o que acontece por tr√°s dos processos. O que permite identificar um problema ou pelo menos saber se voc√™ realmente tem um problema.&lt;/p>
&lt;p>Iniciei meu aprendizado em MlOps (&lt;em>Machine Learning Operations&lt;/em>). Embora tenha pouca experi√™ncia foi f√°cil aceitar que MlOps envolve um workflow extremamente intricado com muitos poss√≠veis pontos de falhas. Tais pontos podem n√£o estar relacionados com os operadores. Portanto, saber identificar se existe uma falha e o que est√° causando ela √© de suma import√¢ncia. Isso vai desde compreender o comportamento de um processo criado pelos pr√≥prios operadores ou o que o &lt;code>pip/conda&lt;/code> e demais depend√™ncias externas est√£o aprontando debaixo dos panos.&lt;/p>
&lt;p>O primeiro passo para entender um problema com um processo √© analisar o output (a sa√≠da na sess√£o do seu terminal). Contudo, algumas vezes isso n√£o te fornece a informa√ß√£o suficiente. Neste texto vou discorrer do b√°sico sobre como debugar processos usando o &lt;code>strace&lt;/code> e &lt;code>lsof&lt;/code>. Iremos criar alguns exemplos patol√≥gicos usando python para simular problemas que podemos encontrar e como eles s√£o dissecados pelo &lt;code>strace&lt;/code> e o &lt;code>lsof&lt;/code>.&lt;/p>
&lt;h1 id="conceitos">Conceitos&lt;/h1>
&lt;h2 id="everything-is-a-file-mantra-unix">‚ÄúEverything is a file.‚Äù mantra UNIX&lt;/h2>
&lt;p>&lt;img src="everthing_is_a_file.png" alt="everthing_is_a_file">&lt;/p>
&lt;p>Quando voc√™ pensa em arquivo voc√™ talvez relacione com um &lt;em>CSV&lt;/em>, uma planilha ou imagem. Mas na abordagem UNIX de fazer SO o conceito de arquivo aparece em todos os lugares. Por exemplo, at√© conex√µes de rede s√£o associadas a um arquivo. Em casos que um elemento em si n√£o √© um arquivo tal elemento tem a ele associado um descritor de arquivo (&lt;em>file descriptor&lt;/em>). Como isso se relaciona com debugar processos? **Se tudo √© um arquivo analisar um processo pode ser feito com o mesmo conjunto de ferramentas e conceitos que usamos para listar, compreender e comunicar com arquivo inclusive com a mesma API. ** Aqui abordaremos uma ferramenta para listagem de arquivos, o &lt;code>lsof&lt;/code>.&lt;/p>
&lt;h3 id="lsof">LSOF&lt;/h3>
&lt;p>A ferramenta &lt;strong>lsof&lt;/strong> √© um comando que pode ser usado para listar os &lt;em>file descriptors&lt;/em> abertos e os processos que foram respons√°veis por tal a√ß√£o. Desta maneira voc√™ pode listar os file descriptors de um usu√°rio que est√£o associados a uma porta via conex√£o ou processo. O nome desse comando √© um acr√¥nimo para &lt;strong>l&lt;/strong>ist &lt;strong>o&lt;/strong>pen &lt;strong>f&lt;/strong>iles.&lt;/p>
&lt;p>O exemplo mais simples de uso jogando os resultados para um arquivo √© esse&lt;/p>
&lt;pre>&lt;code class="language-bash">meuusuario:/$ lsof &amp;gt; lsof_tudo.txt
&lt;/code>&lt;/pre>
&lt;p>O comando acima ir√° criar uma tabela (imensa) dentro de &lt;code>lsof_tudo.txt&lt;/code>&lt;/p>
&lt;p>Essa tabela ser√° mais ou menos assim&lt;/p>
&lt;pre>&lt;code class="language-bash">COMMAND PID TID TASKCMD USER FD TYPE DEVICE SIZE/OFF NODE NAME
systemd 1 root cwd unknown /proc/1/cwd (readlink: Permission denied)
systemd 1 root rtd unknown /proc/1/root (readlink: Permission denied)
systemd 1 root txt unknown /proc/1/exe (readlink: Permission denied)
&lt;/code>&lt;/pre>
&lt;p>Se voc√™ olhar com cuidado ver√° que aparecem linhas de diferentes usu√°rios. As primeiras s√£o do &lt;code>root&lt;/code> e uma das colunas mostra que voc√™ n√£o tem permiss√£o para ler os &lt;em>file descriptors&lt;/em> desse usu√°rio, ainda bem! Para pedir apenas a listagem do seu usu√°rio fa√ßa&lt;/p>
&lt;pre>&lt;code class="language-bash">meuusuario:/$ lsof -u meuusuario &amp;gt; lsof_meu.txt
&lt;/code>&lt;/pre>
&lt;p>O arquivo ainda √© enorme, mas abra ele com seu editor de texto. Tente procurar nomes de arquivos e processos que voc√™ esta usando agora.&lt;/p>
&lt;p>Temos muitas colunas no output, voc√™ pode ver o significado detalhado de cada uma digitando &lt;code>man lsof&lt;/code> . Mas eu acho mais interessante voc√™ focar nas seguintes colunas:&lt;/p>
&lt;ul>
&lt;li>COMAND
&lt;ul>
&lt;li>O nome do comando associado ao processo que abriu o arquivo&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>PID
&lt;ul>
&lt;li>Um n√∫mero que identifica unicamente o processo. Voc√™ pode usar esse n√∫mero para matar o processo usando &lt;code>pkill&lt;/code>, usar ele no &lt;code>strace&lt;/code> etc.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>TID
&lt;ul>
&lt;li>Se o arquivo foi aberto por uma thread de um processo. Quando n√£o tem nada nessa coluna significa que a a√ß√£o foi feita por um processo.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>USER
&lt;ul>
&lt;li>O usu√°rio respons√°vel pelo processo que efetuou a a√ß√£o.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>TYPE
&lt;ul>
&lt;li>Essa coluna √© bem √∫til. Tal coluna te diz o tipo de n√≥ associado ao arquivo. Por exemplo, se o arquivo for associado com protocolos voc√™ vera aqui coisas do tipo: &lt;strong>IPV4, IPV6&lt;/strong>. Se for um arquivo normal haver√° na coluna o identificador **REG. **Existem algumas dezenas de possibilidades de valores para essa coluna, eu nunca lembro o que elas significam, mas √© f√°cil consultar online ou no &lt;code>man&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>NODE
&lt;ul>
&lt;li>O identificador do n√≥ do arquivo. No caso desse arquivo envolver protocolos de internet haver√° coisas como &lt;strong>TCP, UDP&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>NAME
&lt;ul>
&lt;li>Tamb√©m bastante √∫til. Ele muda bastante dependendo do que o arquivo se refere. Pode ser o endere√ßo do servidor (&lt;a href="http://www.google.com">www.google.com&lt;/a>, localhost:5000) assim como o endere√ßo do arquivo.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>O &lt;code>lsof&lt;/code> tem muitos argumentos poss√≠veis, veremos alguns utilizando alguns casos que eu acho interessante e que acontecem.&lt;/p>
&lt;h2 id="system-calls-e-strace">System Calls e strace&lt;/h2>
&lt;p>O system call √© o mecanismo de comunica√ß√£o entre processos e o kernel do seu SO.
Tal mecanismo permite que um processo requisite recursos do kernel disponibilizados pelo seu hardware. Para ler um arquivo armazenado em seu hardwre √© necess√°rio que ocorra antes um system call. Portanto, tendo uma maneira de interceptar essas chamadas entre um processo e o kernel temos como compreender o que tal processo est√° fazendo. Um comando que permite essa intercepta√ß√£o √© o &lt;code>strace&lt;/code>.&lt;/p>
&lt;pre>&lt;code class="language-bash">$ man strace
&lt;/code>&lt;/pre>
&lt;p>Se o strace n√£o estiver dispon√≠vel instale&lt;/p>
&lt;pre>&lt;code class="language-bash">$ apt install strace
&lt;/code>&lt;/pre>
&lt;p>O &lt;code>strace&lt;/code> pode ser executado de duas formas. A primeira √©
usando o comando a ser interceptado como argumento do strace&lt;/p>
&lt;pre>&lt;code class="language-bash">$ strace ARGS COMANDO_A_SER_INTERCEPTADO
&lt;/code>&lt;/pre>
&lt;p>a segunda, bastante √∫til, √© interceptando um processo j√° iniciado usando
o PID de tal processo,&lt;/p>
&lt;pre>&lt;code class="language-bash">$ strace ARGS -p PID_DO_PROCESSO
&lt;/code>&lt;/pre>
&lt;p>Para descobrir o PID de um processo use o &lt;code>htop&lt;/code> ou o seguinte comando &lt;code>ps aux | grep -i '[n]ome_do_processo'&lt;/code>.&lt;/p>
&lt;p>Veja um exemplo simples do strace e seu output&lt;/p>
&lt;pre>&lt;code class="language-bash">$ strace -t ls
&lt;/code>&lt;/pre>
&lt;p>O resultado ser√° algo do tipo&lt;/p>
&lt;pre>&lt;code>18:02:23 execve(&amp;quot;/usr/bin/ls&amp;quot;, [&amp;quot;ls&amp;quot;], 0x7fffa727a418 /* 54 vars */) = 0
18:02:23 brk(NULL) = 0x55ebef60c000
18:02:23 access(&amp;quot;/etc/ld.so.preload&amp;quot;, R_OK) = -1 ENOENT (No such file or directory)
18:02:23 openat(AT_FDCWD, &amp;quot;/etc/ld.so.cache&amp;quot;, O_RDONLY|O_CLOEXEC) = 3
...
&lt;/code>&lt;/pre>
&lt;p>Cada linha representa uma system call e o seu respectivo resultado. O argumento &lt;code>-t&lt;/code> diz para imprimir na primeira coluna o instante de tempo que o system call foi chamado.&lt;/p>
&lt;p>De forma resumida o formato das linhas segue o padr√£o:&lt;/p>
&lt;p>&lt;strong>Nome da SYS CALL(Argumentos usados na SYS CALL) = O resultado&lt;/strong>&lt;/p>
&lt;p>O output √© dif√≠cil se n√£o humanamente imposs√≠vel de compreender tudo sem um guia externo. Um guia poss√≠vel √© o comando &lt;code>man&lt;/code>. O comando abaixo mostra a documenta√ß√£o do sys call &lt;code>openat&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-bash">$ man 2 openat
&lt;/code>&lt;/pre>
&lt;p>O &lt;code>openat&lt;/code> √© o sys call que requisita a abertura de um arquivo, o resultado na √∫ltima linha (&lt;code> O_RDONLY|O_CLOEXEC) = 3&lt;/code>) significa que a chamada do sistema foi bem sucedida. Caso fosse &lt;strong>-1&lt;/strong> alguma coisa teria dado errado quando o processo requisitou o recurso.&lt;/p>
&lt;h1 id="investigando-problemas">Investigando problemas&lt;/h1>
&lt;p>Veremos aqui problemas e falhas relacionados a arquivos regulares e conex√µes de rede. Contudo podemos usar as mesmas tecnicas para outros tipos de problemas.&lt;/p>
&lt;h2 id="identificando-problemas-de-conex√£o">Identificando problemas de conex√£o&lt;/h2>
&lt;p>O conda est√° travado? O pip t√° baixando os pacotes do servidor ou existe algum servidor engasgando? Para onde minhas requisi√ß√µes est√£o indo? Antes de tentar iniciar um modo verboso e ter que matar seu processo voc√™ pode usar o lsof para responder essas perguntas. Para come√ßar nosso tutorial e realizar as simula√ß√µes instale o flask e requests&lt;/p>
&lt;pre>&lt;code class="language-bash">$ python -m pip install requests flask
&lt;/code>&lt;/pre>
&lt;p>Crie o arquivo &lt;code>server_mlops.py&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-python"># server_mlops.py
import time
import flask
app = flask.Flask(__name__)
@app.route('/')
def hello_world():
sleep_time = flask.request.args.get('sleep', default=10, type=int)
print('sleep_time:', sleep_time)
time.sleep(sleep_time)
return 'Hello World!'
if __name__ == '__main__':
app.run()
&lt;/code>&lt;/pre>
&lt;p>Inicie duas sess√µes no terminal. Na primeira inicie o servidor&lt;/p>
&lt;pre>&lt;code class="language-bash">$ python server_mlops.py
&lt;/code>&lt;/pre>
&lt;p>Na segunda execute&lt;/p>
&lt;pre>&lt;code class="language-bash">$ ps aux | grep -i '[s]erver_mlops.py'
&lt;/code>&lt;/pre>
&lt;p>voc√™ vera um output do tipo&lt;/p>
&lt;pre>&lt;code class="language-bash">devmess+ 19321 18.0 0.3 29716 24792 pts/5 S+ 14:27 0:00 python server_mlops.py
&lt;/code>&lt;/pre>
&lt;p>O n√∫mero na frente do seu username (19321) √© o &lt;code>PID&lt;/code> do processo.&lt;/p>
&lt;h3 id="o-meu-servi√ßo-est√°-on">O meu servi√ßo est√° on?&lt;/h3>
&lt;p>O argumento &lt;code>-a&lt;/code> pede que o &lt;code>lsof&lt;/code> use todos os argumentos de filtragem com o operador &lt;code>AND&lt;/code> isto √©, todas as condi√ß√µes devem ser v√°lidas. O argumento &lt;code>-i&lt;/code> pede para que ele filtre apenas arquivos associados a conex√µes e o argumento &lt;code>-p 19321&lt;/code> pede que use apena o processo com o &lt;code>PID 19321&lt;/code>.&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lsof -a -i -p 19321
&lt;/code>&lt;/pre>
&lt;p>Voc√™ vera um output mais ou menos assim&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>COMMAND&lt;/th>
&lt;th>PID&lt;/th>
&lt;th>USER&lt;/th>
&lt;th>FD&lt;/th>
&lt;th>TYPE&lt;/th>
&lt;th>DEVICE&lt;/th>
&lt;th>SIZE/OFF&lt;/th>
&lt;th>NODE&lt;/th>
&lt;th>NAME&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>python&lt;/td>
&lt;td>19321&lt;/td>
&lt;td>devmessias&lt;/td>
&lt;td>4u&lt;/td>
&lt;td>IPv4&lt;/td>
&lt;td>16108218&lt;/td>
&lt;td>0t0&lt;/td>
&lt;td>TCP&lt;/td>
&lt;td>localhost:5000 (LISTEN)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Est√° tudo ok com o seu servi√ßo. Tente remover um dos argumentos (remova o &lt;code>-a&lt;/code> por exemplo) ou usar eles isolados, veja como o output muda.&lt;/p>
&lt;h3 id="o-pip-ou-um-cliente-qualquer-est√°-engasgado-esperando-uma-resposta-de-algu√©m">O pip ou um cliente qualquer est√° engasgado esperando uma resposta de algu√©m?&lt;/h3>
&lt;p>Esse tipo de problema pode acontecer quando estamos gerenciando uma depend√™ncia, requisitando algum tipo de dado de um servidor e em in√∫meros outros casos em que n√£o temos acesso a m√°quina que executa o servi√ßo. Portanto, precisamos analisar do nosso lado se o processo est√° travado por alguma falha nossa.&lt;/p>
&lt;p>Crie o arquivo &lt;code>client_mlops.py&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-python">#!/usr/bin/env python
#client_mlops.py
import requests
import argparse
parser = argparse.ArgumentParser()
parser.add_argument(
'--sleep', type=int, help='time to sleep', default=0)
args = parser.parse_args()
print('Ask for localhost:5000 to sleep for {} seconds'.format(args.sleep))
r = requests.get('http://localhost:5000', params={'sleep': int(args.sleep)})
print(r.text)
&lt;/code>&lt;/pre>
&lt;p>No c√≥digo acima temos o argumento &lt;code>sleep&lt;/code> que pedira para o &lt;code>server_mlops.py&lt;/code> esperar alguns segundos antes de enviar a resposta.&lt;/p>
&lt;p>Simularemos um problema de um servidor pregui√ßoso. Pedindo que ele durma por 20 segundos. Se voc√™ matou o processo do servidor inicie ele novamente.&lt;/p>
&lt;p>Execute o &lt;code>client_mlops.py&lt;/code> com o &lt;code>strace&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-bash">$ strace -e poll,select,connect,recvfrom,sendto python client_mlops.py --sleep=20
&lt;/code>&lt;/pre>
&lt;p>aqui estamos pedindo para que o &lt;code>strace&lt;/code> nos mostre apenas chamadas do tipo &lt;code>poll,select,connect,recvfrom&lt;/code> e &lt;code>sendto&lt;/code>.&lt;/p>
&lt;p>O output ser√° algo do tipo&lt;/p>
&lt;pre>&lt;code>connect(4, {sa_family=AF_INET, sin_port=htons(5000), sin_addr=inet_addr(&amp;quot;127.0.0.1&amp;quot;)}, 16) = 0
connect(4, {sa_family=AF_INET6, sin6_port=htons(5000), inet_pton(AF_INET6, &amp;quot;::1&amp;quot;, &amp;amp;sin6_addr), sin6_flowinfo=htonl(0), sin6_scope_id=0}, 28) = 0
connect(4, {sa_family=AF_INET6, sin6_port=htons(5000), inet_pton(AF_INET6, &amp;quot;::1&amp;quot;, &amp;amp;sin6_addr), sin6_flowinfo=htonl(0), sin6_scope_id=0}, 28) = -1 ECONNREFUSED (Connection refused)
connect(4, {sa_family=AF_INET, sin_port=htons(5000), sin_addr=inet_addr(&amp;quot;127.0.0.1&amp;quot;)}, 16) = 0
sendto(4, &amp;quot;GET /?sleep=10 HTTP/1.1\r\nHost: l&amp;quot;..., 154, 0, NULL, 0) = 154
recvfrom(4,
&lt;/code>&lt;/pre>
&lt;p>Note que temos uma &lt;strong>SYS_CALL&lt;/strong> engasgada, &lt;code>recvfrom&lt;/code> (se voc√™ quiser obter mais informa√ß√µes sobre uma SYS_CALL digite &lt;code>man 2 recvfrom&lt;/code>) . Quem t√° engasagando √© o servidor e n√£o o cliente.&lt;/p>
&lt;p>Voc√™ pode tamb√©m usar o &lt;code>lsof&lt;/code> para checar se voc√™ est√° com esse tipo de problema. Para isso, execute o cliente em uma sess√£o separada&lt;/p>
&lt;pre>&lt;code class="language-bash">$ python client_mlops.py --sleep=100
&lt;/code>&lt;/pre>
&lt;p>pegue o PID com &lt;code>ps aux | grep -i '[c]lient_mlops.py'&lt;/code> e execute o &lt;code>lsof&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-bash">lsof -a -i -p 19321
&lt;/code>&lt;/pre>
&lt;p>O resultado ser√° algo do tipo&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>COMMAND&lt;/th>
&lt;th>PID&lt;/th>
&lt;th>USER&lt;/th>
&lt;th>FD&lt;/th>
&lt;th>TYPE&lt;/th>
&lt;th>DEVICE&lt;/th>
&lt;th>SIZE/OFF&lt;/th>
&lt;th>NODE&lt;/th>
&lt;th>NAME&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>python&lt;/td>
&lt;td>31551&lt;/td>
&lt;td>devmessias&lt;/td>
&lt;td>4u&lt;/td>
&lt;td>IPv4&lt;/td>
&lt;td>16622065&lt;/td>
&lt;td>0t0&lt;/td>
&lt;td>TCP&lt;/td>
&lt;td>localhost:57314-&amp;gt;localhost:5000 (ESTABLISHED)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Note que uma conex√£o foi estabelecida (coluna NAME). Se o servi√ßo estivesse enviado a resposta n√£o ter√≠amos obtido nada na sa√≠da do &lt;code>lsof&lt;/code>.&lt;/p>
&lt;h2 id="problemas-com-arquivos">Problemas com arquivos&lt;/h2>
&lt;p>Vamos simular alguns problemas com arquivos regulares: csv, txt, bin, jpg etc. Copie um csv para pasta /tmp/, ou execute o comando abaixo para criar um txt dummy contendo o manual do comando strace.&lt;/p>
&lt;pre>&lt;code class="language-bash">$ man strace &amp;gt; /tmp/arquivo.csv
&lt;/code>&lt;/pre>
&lt;h3 id="quais-processos-est√£o-usando-esse-arquivo">Quais processos est√£o usando esse arquivo?&lt;/h3>
&lt;p>O objetivo aqui √© saber quais processos est√£o acessando um arquivo. Isto √© √∫til quando queremos identificar processos que j√° deveriam ter &amp;ldquo;fechado&amp;rdquo; o arquivo ou inentificar acessos indenvidos. Tamb√©m pode ser √∫til para descobrir qual processo est√° criando um arquivo gigantesco no seu sistema para que voc√™ possa dar um kill.&lt;/p>
&lt;p>Crie o script a seguir em uma pasta.&lt;/p>
&lt;pre>&lt;code class="language-python">#!/usr/bin/env python
# file_open.py
import time
f = open('/tmp/arquivo.csv', 'r')
input('Press Enter to continue...')
&lt;/code>&lt;/pre>
&lt;p>Depois abra duas sess√µes no terminal e rode o comando &lt;code>python file_open.py&lt;/code>. Agora basta listar os processos que est√£o com arquivo.csv abertos&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lsof /tmp/arquivo.csv
&lt;/code>&lt;/pre>
&lt;p>O output ser√° algo do tipo&lt;/p>
&lt;pre>&lt;code>COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME
python 15411 devmessias 3r REG 8,2 0 2911031 /tmp/arquivo.csv
python 20777 devmessias 3r REG 8,2 0 2911031 /tmp/arquivo.csv
&lt;/code>&lt;/pre>
&lt;p>Temos dois processos distintos (dois PID) utilizando nosso arquivo.&lt;/p>
&lt;h3 id="deletei-o-csv-e-agora">Deletei o csv e agora?&lt;/h3>
&lt;p>Suponha uma situa√ß√£o em que acidentalmente um arquivo foi apagado. Contudo, existe um processo que ainda est√° fazendo uso de tal recurso.&lt;/p>
&lt;p>Crie um arquivo qualquer, aqui vou chamar de &lt;code>acidente.txt&lt;/code>&lt;/p>
&lt;p>Abra uma sess√£o no terminal e execute o comando a seguir. &lt;strong>N√£o feche a sess√£o!&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-bash">$ python -c 'f=open(&amp;quot;acidente.txt&amp;quot;, &amp;quot;r&amp;quot;);input(&amp;quot;...&amp;quot;)'
&lt;/code>&lt;/pre>
&lt;p>Simularemos o acidente que outro processo remove o arquivo. Execute os comandos abaixo&lt;/p>
&lt;pre>&lt;code class="language-bash">$ rm acidente.txt
$ ls acidente.txt
&lt;/code>&lt;/pre>
&lt;p>Nosso arquivo foi embora :(&lt;/p>
&lt;pre>&lt;code>ls: cannot access 'acidente.txt': No such file or directory
&lt;/code>&lt;/pre>
&lt;p>Mas n√£o se preocupe! Uma coisa legal do linux: todos os processos do sistema tem a eles associados um diret√≥rio dentro da pasta &lt;code>/proc&lt;/code> (everthing is a file). E o que tem nesses diret√≥rios ? Muitas coisas, incluindo o &lt;code>file descriptor&lt;/code> do &lt;code>acidente.txt&lt;/code>. Utilizado pelo nosso processo python. Para encontrar esse &lt;code>file descriptor&lt;/code> usaremos o &lt;code>lsof&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-bash">$ lsof -u nomedeusuario | grep 'acidente.txt'
&lt;/code>&lt;/pre>
&lt;p>No meu caso obtive o seguinte output&lt;/p>
&lt;pre>&lt;code>python 22465 devmessias 3r REG 8,2 37599 14288174 caminho/acidente.txt (deleted)
&lt;/code>&lt;/pre>
&lt;p>Ent√£o o PID √© &lt;code>22465&lt;/code> e o n√∫mero que descreve o arquivo (file descriptor) √© &lt;code>3&lt;/code> (o que vem antes do &lt;code>r&lt;/code> no output acima). Para obter uma c√≥pia do acidente.txt deletado basta chamar um simples &lt;code>cp&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-bash">$ cp /proc/22465/fd/3 recuperado.txt
&lt;/code>&lt;/pre>
&lt;p>Abra o arquivo &lt;code>recuperado.txt&lt;/code> e veja que tudo est√° no seu devido lugar. N√£o √© m√°gica, procure por &lt;strong>process pseudo-filesystem&lt;/strong> na web ou digite &lt;code>man proc&lt;/code> .&lt;/p>
&lt;h3 id="erros-silenciosos-arquivo-n√£o-existente-ou-permiss√£o">Erros silenciosos: arquivo n√£o existente ou permiss√£o&lt;/h3>
&lt;p>Em alguns casos voc√™ pode ter um processo criado por uma depend√™ncia externa que tenta acessar um arquivo com permiss√£o errada ou mesmo n√£o existente. Criaremos essas duas situa√ß√µes com o script &lt;code>file_404.py&lt;/code>.&lt;/p>
&lt;pre>&lt;code class="language-python">#!/usr/bin/env python
# file_404.py
import time
try:
f = open('/tmp/arquivo_404.csv', 'r')
except FileNotFoundError:
pass
try:
# um arquivo que vc nao tem permissao, crie como sudo e mude com chmod 700
f = open('/tmp/arquivo_permission.csv', 'r')
except PermissionError:
pass
input('Press Enter to continue...')
&lt;/code>&lt;/pre>
&lt;p>Execute ele com &lt;code>python file_404.py&lt;/code> veja que nenhum problema √© informado.&lt;/p>
&lt;p>Para traquear as chamadas do sistema do tipo arquivo feitas por &lt;code>python file_404.py &lt;/code> basta digitar o comando abaixo no terminal&lt;/p>
&lt;pre>&lt;code class="language-bash">$ strace -f -e trace=file python file_404.py
&lt;/code>&lt;/pre>
&lt;p>o argumento &lt;code>-f&lt;/code> diz para o strace monitorar tamb√©m qualquer processo filho criado. Em python, isso seria por exemplo os processos criados por &lt;code>os.fork&lt;/code>.&lt;/p>
&lt;p>A sa√≠da do exemplo ser√° algo do tipo&lt;/p>
&lt;pre>&lt;code>lstat(&amp;quot;SEU DIRETORIO/file_404.py&amp;quot;, {st_mode=S_IFREG|0644, st_size=242, ...}) = 0
openat(AT_FDCWD, &amp;quot;file_404.py&amp;quot;, O_RDONLY) = 3
openat(AT_FDCWD, &amp;quot;/tmp/arquivo_404.csv&amp;quot;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &amp;quot;/tmp/arquivo_permission.csv&amp;quot;, O_RDONLY|O_CLOEXEC) = -1 EACCES (Permission denied)
&lt;/code>&lt;/pre>
&lt;p>Note que temos no output informa√ß√µes que n√£o queremos investigar, mas nas √∫ltimas linhas os erros de permiss√£o e aus√™ncia de arquivo apareceram.&lt;/p>
&lt;p>Uma maneira de filtrar o resultado e tornar sua vida mais f√°cil √© usar o &lt;code>awk&lt;/code> redirecionado a sa√≠da do strace com o pipe &lt;code>|&lt;/code>.&lt;/p>
&lt;pre>&lt;code class="language-bash">$ strace -f -e trace=file python file_404.py 2&amp;gt;&amp;amp;1 | awk '/^open/ &amp;amp;&amp;amp; /= -1/ {print}'
&lt;/code>&lt;/pre>
&lt;p>O comando acima diz para mostrar apenas as linhas que come√ßam com a string &lt;code>open&lt;/code> e em alguma parte da linha tenha o padr√£o &lt;code>= -1&lt;/code>.&lt;/p>
&lt;p>O comando com &lt;code>awk&lt;/code> concatenado produzir√° um output mais limpo, veja s√≥&lt;/p>
&lt;pre>&lt;code>openat(AT_FDCWD, &amp;quot;/home/devmessias/anaconda3/pyvenv.cfg&amp;quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &amp;quot;/tmp/arquivo_404.csv&amp;quot;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, &amp;quot;/tmp/arquivo_permission.csv&amp;quot;, O_RDONLY|O_CLOEXEC) = -1 EACCES (Permission denied)
&lt;/code>&lt;/pre>
&lt;h3 id="esse-processo-est√°-salvando-algo-que-n√£o-deveria-onde">Esse processo est√° salvando algo que n√£o deveria? Onde?&lt;/h3>
&lt;p>Talvez voc√™ queira monitorar o que uma depend√™ncia externa anda fazendo no seu sistema de arquivos. Outro problema que pode ocorrer √© caso voc√™ delete um arquivo usado por uma depend√™ncia, contudo tal depend√™ncia fez um cache em algum lugar antes de voc√™ efetuar a remo√ß√£o. O que te impede de &lt;em>ressetar&lt;/em> a depend√™ncia.&lt;/p>
&lt;p>Usando o mesmo comando anterior √© poss√≠vel buscar onde esses caches e arquivos est√£o&lt;/p>
&lt;pre>&lt;code class="language-bash">$ strace -f -e trace=file comando 2&amp;gt;&amp;amp;1 | awk '/^open/{print}'
&lt;/code>&lt;/pre>
&lt;p>se voc√™ quiser pegar apenas as chamadas que n√£o retornaram em falha digite&lt;/p>
&lt;pre>&lt;code class="language-bash">$ strace -f -e trace=file comando 2&amp;gt;&amp;amp;1 | awk '/^open/ &amp;amp;&amp;amp; !/= -1/ {print}'
&lt;/code>&lt;/pre>
&lt;h2 id="extras-envolvendo-arquivos-proc-e-strace">Extras envolvendo arquivos (&lt;code>/proc/&lt;/code>) e &lt;code>strace&lt;/code>&lt;/h2>
&lt;p>Usando problemas comuns envolvendo arquivos e conex√µes conversamos um pouco sobre o &lt;code>strace&lt;/code> e &lt;code>lsof&lt;/code>. Conceitos como SYS CALL e a pasta &lt;code>/proc/&lt;/code> tamb√©m foram mencioandos. Darei alguns exemplos de algumas outras quest√µes que podemos responder usando esses outros elementos.&lt;/p>
&lt;h3 id="gerando-um-sum√°rio-de-sys-call">Gerando um sum√°rio de SYS CALL&lt;/h3>
&lt;p>Voc√™ pode sumarizar todas as sys call feitas por um processo usando o argumento &lt;code>-c&lt;/code>. Isso pode te ajudar a economizar tempo numa pre-an√°lise.&lt;/p>
&lt;p>O comando abaixo retorna as sys calls efetuadas pelo comando &lt;code>make sync-env&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-bash">$ strace -c -e trace=!\wait4 make sync-env
&lt;/code>&lt;/pre>
&lt;p>outro argumento que foi alterado aqui √© o operador &lt;code>!\&lt;/code> que diz para o strace ignorar as sys call do tipo &lt;code>wait4&lt;/code>. O ouput ser√° algo do tipo:&lt;/p>
&lt;pre>&lt;code>% time seconds usecs/call calls errors syscall
------ ----------- ----------- --------- --------- ----------------
14,54 0,000209 6 33 13 openat
13,01 0,000187 17 11 vfork
12,32 0,000177 7 25 mmap
8,49 0,000122 3 31 close
8,42 0,000121 5 21 rt_sigprocmask
8,14 0,000117 6 17 read
6,89 0,000099 5 19 11 stat
5,85 0,000084 3 23 fstat
2,85 0,000041 8 5 mprotect
2,64 0,000038 9 4 write
2,51 0,000036 2 16 fcntl
2,02 0,000029 3 9 rt_sigaction
1,95 0,000028 14 2 readlink
1,95 0,000028 14 2 getdents64
1,25 0,000018 4 4 brk
1,25 0,000018 18 1 1 access
1,25 0,000018 3 5 pipe
1,11 0,000016 4 4 ioctl
0,84 0,000012 6 2 getcwd
0,70 0,000010 10 1 munmap
0,49 0,000007 7 1 lstat
0,49 0,000007 7 1 execve
0,49 0,000007 3 2 prlimit64
0,35 0,000005 5 1 chdir
0,21 0,000003 3 1 arch_prctl
------ ----------- ----------- --------- --------- ----------------
100.00 0,001437 241 25 total
&lt;/code>&lt;/pre>
&lt;p>A coluna time diz que &lt;code>make sync-env&lt;/code> gastou $14$% do tempo (com exce√ß√£o do &lt;code>wait4&lt;/code>) em sys calls do tipo &lt;code>openat&lt;/code> e $13$ das $33$ chamadas n√£o foram bem sucedidas.&lt;/p>
&lt;h3 id="o-processo-foi-iniciado-com-as-vari√°veis-de-ambiente-corretas">O processo foi iniciado com as vari√°veis de ambiente corretas?&lt;/h3>
&lt;p>Os pr√≥ximos exemplos envolvem situa√ß√µes em que um processo foi iniciado, mas voc√™ quer verificar algumas informa√ß√µes sobre o mesmo sem que seja necess√°rio matar e reiniciar processo. Imagine fazer isso em produ√ß√£o? Ou com um modelo de ML que j√° gastou muitos &lt;strong>R$&lt;/strong> para chegar no est√°gio atual.&lt;/p>
&lt;p>Vamos continuar com o nosso &lt;code>server_mlops.py&lt;/code>. Suponha que o processo foi iniciado usando uma vari√°vel de ambiente extra, &lt;code>ANSWER&lt;/code>.&lt;/p>
&lt;pre>&lt;code class="language-bash">$ ANSWER=42 python server_mlops.py
&lt;/code>&lt;/pre>
&lt;p>Ap√≥s o inicio do processo como saber com quais vari√°veis de ambiente ele est√° usando? Essa vari√°veis setam por exemplo bibliotecas de otimiza√ß√£o(BLAS, LAPACK), env&amp;rsquo;s python etc.&lt;/p>
&lt;p>Como dito em um exemplo anterior, a pasta &lt;code>/proc&lt;/code> cont√™m arquivos representado o estado dos processos em execu√ß√£o. Supondo que o PID do processo √© &lt;code>4031&lt;/code> voc√™ pode acessar as vari√°veis de ambiente do mesmo atrav√©s de &lt;code>cat /proc/4031/environ&lt;/code>. Mas o output √© meio feio, vamos usar &lt;code>tr&lt;/code> para trocar os caracteres nulos &lt;code>\0&lt;/code> por quebras de linhas, &lt;code>\n&lt;/code>.&lt;/p>
&lt;pre>&lt;code class="language-bash">$ tr '\0' '\n' &amp;lt; /proc/4031/environ
&lt;/code>&lt;/pre>
&lt;p>Voc√™ ter√° um output do tipo&lt;/p>
&lt;pre>&lt;code>ANSWER=42
SHELL=/bin/bash
LANGUAGE=en_US
JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64/bin/java
...more stuff
&lt;/code>&lt;/pre>
&lt;p>Se voc√™ quiser filtrar apenas linhas que comecem com a string CONDA fa√ßa&lt;/p>
&lt;pre>&lt;code class="language-bash">$ tr '\0' '\n' &amp;lt; /proc/4031/environ 2&amp;gt;&amp;amp;1 | awk '/^CONDA/ {print}'
&lt;/code>&lt;/pre>
&lt;p>o output no meu caso foi algo do tipo&lt;/p>
&lt;pre>&lt;code>CONDA_EXE=/home/devmessias/anaconda3/bin/conda
CONDA_PREFIX=/home/devmessias/anaconda3
CONDA_PROMPT_MODIFIER=(base)
CONDA_SHLVL=1
CONDA_PYTHON_EXE=/home/devmessias/anaconda3/bin/python
CONDA_DEFAULT_ENV=base
&lt;/code>&lt;/pre>
&lt;h3 id="esqueci-de--redirecionar-os-outputs-do-processo-para-um-arquivo--o-que-fazer">Esqueci de redirecionar os outputs do processo para um arquivo. O que fazer?&lt;/h3>
&lt;p>Suponha que voc√™ iniciou um processo e n√£o redirecionou os outputs para um arquivo de texto por esquecimento ou por subestimar problemas. Se reiniciar o processo n√£o √© uma op√ß√£o voc√™ est√° com problemas. Felizmente √© poss√≠vel usar o &lt;code>strace&lt;/code> para interceptar os outputs e salva-los em um arquivo externo.&lt;/p>
&lt;p>A SYS CALL respons√°vel por requisitar a &lt;em>escrita&lt;/em> no &lt;strong>stdin, stdout e stderr&lt;/strong> √© a &lt;code>write&lt;/code> . Veja o manual dessa chamada&lt;/p>
&lt;pre>&lt;code class="language-bash">$ man 2 write
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>NAME
write - write to a file descriptor
SYNOPSIS
#include &amp;lt;unistd.h&amp;gt;
ssize_t write(int fd, const void *buf, size_t count);
&lt;/code>&lt;/pre>
&lt;p>O primeiro argumento √© um inteiro que representa o file descriptor. Sendo que &lt;strong>fd=1&lt;/strong> implica que a chamada escrever√° no &lt;strong>stdout&lt;/strong> e &lt;strong>fd=2&lt;/strong> no &lt;strong>stderr&lt;/strong> . Portanto, n√£o existe nenhum segredo aqui. Se voc√™ quiser capturar os outputs basta filtrar as SYS CALL do tipo write e file descriptor &lt;strong>1&lt;/strong> ou &lt;strong>2&lt;/strong> e envia-las para o arquivo desejado. Temos que tomar cuidado s√≥ com as algumas coisas aqui. No manual do strace (&lt;code>man strace&lt;/code>) voc√™ vera que por padr√£o ele &lt;em>printa&lt;/em> apenas $32$ caracteres em uma string. Portanto, precisamos aumentar o limite com o argumento &lt;code>-s&lt;/code>. Tamb√©m √© interessante traquear os forks. No caso do &lt;code>server_mlops.py&lt;/code> por exemplo, qualquer print dentro de um m√©todo n√£o ser√° executado na main, ent√£o o &lt;code>-f&lt;/code> √© obrigat√≥rio.&lt;/p>
&lt;p>O comando para redirecionar as saidas do stdout e stderr no arquivo &lt;code>out.txt&lt;/code> pode ser colocado da seguinte maneira com o log dos tempos (-t) opicional.&lt;/p>
&lt;pre>&lt;code class="language-bash">$ strace -f -t -etrace=write -s 666 -p PID_DO_PROCESSO 2&amp;gt;&amp;amp;1 | grep --line-buffered -e 'write(2, ' -e 'write(1, ' &amp;gt;&amp;gt; out.txt
&lt;/code>&lt;/pre>
&lt;p>O c√≥digo abaixo tem uma altera√ß√£o no &lt;code>server_mlops.py&lt;/code> , e execute ele assim como o &lt;code>client_mlops.py&lt;/code>. Pegando o PID do &lt;code>serve_mlops&lt;/code> voc√™ conseguir√° explorar esse exemplo&lt;/p>
&lt;pre>&lt;code class="language-python"># server_mlops.py
import time
import flask
import sys
app = flask.Flask(__name__)
@app.route('/')
def hello_world():
sleep_time = flask.request.args.get('sleep', default=10, type=int)
print('sleep_time:', sleep_time)
for i in range(sleep_time):
print(f'INFO: {i} of sleep_time \n asdf \t ')
print(f'ERROR: Example msg {i}', file=sys.stderr)
time.sleep(1)
return 'Hello World!'
if __name__ == '__main__':
app.run()
&lt;/code>&lt;/pre>
&lt;h3 id="qual-comando-gerou-o-processo-e-onde-√©-o-seu-working-dir">Qual comando gerou o processo e onde √© o seu working dir?&lt;/h3>
&lt;p>Essa pergunta talvez n√£o seja t√£o dif√≠cil de responder se voc√™ tem o &lt;code>htop&lt;/code> instalado. Mas supondo que voc√™ n√£o lembra as informa√ß√µes sobre o comando que gerou o processo execute o comando abaixo&lt;/p>
&lt;pre>&lt;code class="language-bash">$ tr '\0' '\t' &amp;lt; /proc/PID_CLIENT_MLOPS/cmdline
&lt;/code>&lt;/pre>
&lt;p>o output ser√°&lt;/p>
&lt;pre>&lt;code>python client_mlops.py --sleep 1000
&lt;/code>&lt;/pre>
&lt;p>Para descobrir o diret√≥rio do &lt;code>client_mlops.py&lt;/code> basta executar&lt;/p>
&lt;pre>&lt;code class="language-bash">$ readlink /proc/PID_CLIENT_MLOPS/cwd
&lt;/code>&lt;/pre>
&lt;h2 id="agradecimentos--sugest√µes">Agradecimentos &amp;amp; Sugest√µes&lt;/h2>
&lt;blockquote>
&lt;p>Achou um erro? Tem alguma sugest√£o ou dica? mande um email para &lt;a href="mailto:devmessias@gmail.com">devmessias@gmail.com&lt;/a>.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>Obrigado
&lt;a href="https://www.linkedin.com/in/elisarma" target="_blank" rel="noopener">Elisa Ribeiro&lt;/a> por ter corrigido os typos da primeira vers√£o do post.&lt;/li>
&lt;li>
&lt;a href="https://www.linkedin.com/in/reynaldoallanf" target="_blank" rel="noopener">Reynaldo Allan Fulin&lt;/a> pelas discuss√µes sempre √∫teis sobre linux.&lt;/li>
&lt;/ul></description></item></channel></rss>