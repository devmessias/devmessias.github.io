<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>compilers | Bruno Messias</title><link>/pt-br/tag/compilers/</link><atom:link href="/pt-br/tag/compilers/index.xml" rel="self" type="application/rss+xml"/><description>compilers</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>pt-br</language><copyright>Bruno Messias</copyright><lastBuildDate>Mon, 11 Apr 2022 00:00:00 +0000</lastBuildDate><image><url>/images/icon_hucd6a3d413e7b81060a1d462b35f64cf9_5018_512x512_fill_lanczos_center_2.png</url><title>compilers</title><link>/pt-br/tag/compilers/</link></image><item><title>Metaprograma√ß√£o em Python com ASTs: criando um decorador com introspec√ß√£o</title><link>/pt-br/post/python_ast_metaprogramming_with_introspection_and_decorators/</link><pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate><guid>/pt-br/post/python_ast_metaprogramming_with_introspection_and_decorators/</guid><description>&lt;details
class="toc-inpage d-print-none d-none d-sm-block d-md-none " open>
&lt;summary class="font-weight-bold">Lista de Conte√∫dos&lt;/summary>
&lt;nav id="TableOfContents">
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>&lt;a href="#introdu√ß√£o">Introdu√ß√£o&lt;/a>&lt;/li>
&lt;li>&lt;a href="#asts-o-que-s√£o">ASTs: O que s√£o?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#python-√©--interpretado-ou-compilado">Python √© interpretado ou compilado?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#extraindo-e-interpretando-asts">Extraindo e interpretando ASTs&lt;/a>&lt;/li>
&lt;li>&lt;a href="#como-metaprogramar-de-forma-eficiente">Como metaprogramar de forma eficiente?&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#6-passos-simples">6 passos simples&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#criando-nossa-meta-fun√ß√£o">Criando nossa meta-fun√ß√£o&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#primeira-itera√ß√£o">Primeira itera√ß√£o&lt;/a>&lt;/li>
&lt;li>&lt;a href="#o-nodetransformer">O NodeTransformer&lt;/a>&lt;/li>
&lt;li>&lt;a href="#a-segunda-itera√ß√£o">A segunda itera√ß√£o&lt;/a>&lt;/li>
&lt;li>&lt;a href="#criando-uma-nova-fun√ß√£o-em-runtime">Criando uma nova fun√ß√£o em runtime&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#integrando-a-manipula√ß√£o-de-ast-com-um-decorador">Integrando a manipula√ß√£o de AST com um decorador&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/nav>
&lt;/details>
&lt;h2 id="introdu√ß√£o">Introdu√ß√£o&lt;/h2>
&lt;p>N√£o se assuste com as palavras no t√≠tulo. Embora possam ser estranhas para voc√™ provavelmente em algum momento voc√™ utilizou ferramentas que fazem uso de t√©cnicas de metaprograma√ß√£o ou inspe√ß√£o de AST. Pytest e Numba s√£o exemplos.&lt;/p>
&lt;p>No post anterior eu falei sobre python frames e inspection. Mostrei como podemos usar &lt;code>inspect.signautre&lt;/code> para criar um decorador que valide argumentos:&lt;/p>
&lt;pre>&lt;code class="language-python">@math_validator()
def simple_method(x: &amp;quot;\in R&amp;quot;, y: &amp;quot;\in R_+&amp;quot;, z: float = 2) -&amp;gt; float:
...
simple_method(1, 0)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>simple_method((1, 2)) -&amp;gt; 1.5
---&amp;gt; 19 simple_method(1, 0)
...
&amp;lt;locals&amp;gt;.decorate.&amp;lt;locals&amp;gt;.decorated(*_args)
11 continue
13 if not MATH_SPACES[annotation][&amp;quot;validator&amp;quot;](_args[i]):
---&amp;gt; 14 raise ValueError(f&amp;quot;{k} doesn't belong to the {MATH_SPACES[annotation]['name']}&amp;quot;)
15 result = func(*_args)
16 print(f&amp;quot;{func.__name__}({_args}) -&amp;gt; {result}&amp;quot;)
ValueError: y doesn't belong to the space of real numbers greater than zero
&lt;/code>&lt;/pre>
&lt;p>No outro exemplo mostrei como podemos combinar o &lt;code>signature&lt;/code> com &lt;code>sys.trace&lt;/code> para criar um decorador que exp√µe o &lt;code>locals&lt;/code> da fun√ß√£o decorada. O que nos permite fazer coisas legais tais como criar um decorador &lt;code>@report&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-python">@report('{arg.n_bananas} Monkey {gluttonous_monkey} ate too much bananas. Num monkeys {num_monkeys}')
def feed_monkeys(n_bananas):
num_monkeys = 3
monkeys = {
f&amp;quot;monkey_{i}&amp;quot;: {&amp;quot;bananas&amp;quot;: 0}
for i in range(num_monkeys)
}
while n_bananas &amp;gt; 0:
if np.random.uniform() &amp;lt; 0.4:
continue
monkey = monkeys[np.random.choice(list(monkeys.keys()))]
if n_bananas &amp;gt; 0:
monkey[&amp;quot;bananas&amp;quot;] += 1
n_bananas -= 1
gluttonous_monkey = max(monkeys, key=lambda k: monkeys[k][&amp;quot;bananas&amp;quot;])
&lt;/code>&lt;/pre>
&lt;p>Contudo, no final do post passado eu disse que essa solu√ß√£o tem alguns problemas&lt;/p>
&lt;p>&lt;div class="spoiler " >
&lt;p>
&lt;a class="btn btn-primary" data-toggle="collapse" href="#spoiler-1" role="button" aria-expanded="false" aria-controls="spoiler-1">
Click here to see the solution
&lt;/a>
&lt;/p>
&lt;div class="collapse card " id="spoiler-1">
&lt;div class="card-body">
&lt;pre>&lt;code class="language-python">import sys
import inspect
from types import SimpleNamespace
def call_and_extract_frame(func, *args, **kwargs):
frame_var = None
trace = sys.gettrace()
def update_frame_var(stack_frame, event_name, arg_frame):
&amp;quot;&amp;quot;&amp;quot;
Args:
stack_frame: (frame)
The current stack frame.
event_name: (str)
The name of the event that triggered the call.
Can be 'call', 'line', 'return' and 'exception'.
arg_frame:
Depends on the event. Can be a None type
&amp;quot;&amp;quot;&amp;quot;
nonlocal frame_var # nonlocal is a keyword which allows us to modify the outisde scope variable
if event_name != 'call':
return trace
frame_var = stack_frame
sys.settrace(trace)
return trace
sys.settrace(update_frame_var)
try:
func_result = func(*args, **kwargs)
finally:
sys.settrace(trace)
return frame_var, func_result
def report(formater):
def decorate(func):
def decorated(*_args):
sig = inspect.signature(func)
named_args = {}
num_args = len(_args)
for i, (k, v) in enumerate(sig.parameters.items()):
if i &amp;lt; num_args:
named_args[k] = repr(_args[i])
else:
named_args[k] = repr(v.default)
frame_func, _result = call_and_extract_frame(func, *_args)
name = func.__name__
result = repr(_result)
args_dict = {
&amp;quot;args&amp;quot;: SimpleNamespace(**named_args),
&amp;quot;args_repr&amp;quot;: repr(SimpleNamespace(**named_args)),
**locals(),
**frame_func.f_locals,
}
print(formater.format(**args_dict))
# do other stuff here
return _result
return decorated
return decorate
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/div>
&lt;/div>
Quais s√£o os problemas?&lt;/p>
&lt;ul>
&lt;li>
&lt;p>√â esperado que o tracing reduza a performance do sistema. Se voc√™ usar a solu√ß√£o acima s√≥ para casos pontuais ou debug √© ok&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Pode criar conflitos com outras ferramentas e bibliotecas que tamb√©m est√£o usando a ferramenta de tracing, tais como debuggers.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Parece uma solu√ß√£o feia!&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Voc√™ pode se perguntar: &amp;ldquo;&lt;em>Overengineering! Era s√≥ esse fazer isso aqui:&lt;/em>&amp;rdquo;&lt;/p>
&lt;pre>&lt;code class="language-python">@report('stuff goes here')
def func(x, y):
random_var = np.random.uniform()
... #more local vars
result = (x+y)**random_var
return result, locals
&lt;/code>&lt;/pre>
&lt;p>&lt;em>&amp;quot;..e dentro do decorador ele mudar para isso&amp;quot;&lt;/em>&lt;/p>
&lt;pre>&lt;code class="language-python">_result, local_vars = func(x, y)
&lt;/code>&lt;/pre>
&lt;p>A raz√£o √©:&lt;/p>
&lt;p>O ponto de usar um decorador √© para evitar mudan√ßas em qualquer outra parte da nossa codebase. Por exemplo, se em qualquer outra parte da nossa codebase func est√° sendo chamada, eu teria que fazer mudan√ßas do tipo&lt;/p>
&lt;pre>&lt;code class="language-python">result = func(x, y) # to
result = func(x, y)[0]
&lt;/code>&lt;/pre>
&lt;p>E se futuramente eu quisesse remover o decorador de uma fun√ß√£o eu teria que desfazer todas as mudan√ßas acima&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Voc√™ ir√° aumentar o cognitive load de todos os membros do seu time que n√£o precisam saber sobre ou usar o decorador.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Se voc√™ est√° ok com fazer mudan√ßas em outros lugares do seu c√≥digo por que n√£o criar novas fun√ß√µes ao inv√©s de decoradores que funcionam mais ou menos?&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Ok, voc√™ pode estar pensando: &amp;ldquo;T√° , faz sentido n√£o fazer isso que sugeri, mas do que adianta evitar sujar sua codebase se voc√™ t√° criando problemas de desempenho e debug? N√£o parece uma boa solu√ß√£o na maioria dos casos. Eu tenho que concordar com voc√™!&amp;rdquo;&lt;/p>
&lt;p>Bom, ent√£o o que podemos fazer?? O problema que encontramos √© que em python n√£o temos context managers que podem lidar com namespaces
&lt;a href="https://mail.python.org/archives/list/python-ideas@python.org/thread/TAVHEKDZVYKJUGZKWSVZVAOGBPLZVKQG/" target="_blank" rel="noopener">https://mail.python.org/archives/list/python-ideas@python.org/&lt;/a>. Mas se desanime com essa limita√ß√£o, a quest√£o agora √©:&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
&lt;strong>Se uma linguagem n√£o tem uma feature que eu preciso o que eu posso fazer?&lt;/strong>
&lt;/div>
&lt;/div>
&lt;p>Em pyhton estamos bem com isso pois √© f√°cil manipular o que √© conhecido como &lt;strong>A&lt;/strong>bstract &lt;strong>S&lt;/strong>yntax &lt;strong>T&lt;/strong>ree (√°rvore sint√°tica abstrata) e compilar ela em uma nova fun√ß√£o em tempo de execu√ß√£o (runtime). ** Quando programamos desse jeito estamos no reino da metaprograma√ß√£o! Tentarei esclarecer esses pontos agora**&lt;/p>
&lt;h2 id="asts-o-que-s√£o">ASTs: O que s√£o?&lt;/h2>
&lt;p>Uma linguagem de programa√ß√£o √© obviamente, pelo menos uma linguagem&amp;hellip; OK, &lt;strong>mas o que √© uma linguagem? Todas as linguagens humanas compartilham uma estrutura em comum? Como podemos comparar senten√ßas diferentes na mesma linguagem?&lt;/strong> Essas quest√µes talvez pare√ßam ser mais adequadas para serem respondidas por fil√≥sofos. Contudo, tamb√©m √© tema de trabalho de matem√°ticos e computeiros&lt;/p>
&lt;p>A grande diferen√ßa √© que matem√°ticos e computeiros comumente preferem falar sobre coisas usando algum formalismo matem√°tico. Em ess√™ncia, &lt;strong>AST&lt;/strong> faz parte de um formalismo matem√°tico que permite isso. Uma &lt;strong>AST&lt;/strong> permite representar uma senten√ßa atrav√©s de um grafo direcionado do tipo √°rvore. Para isso usamos um conjunto de regras bem definidas em como construir essa √°rvore.&lt;/p>
&lt;h3>Como saber se uma senten√ßa est√° gramaticalmente correta?&lt;/h3>
&lt;p>Voc√™ provavelmente se lembra quase institivamente de um conjunto de regras que aprendeu durante sua vida ou acabou se acostumando sobre como organizar e compor verbos, substantivos, adjetivos, etc. Este conjunto de regras e guias √© a sintaxe da linguagem que voc√™ fala/escreve. &lt;em>AST&lt;/em>s permitem checar e compreender uma senten√ßa utilizando essas regras&lt;/p>
&lt;p>Pegue por exemplo a senten√ßa&lt;/p>
&lt;p>&lt;em>&amp;ldquo;I drive a car to my college&amp;rdquo;&lt;/em>, a AST √© a seguinte&lt;/p>
&lt;figure id="figure-fonte-geeks-for-geekssyntax-tree--natural-language-processinghttpswwwgeeksforgeeksorgsyntax-tree-natural-language-processing">
&lt;a data-fancybox="" href="/pt-br/post/python_ast_metaprogramming_with_introspection_and_decorators/ast_english_sentence_hue5b8d52ce962721ee6d0acb19268cb10_239788_0x400_resize_lanczos_2.png" data-caption="&amp;lt;strong&amp;gt;Fonte&amp;lt;/strong&amp;gt;:&amp;lt;a href=&amp;#34;https://www.geeksforgeeks.org/syntax-tree-natural-language-processing/&amp;#34;&amp;gt; Geeks for Geeks:Syntax Tree ‚Äì Natural Language Processing.&amp;lt;/a&amp;gt;">
&lt;img src="/pt-br/post/python_ast_metaprogramming_with_introspection_and_decorators/ast_english_sentence_hue5b8d52ce962721ee6d0acb19268cb10_239788_0x400_resize_lanczos_2.png" alt="" height="400px">
&lt;/a>
&lt;figcaption>
&lt;strong>Fonte&lt;/strong>:&lt;a href="https://www.geeksforgeeks.org/syntax-tree-natural-language-processing/"> Geeks for Geeks:Syntax Tree ‚Äì Natural Language Processing.&lt;/a>
&lt;/figcaption>
&lt;/figure>
&lt;p>Qual a vantagem de usar ASTs? Note que n√£o precisamos falar de espa√ßos, caligrafia ou estilo pessoal de organizar escrita para compreender uma senten√ßa e saber se ela est√° v√°lida. Al√©m disso, temos uma estrutura hier√°rquica que permite entender a senten√ßa por n√≠veis!&lt;/p>
&lt;p>N√£o √© uma surpresa que ASTs s√£o tamb√©m uma ferramenta comum em processos de analisar a validade de um c√≥digo ou na constru√ß√£o de um compilador/interpretador. Nesse post iremos manipular a AST! Mas antes disso quero fazer uma pergunta:&lt;/p>
&lt;h2 id="python-√©--interpretado-ou-compilado">Python √© interpretado ou compilado?&lt;/h2>
&lt;p>Geralmente, quando encontro um hater de python ou mesmo um entusiasta ou√ßo ou leio coisas do tipo:&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;&lt;em>Python √© lento pois √© uma linguagem interpretada&lt;/em>&amp;rdquo;&lt;/li>
&lt;li>&amp;ldquo;*Python √© legal pois n√£o tem chatice de compila√ß√£o&amp;rdquo;&lt;/li>
&lt;li>&lt;em>&amp;ldquo;Python √© ruim comparado a C pois n√£o tem um compilador&amp;rdquo;&lt;/em>&lt;/li>
&lt;/ul>
&lt;p>Bem, essas asser√ß√µes n√£o s√£o verdadeiras, pois est√£o usando conceitos errados! Outra confus√£o √© que geralmente quando se fala em python estamos nos referindo a linguagem (sintaxe, etc) python mais a m√°quina virtual do CPython. Vamos conversar um pouco mais sobre isso&lt;/p>
&lt;p>Dizer que uma linguagem hoje √© &lt;em>puramente compilada ou interpretada&lt;/em> √© confuso, pois essa divis√£o √© borrada. Veja o seguinte&lt;/p>
&lt;pre>&lt;code class="language-python">hello_world = &amp;quot;print('Hello, world!')&amp;quot;
hello_world_obj = compile(hello_world, '&amp;lt;string&amp;gt;', 'single')
&lt;/code>&lt;/pre>
&lt;p>Pois √©&amp;hellip; se voc√™ tentaria defender nos coment√°rios que python √© puramente interpretado as coisas est√£o mais dif√≠ceis para voc√™. Por que tem um &lt;code>compile&lt;/code> dispon√≠vel? O que ele faz?&lt;/p>
&lt;pre>&lt;code class="language-python">exec(hello_world_obj)
Hello, world!
&lt;/code>&lt;/pre>
&lt;p>O que ser√° que tem dentro desse &lt;code>hello_world_obj&lt;/code>?&lt;/p>
&lt;pre>&lt;code class="language-python">print(f&amp;quot;Bad news for you:\n\tContent: {hello_world_obj.co_code}\n\tType: {type(hello_world_obj.co_code)}&amp;quot;)
Bad news for you:
Content: b'e\x00d\x00\x83\x01F\x00d\x01S\x00'
Type: &amp;lt;class 'bytes'&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>Para entender os prints acima voc√™ precisa compreender o que acontece por tr√°s dos panos quando um c√≥digo python √© &amp;ldquo;&lt;em>interpretado&lt;/em>&amp;rdquo;.&lt;/p>
&lt;p>Ap√≥s voc√™ escrever um c√≥digo e chamar o comando python, o python inicia um processo de compila√ß√£o criando as ASTs, depois gerando bytecodes a partir das ASTs e esses √∫ltimos ser√£o encapsulados em &lt;code>code_object&lt;/code>s. Na √∫ltima etapa os code objects ser√£o interpretados pela m√°quina virtual do CPython. O diagrama √† baixo √© uma representa√ß√£o simples (com passos omitidos) do processo&lt;/p>
&lt;div class="mermaid mermaidContainer">
graph LR;
A[Source Code]-->|parsing|B[Parse Tree];
B-->C[AST];
C-->E[Bytecode];
E-->F[Code Object];
F-->|execution by|G[CPython Virtual Machine];
&lt;/div>
&lt;p>A fase de compila√ß√£o s√£o os primeiros passos do diagrama acima&lt;/p>
&lt;div class="mermaid mermaidContainer">
graph LR;
A[Source Code]-->|parsing|B[Parse Tree];
B-->C[AST];
C-->E[Bytecode];
E-->F[Code Object];
&lt;/div>
Se voc√™ n√£o conhece os conceitos dos nomes acima n√£o se preocupe, n√£o precisamos de tanto aprofundamento.
**Bytecodes s√£o apenas uma maneira compacta de dizer ao interpretador o que o c√≥digo quer que ele fa√ßa. Enquanto code objects s√£o coisas que encapsulam esses bytecodes.**
&lt;p>Ok, onde isso entra na minha solu√ß√£o? O que eu proponho fazer √© manipular a AST e compilar um novo code object que ser√° interpretado pelo cpython!&lt;/p>
&lt;blockquote>
&lt;p>Um hist√≥ria engra√ßada do Luciano Ramalho:
&lt;blockquote class="twitter-tweet">&lt;p lang="en" dir="ltr">In 2018 I told a CBP officer I was entering the US to speak at PyCon. He asked: &amp;quot;Is Python interpreted or compiled?&amp;quot; After a 2 second pause I said &amp;quot;Interpreted&amp;quot;. I didn&amp;#39;t give the correct answer because I didn&amp;#39;t want to extend the &amp;quot;pleasant&amp;quot; conversation. He let me in.&lt;/p>&amp;mdash; Luciano Ramalho ‚òî üêç ‚öó ‚ñ∂Ô∏èüò∑üíâüíâüíâ (@ramalhoorg) &lt;a href="https://twitter.com/ramalhoorg/status/1474044907585167362?ref_src=twsrc%5Etfw">December 23, 2021&lt;/a>&lt;/blockquote>
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script>
&lt;/p>
&lt;/blockquote>
&lt;h2 id="extraindo-e-interpretando-asts">Extraindo e interpretando ASTs&lt;/h2>
&lt;p>Veja o seguinte exemplo:&lt;/p>
&lt;pre>&lt;code class="language-python">import inspect
import ast
import astor # install this for pretty printing
def example(a: float, b:float = 2) -&amp;gt; float:
s = a+b
return s
tree = ast.parse(inspect.getsource(example))
print(astor.dump(tree))
astor.to_source(tree)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>Module(
body=[
FunctionDef(name='example',
args=arguments(posonlyargs=[],
args=[arg(arg='a', annotation=Name(id='float'), type_comment=None),
arg(arg='b', annotation=Name(id='float'), type_comment=None)],
vararg=None,
kwonlyargs=[],
kw_defaults=[],
kwarg=None,
defaults=[Constant(value=2, kind=None)]),
body=[
Assign(targets=[Name(id='s')],
value=BinOp(left=Name(id='a'), op=Add, right=Name(id='b')),
type_comment=None),
Return(value=Name(id='s'))],
decorator_list=[],
returns=Name(id='float'),
type_comment=None)],
type_ignores=[])
&lt;/code>&lt;/pre>
&lt;p>O output acima √© a AST da fun√ß√£o. Gaste algum tempo olhando essa sa√≠da e tente entender/inferir o que cada coisa significa e como ela √© organizada. A imagem abaixo √© a representa√ß√£o visual da sa√≠da acima&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="/pt-br/post/python_ast_metaprogramming_with_introspection_and_decorators/simple_ast_hudca446749283cbe6d28b67a245474890_120568_0x1000_resize_lanczos_2.png" >
&lt;img src="/pt-br/post/python_ast_metaprogramming_with_introspection_and_decorators/simple_ast_hudca446749283cbe6d28b67a245474890_120568_0x1000_resize_lanczos_2.png" alt="" height="400px">
&lt;/a>
&lt;/figure>
&lt;p>Cada elemento do output que inicia com uma letra mai√∫scula √© um n√≥, &lt;strong>node&lt;/strong>(Name, BinOp, FunctionDef, etc) derivado da classe &lt;code>ast.Node&lt;/code>. Um dos n√≥s mais importante √© o &lt;code>ast.Name&lt;/code>.
Por exemplo em&lt;/p>
&lt;pre>&lt;code>value=BinOp(left=Name(id='a'), op=Add, right=Name(id='b')),
&lt;/code>&lt;/pre>
&lt;p>o &lt;code>ast.Name(...&lt;/code> √© usado para referenciar as vari√°veis &lt;code>a&lt;/code> e &lt;code>b&lt;/code> da nossa fun√ß√£o.&lt;/p>
&lt;p>Ok, voltemos ao nosso problema. Lembre-se que uma solu√ß√£o ruim era reescrever cada fun√ß√£o que precisa ser decorada, por exemplo&lt;/p>
&lt;pre>&lt;code class="language-python">def func(x, y):
random_var = np.random.uniform()
... #more local vars
result = (x+y)**random_var
return result
&lt;/code>&lt;/pre>
&lt;p>como&lt;/p>
&lt;pre>&lt;code class="language-python">def func_transformed(x, y):
random_var = np.random.uniform()
... #more local vars
result = (x+y)**random_var
return result, locals
&lt;/code>&lt;/pre>
&lt;p>A coisa legal que faremos aqui √© &lt;strong>escrever uma fun√ß√£o que escrevera essas mudan√ßas para n√≥s! E depois colocaremos a compila√ß√£o dentro de um decorador para evitar que nossa codebase seja alterada.&lt;/strong>&lt;/p>
&lt;h2 id="como-metaprogramar-de-forma-eficiente">Como metaprogramar de forma eficiente?&lt;/h2>
&lt;p>Fazer um c√≥digo que fa√ßa as altera√ß√µes desejadas na nossa AST pode ser trabalhoso. Como come√ßar a ter uma ideia do que precisa ser feito? Eu penso em uma sucess√£o de 6 passos e ir iterando para melhorar&lt;/p>
&lt;h3 id="6-passos-simples">6 passos simples&lt;/h3>
&lt;ol>
&lt;li>Criar uma fun√ß√£o exemplo (A)&lt;/li>
&lt;li>Codar uma fun√ß√£o transformada do jeito que queremos que ela seja (B)&lt;/li>
&lt;li>Escrever um teste para que possa ser usado posteriormente para&lt;br>
checar se nossa fun√ß√£o transformada (B) bate com a fun√ß√£o gerada pela meta-programa√ß√£o (C)&lt;/li>
&lt;li>Extrair a AST de A e B&lt;/li>
&lt;li>Comparar as ASTs. O que elas diferem? Anote as diferen√ßas
&lt;ul>
&lt;li>Voc√™ pode usar a &lt;code>difflib&lt;/code> do python para fazer isso&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Criar uma nova e mais complexa fun√ß√£o exemplo (A) e repetir o processo at√© termos uma boa ideia das modifica√ß√µes necess√°rias na AST&lt;/li>
&lt;/ol>
&lt;h2 id="criando-nossa-meta-fun√ß√£o">Criando nossa meta-fun√ß√£o&lt;/h2>
&lt;h3 id="primeira-itera√ß√£o">Primeira itera√ß√£o&lt;/h3>
&lt;p>Come√ßaremos escrevendo uma fun√ß√£o incrivelmente simples&lt;/p>
&lt;pre>&lt;code class="language-python">def example_1(x, y):
internal_var = 222
result = (x+y)**internal_var
return result
def example_1_expected(x, y):
internal_var = 222
result = (x+y)**internal_var
return result, locals()
def test_meta_example_1(meta_func, x, y):
expected_result, expected_locals = example_1_expected(x, y)
result, locals_dict = meta_func(x, y)
assert result == expected_result
assert expected_locals == locals_dict
&lt;/code>&lt;/pre>
&lt;p>Agora usaseri a &lt;code>difflib&lt;/code> para entender as diferen√ßas entre as duas ASTs.&lt;/p>
&lt;pre>&lt;code class="language-python">import difflib
from pprint import pprint
example_1_ast_str = astor.dump_tree(ast.parse(inspect.getsource(example_1)))
example_1_expected_str = astor.dump_tree(ast.parse(inspect.getsource(example_1_expected)))
pprint(
list(
difflib.unified_diff(example_1_ast_str.splitlines(), example_1_expected_str.splitlines(), n=0)
)
)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>['--- \n',
'+++ \n',
'@@ -3 +3 @@\n',
&amp;quot;- FunctionDef(name='example_1',&amp;quot;,
&amp;quot;+ FunctionDef(name='example_1_expected',&amp;quot;,
'@@ -19 +19 @@\n',
&amp;quot;- Return(value=Name(id='result'))],&amp;quot;,
&amp;quot;+ Return(value=Tuple(elts=[Name(id='result'), &amp;quot;
&amp;quot;Call(func=Name(id='locals'), args=[], keywords=[])]))],&amp;quot;]
&lt;/code>&lt;/pre>
&lt;p>Com o output acima sabemos aogra que precisaremos mudar o seguinte n√≥ na AST&lt;/p>
&lt;pre>&lt;code>Return(value=Name(id='result'))],
&lt;/code>&lt;/pre>
&lt;p>para isto&lt;/p>
&lt;pre>&lt;code>Return(value=Tuple(elts=[Name(id='result'), Call(func=Name(id='locals'), args=[], keywords=[])]))],
&lt;/code>&lt;/pre>
&lt;p>Como alterar n√≥s na AST? Com a ajuda do &lt;code>NodeTransformer&lt;/code>&lt;/p>
&lt;h3 id="o-nodetransformer">O NodeTransformer&lt;/h3>
&lt;p>O &lt;code>ast.NodeTransformer&lt;/code> nos permite criar objetos com uma interface de caminhante. O caminhante visitar√° cada Node da AST e durante cada visita ele pode remover, substituir, modificar ou adicionar Nodes. Ap√≥s fazer essas altera√ß√µes o caminhante pode continuar sua caminhada nos filhos do Node ou apenas parar.&lt;/p>
&lt;p>Vamos iniciar criando uma classe derivada de &lt;code>ast.NodeTransformer&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-python">class ASTTransformer(ast.NodeTransformer):
def visit_Return(self, node):
&lt;/code>&lt;/pre>
&lt;p>Se queremos interagir com um n√≥ do tipo &lt;code>AlgumaCoisa&lt;/code> precisamos sobrescrever o m√©todo &lt;code>visit_AlgumaCoisa&lt;/code>.
Portanto, como sabemos que precisamos mudar o &lt;code>Return&lt;/code> iremos sobrescrever o &lt;code>visit_Return&lt;/code>. Precisaremos criar tamb√©m um n√≥ para pegar o &lt;code>locals&lt;/code>. Esse n√≥ √© o &lt;code>Call&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-python">class ASTTransformer(ast.NodeTransformer):
def visit_Return(self, node):
node_locals = ast.Call(
func=ast.Name(id='locals', ctx=ast.Load()),
args=[], keywords=[]
)
self.generic_visit(node)
return node
&lt;/code>&lt;/pre>
&lt;p>Veja que usamos o n√≥ &lt;code>Name&lt;/code> para identificar a fun√ß√£o &lt;code>locals&lt;/code>. Agora, de acordo com o resultado do nosso diff o resultado do &lt;code>Return&lt;/code> precisa ser uma n√≥ do tipo &lt;code>Tuple&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-python">class ASTTransformer(ast.NodeTransformer):
def visit_Return(self, node):
node_locals = ast.Call(
func=ast.Name(id='locals', ctx=ast.Load()),
args=[], keywords=[]
)
new_node.value = ast.Tuple(
elts=[
node.value,
node_locals
],
ctx=ast.Load()
)
self.generic_visit(new_node)
return new_node
&lt;/code>&lt;/pre>
&lt;p>Uma nova coisa apareceu. O argumento &lt;code>elts&lt;/code>. N√£o se preoucupe em entender tudo. Mas o &lt;code>elts&lt;/code> √© um arg que diz qual √© a lista de n√≥s que a Tupla deve conter. Toda vez que voc√™ quiser entender um pouco mais sobre ASTs e a gram√°tica do python voc√™ pode consultar a documenta√ß√£o oficial
&lt;a href="https://docs.python.org/3/library/ast.html" target="_blank" rel="noopener">aqui&lt;/a>.&lt;/p>
&lt;p>Quase tudo pronto. A √∫ltima coisa que precisamos fazer √© corrigir nossa AST. Pois ao alterar o Node precisamos preencher/corrigir as informa√ß√µes de line_number e column_offest. O python torna isso f√°cil com o m√©todo &lt;code>fix_missing_locations&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-python">
class ASTTransformer(ast.NodeTransformer):
def visit_Return(self, node):
new_node = node
node_locals = ast.Call(
func=ast.Name(id='locals', ctx=ast.Load()),
args=[], keywords=[]
)
new_node.value = ast.Tuple(
elts=[
node.value,
node_locals
],
ctx=ast.Load()
)
ast.copy_location(new_node, node)
ast.fix_missing_locations(new_node)
self.generic_visit(new_node)
return new_node
&lt;/code>&lt;/pre>
&lt;p>Ok, vamos ver se funcionou. Para isso, precisamos instanciar nosso transformer e chamar o m√©todo &lt;code>visit&lt;/code> que diz para o caminhante iniciar a caminhada e fazer as modifica√ß√µes pedidas&lt;/p>
&lt;pre>&lt;code class="language-python">tree_meta = ast.parse(inspect.getsource(example_1))
transformer = ASTTransformer()
transformer.visit(tree_meta)
example_1_meta_ast_str = astor.dump_tree(tree_meta)
example_1_expected_str = astor.dump_tree(ast.parse(inspect.getsource(example_1_expected)))
pprint(
list(
difflib.unified_diff(example_1_meta_ast_str.splitlines(), example_1_expected_str.splitlines(), n=0)
)
)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>['--- \n',
'+++ \n',
'@@ -3 +3 @@\n',
&amp;quot;- FunctionDef(name='example_1',&amp;quot;,
&amp;quot;+ FunctionDef(name='example_1_expected',&amp;quot;]
&lt;/code>&lt;/pre>
&lt;p>Funcionou! Vamos adicionar um pouco mais de complica√ß√£o para ver se o NodeTransformer continuar√° funcionando.&lt;/p>
&lt;h3 id="a-segunda-itera√ß√£o">A segunda itera√ß√£o&lt;/h3>
&lt;p>Seja criativo na hora de complicar, eu fiz isso aqui √© feio mais adiciona muita confus√£o para estressar o NodeTransformer.&lt;/p>
&lt;pre>&lt;code class="language-python">def example_2(x, y):
internal_var = 222
def sub(x, y):
ommit_this_var = 1
return x - y
result = sub(x,y)**internal_var
return (result, False)
def example_2_expected(x, y):
internal_var = 222
def sub(x, y):
ommit_this_var = 1
return x - y
result = sub(x,y)**internal_var
return ((result, False), locals())
def test_meta_example_2(meta_func, x, y):
expected_result, expected_locals = example_2_expected(x, y)
result, locals_dict = meta_func(x, y)
del locals_dict[&amp;quot;sub&amp;quot;]
del expected_locals[&amp;quot;sub&amp;quot;]
assert result == expected_result
assert expected_locals == locals_dict
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-python">example_2_ast_str = astor.dump_tree(ast.parse(inspect.getsource(example_2)))
example_2_expected_str = astor.dump_tree(ast.parse(inspect.getsource(example_2_expected)))
pprint(
list(
difflib.unified_diff(example_2_ast_str.splitlines(), example_2_expected_str.splitlines(), n=0)
)
)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>['--- \n',
'+++ \n',
'@@ -3 +3 @@\n',
&amp;quot;- FunctionDef(name='example_2',&amp;quot;,
&amp;quot;+ FunctionDef(name='example_2_expected',&amp;quot;,
'@@ -37 +37,4 @@\n',
&amp;quot;- Return(value=Tuple(elts=[Name(id='result'), &amp;quot;
'Constant(value=False, kind=None)]))],',
'+ Return(',
'+ value=Tuple(',
&amp;quot;+ elts=[Tuple(elts=[Name(id='result'), &amp;quot;
'Constant(value=False, kind=None)]),',
&amp;quot;+ Call(func=Name(id='locals'), args=[], &amp;quot;
'keywords=[])]))],']
&lt;/code>&lt;/pre>
&lt;p>Agora √© hora de cruzar os dedos e esperar que continue funcionando&lt;/p>
&lt;pre>&lt;code class="language-python">tree_meta = ast.parse(inspect.getsource(example_2))
transformer = ASTTransformer()
transformer.visit(tree_meta)
example_2_meta_ast_str = astor.dump_tree(tree_meta)
example_2_expected_str = astor.dump_tree(ast.parse(inspect.getsource(example_2_expected)))
pprint(
list(
difflib.unified_diff(example_2_meta_ast_str.splitlines(), example_2_expected_str.splitlines(), n=0)
)
)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>['--- \n',
'+++ \n',
'@@ -3 +3 @@\n',
&amp;quot;- FunctionDef(name='example_2',&amp;quot;,
&amp;quot;+ FunctionDef(name='example_2_expected',&amp;quot;,
'@@ -27,4 +27 @@\n',
'- Return(',
'- value=Tuple(',
&amp;quot;- elts=[BinOp(left=Name(id='x'), op=Sub, &amp;quot;
&amp;quot;right=Name(id='y')),&amp;quot;,
&amp;quot;- Call(func=Name(id='locals'), args=[], &amp;quot;
'keywords=[])]))],',
&amp;quot;+ Return(value=BinOp(left=Name(id='x'), op=Sub, &amp;quot;
&amp;quot;right=Name(id='y')))],&amp;quot;]
&lt;/code>&lt;/pre>
&lt;p>Falhou miseravelmente. Qual √© o problema? Se voc√™ olhar o &lt;code>diff&lt;/code> com cuidado ver√° que o &lt;code>NodeTransformer&lt;/code> alterou a fun√ß√£o interna. N√£o queremos isso. Portanto, diremos para o caminhante evitar modificar se estiver em uma fun√ß√£o interna. Para isso, precisamos sobrescrever o m√©todo &lt;code>visit_FunctionDef&lt;/code> e criar uma flag para marcar em que n√≠vel o caminhante est√°&lt;/p>
&lt;pre>&lt;code class="language-python">class ASTTransformer(ast.NodeTransformer):
def visit_FunctionDef(self, node):
if self._sub:
return node
self._sub = True
self.generic_visit(node)
return node
def visit_Module(self, node):
self._sub = 0
self.generic_visit(node)
def visit_Return(self, node):
new_node = node
node_locals = ast.Call(
func=ast.Name(id='locals', ctx=ast.Load()),
args=[], keywords=[]
)
new_node.value = ast.Tuple(
elts=[
node.value,
node_locals
],
ctx=ast.Load()
)
ast.copy_location(new_node, node)
ast.fix_missing_locations(new_node)
self.generic_visit(new_node)
return new_node
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-python">tree_meta = ast.parse(inspect.getsource(example_2))
transformer = ASTTransformer()
transformer.visit(tree_meta)
example_2_meta_ast_str = astor.dump_tree(tree_meta)
example_2_expected_str = astor.dump_tree(ast.parse(inspect.getsource(example_2_expected)))
pprint(
list(
difflib.unified_diff(example_2_meta_ast_str.splitlines(), example_2_expected_str.splitlines(), n=0)
)
)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>['--- \n',
'+++ \n',
'@@ -3 +3 @@\n',
&amp;quot;- FunctionDef(name='example_2',&amp;quot;,
&amp;quot;+ FunctionDef(name='example_2_expected',&amp;quot;]
&lt;/code>&lt;/pre>
&lt;p>Tudo ok! Pr√≥ximo passo: compilar nossa ast.&lt;/p>
&lt;h3 id="criando-uma-nova-fun√ß√£o-em-runtime">Criando uma nova fun√ß√£o em runtime&lt;/h3>
&lt;p>O que faremos agora √© compilar a AST transformada e associa-la com uma nova fun√ß√£o. Em python podemos fazer isso em tempo de execu√ß√£o com &lt;code>type.FunctionType&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-python">from types import FunctionType, CodeType
def transform_and_compile(func: FunctionType)-&amp;gt;FunctionType:
source = inspect.getsource(func)
# we put this to remove the line from source code with the decorator
source = &amp;quot;\n&amp;quot;.join([l for l in source.splitlines() if not l.startswith(&amp;quot;@&amp;quot;)])
tree = ast.parse(source)
transformer = ASTTransformer()
transformer.visit(tree)
code_obj = compile(tree, func.__code__.co_filename, 'exec')
function_code = [c for c in code_obj.co_consts if isinstance(c, CodeType)][0]
# we must to pass the globals context to the function
transformed_func = FunctionType(function_code, func.__globals__)
return transformed_func
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-python">test_meta_example_1(transform_and_compile(example_1), 4, 2)
test_meta_example_2(transform_and_compile(example_2), 1, 2)
&lt;/code>&lt;/pre>
&lt;p>Veja que &lt;code>transform_and_compile&lt;/code> foi capaz de criar novas fun√ß√µes que passaram nos testes que escrevemos nas itera√ß√µes anteriores! Agora √© o passo final e mais f√°cil desse post. Integrar com o decorador.&lt;/p>
&lt;h2 id="integrando-a-manipula√ß√£o-de-ast-com-um-decorador">Integrando a manipula√ß√£o de AST com um decorador&lt;/h2>
&lt;p>O que faremos √© chamar &lt;code>transform_and_compile&lt;/code> logo ap√≥s o &lt;code>def decorate&lt;/code> para evitar compila√ß√µes desnecess√°rias toda vez que chamarmos a fun√ß√£o decorada&lt;/p>
&lt;pre>&lt;code class="language-python">def report(fmt):
def decorate(func):
meta_func = transform_and_compile(func)
....
&lt;/code>&lt;/pre>
&lt;p>Agora, dentro de &lt;code>def decorated&lt;/code> podemos chamar a &lt;code>meta_func&lt;/code> e retornar s√≥ o resultado pois n√£o queremos mudar nossa codebase&lt;/p>
&lt;pre>&lt;code class="language-python">def report(fmt):
def decorate(func):
meta_func = transform_and_compile(func)
...
def decorated(*_args):
_result, internal_locals = meta_func(*_args)
....
return _result
&lt;/code>&lt;/pre>
&lt;p>Com todas as coisas que fizemos no post nosso decorador &lt;code>report&lt;/code> est√° pronto para ser usado&lt;/p>
&lt;pre>&lt;code class="language-python">
def report(fmt):
def decorate(func):
meta_func = transform_and_compile(func)
sig = inspect.signature(func)
def decorated(*_args):
_result, internal_locals = meta_func(*_args)
named_args = {}
num_args = len(_args)
for i, (k, v) in enumerate(sig.parameters.items()):
if i &amp;lt; num_args:
named_args[k] = repr(_args[i])
else:
named_args[k] = repr(v.default)
name = func.__name__
result = repr(_result)
args_dict = {
**internal_locals,
**locals(),
**named_args
}
print(fmt.format(**args_dict))
# store the information in some place
return result
return decorated
return decorate
&lt;/code>&lt;/pre>
&lt;p>Veja o resultado em uma fun√ß√£o bem simples&lt;/p>
&lt;pre>&lt;code class="language-python">@report(fmt='{name}(a={a}, b={b}, c={c}); sum_ab {sum_ab}, diff_ab {dif_ab}; r={result}')
def dummy_example(a, b, c=2):
sum_ab = a + b
dif_ab = a - b
r = sum_ab**c + dif_ab**c
return r
r = dummy_example(2, 3, 1)
print(&amp;quot;r:&amp;quot;, r)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code> dummy_example(a=2, b=3, c=1); sum_ab 5, diff_ab -1; r=4
r: 4
&lt;/code>&lt;/pre>
&lt;p>Eu sei que esse post pode ter sido dif√≠cil, se tiver d√∫vida voc√™ pode entrar em contato comigo pelos coment√°rios abaixo, twitter ou linkedin. Compartilhe se voc√™ gostou.&lt;/p></description></item></channel></rss>