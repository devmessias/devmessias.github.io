<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>data analysis | Bruno Messias</title>
    <link>/tag/data-analysis/</link>
      <atom:link href="/tag/data-analysis/index.xml" rel="self" type="application/rss+xml" />
    <description>data analysis</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en</language><lastBuildDate>Tue, 15 Feb 2022 15:48:33 -0300</lastBuildDate>
    <image>
      <url>/images/icon_hucd6a3d413e7b81060a1d462b35f64cf9_5018_512x512_fill_lanczos_center_3.png</url>
      <title>data analysis</title>
      <link>/tag/data-analysis/</link>
    </image>
    
    <item>
      <title>Removendo arestas em um grafo: estatístico, threshold e espectral. Parte I</title>
      <link>/post/edge_graph_filtering/</link>
      <pubDate>Tue, 15 Feb 2022 15:48:33 -0300</pubDate>
      <guid>/post/edge_graph_filtering/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;Table of Contents&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#o-que-é-um-grafo&#34;&gt;O que é um grafo?&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#o-que-é-filtragem-por-que-filtrar-um-dado&#34;&gt;O que é filtragem? Por que filtrar um dado?&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#filtrar-para-remover-ruídos&#34;&gt;Filtrar para remover ruídos&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#filtrar-para-ressaltar-características-e-os--princípios-de-gestalt&#34;&gt;Filtrar para ressaltar características e os  princípios de &lt;em&gt;Gestalt&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#reduzindo-custo-computacional-por-filtragem&#34;&gt;Reduzindo custo computacional por filtragem&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#o-que-é-um-processo-de-filtragem-em-um-grafo&#34;&gt;O que é um processo de filtragem em um grafo?&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#algumas-propriedades-de-grafos&#34;&gt;Algumas propriedades de grafos&lt;/a&gt;
          &lt;ul&gt;
            &lt;li&gt;&lt;a href=&#34;#componentes-e-comunidades&#34;&gt;Componentes e Comunidades&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&#34;#matrizes-associadas-a-um-grafo-e-propriedades-espectrais&#34;&gt;Matrizes associadas a um grafo e propriedades espectrais&lt;/a&gt;&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#1-threshold&#34;&gt;1-Threshold&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#pontos-positivos&#34;&gt;Pontos positivos&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#pontos-negativos&#34;&gt;Pontos negativos&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#2-estatístico-disparidade&#34;&gt;2-Estatístico: disparidade&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#pontos-positivos-1&#34;&gt;Pontos positivos&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#pontos-negativos-1&#34;&gt;Pontos negativos&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#3-espectral&#34;&gt;3-Espectral&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#pontos-positivos-2&#34;&gt;Pontos positivos&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#pontos-negativos-2&#34;&gt;Pontos negativos&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#heading&#34;&gt;&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#conclusão&#34;&gt;Conclusão&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Grafos,  redes e redes complexas são praticamente o mesmo conceito. Portanto, você pode encontrar termos como &lt;em&gt;filtering edges on complex networks&lt;/em&gt;.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Quando olhamos uma imagem temos a tendência de procurar padrões  o que reduz o esforço e tempo necessário para identificar do que se trata. Em análise de dados aplicamos filtros com a mesma motivação, seja para remover dados espúrios ou focar nossa análise em um conjunto específico.&lt;/p&gt;
&lt;p&gt;Enquanto o processo de filtragem  em um conjunto de pontos é apresentado em cursos  acadêmicos e tutoriais na internet o mesmo não pode ser dito em relação a grafos.  Portanto, criei  esse post para discutir o conceito de filtragem e padrões em grafos e as diferentes maneiras de se obter tal filtragem. Tentei ser didático o suficiente para que uma pessoa fora da computação ou exatas (que esteja iniciando em dados) consiga comprender o texto.&lt;/p&gt;
&lt;p&gt;Fiz alguns exemplos  usando python e as seguintes bibliotecas:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ python3 -m pip install numpy matplotlib networkx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Sinta-se a vontade para pular qualquer seção do post :)&lt;/p&gt;
&lt;h2 id=&#34;o-que-é-um-grafo&#34;&gt;O que é um grafo?&lt;/h2&gt;
&lt;p&gt;Um grafo é uma estrutura de dados que  você constantemente  está em contato. Alguns exemplos: sua rede de seguidores e seguidos no twitter, as  transações financeiras associadas a sua chave PIX, as relações de repositório e contribuições no github, etc.&lt;/p&gt;
&lt;p&gt;Um grafo armazena objetos que tem relações pares a pares entre si. Sendo que é possível associar a cada objeto ou relação um outro tipo de dado genérico tais como um número real, um vetor, imagem ou mesmo outro grafo.&lt;/p&gt;
&lt;p&gt;A imagem abaixo representa um grafo dirigido formado por 4 vértices.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph TD;
  A--&amp;gt;B;
  B--&amp;gt;A;
  A--&amp;gt;C;
  B--&amp;gt;D;
  C--&amp;gt;D;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vamos usar a letra $G$ para representar um grafo, $V$ para o conjunto de vértices (objetos) e $E$ para o conjunto de arestas (relações). Na imagem acima nosso grafo seria dado então pelo conjunto $V=\{A,B,C,D\}$  e $E=\{(A,B), (B,A), (A,C), (B,D), (C,D)\}$.&lt;/p&gt;
&lt;p&gt;Como disse  no início dessa seção é possível associar &lt;em&gt;coisas&lt;/em&gt; tanto as arestas quanto aos vértices.  Por exemplo, o grafo abaixo poderia representar transações financeiras entre 3 pessoas e o valor que cada uma tem em sua conta corrente&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph RL;
  A[A R\$100,00]--&amp;gt;|R\$1|B;
  B[B R\$3,00]--&amp;gt;|R\$2|A;
  C[C R\$0]--&amp;gt;|R\$0,50|A;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Tais grafos de transações financeiras são usados por exemplo para detectar crimes de lavagem de dinheiro, formação de quadrilhas e fraudes quando o comportamento de um dado cliente é anómalo.&lt;/p&gt;
&lt;h2 id=&#34;o-que-é-filtragem-por-que-filtrar-um-dado&#34;&gt;O que é filtragem? Por que filtrar um dado?&lt;/h2&gt;
&lt;p&gt;Filtro tem origem na palavra feltro. O feltro era o material feito de lã e algodão  usado antigamente para separar um liquido de suas impurezas. Um filtro em análise de dados é a mesma coisa: uma ferramenta que separa um conjunto de dados de uma sujeira, ruído. Portanto, assim como para filtrar uma bebida temos que decidir antes algumas coisas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;O que queremos que seja removido?&lt;/li&gt;
&lt;li&gt;O quão eficiente é nosso fitro?&lt;/li&gt;
&lt;li&gt;Qual é o resultado esperado?&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;filtrar-para-remover-ruídos&#34;&gt;Filtrar para remover ruídos&lt;/h3&gt;
&lt;p&gt;Talvez a primeira coisa que vem a sua cabeça quando  ouve a palavra filtro é Instagram. Alguns filtros de fotos feitos para embelezar nada mais são que um filtro para remoção de ruídos.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-imagem-original-e-imagem-com-contaminação-de-um-ruído&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/edge_graph_filtering/photo_noisy_hub8a9241becf562a36f81d7ad5959569c_1551080_2000x2000_fit_lanczos_3.png&#34; data-caption=&#34;Imagem original e imagem com contaminação de um ruído.&#34;&gt;


  &lt;img data-src=&#34;/post/edge_graph_filtering/photo_noisy_hub8a9241becf562a36f81d7ad5959569c_1551080_2000x2000_fit_lanczos_3.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1600&#34; height=&#34;800&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Imagem original e imagem com contaminação de um ruído.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;O que considerámos ruído depende das respostas das perguntas que levantei anteriormente. Um ruído em uma imagem pode ser uma contribuição espúria devido ao sensor de uma câmera ser ruim o que acaba alterando os valores de cores de cada pixel. Um ruído pode ser também algo intrísseco, por exemplo os poros e rugas na sua pele.&lt;/p&gt;
&lt;h3 id=&#34;filtrar-para-ressaltar-características-e-os--princípios-de-gestalt&#34;&gt;Filtrar para ressaltar características e os  princípios de &lt;em&gt;Gestalt&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;Os princípios de &lt;em&gt;Gestalt&lt;/em&gt; é uma suposição de certas leis sobre como a mente humana processa imagens  através do reconhecimento de padrões. Em resumo, tal princípio estabelece que a percepção não é baseada em elementos indivíduais mas em padrões  em que os elementos são arranjados ou tem contrastes entre-si. &lt;strong&gt;Você não compreende uma imagem analisando cada pixel individualmente, mas como os pixels se organizam e diferem entre-si!&lt;/strong&gt;&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-os-principios-da-gestalt-são-apresentados-nessa-figura-para-mais--informações-recomendo-esse-post-&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/edge_graph_filtering/gestalt_principles_hu63f5cabf0d008b5b0b2fbf74c03a67fd_175876_2000x2000_fit_q90_lanczos.jpg&#34; data-caption=&#34;Os principios da &amp;lt;em&amp;gt;Gestalt&amp;lt;/em&amp;gt; são apresentados nessa figura. Para mais  informações recomendo esse post [].&#34;&gt;


  &lt;img data-src=&#34;/post/edge_graph_filtering/gestalt_principles_hu63f5cabf0d008b5b0b2fbf74c03a67fd_175876_2000x2000_fit_q90_lanczos.jpg&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;1920&#34; height=&#34;1080&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Os principios da &lt;em&gt;Gestalt&lt;/em&gt; são apresentados nessa figura. Para mais  informações recomendo esse post [].
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;Como se relaciona com grafos? Um dos porquês para realizar a filtragem de um grafo consiste em remover relações (arestas)  mesmo que não espúrias para ressaltar um dado padrão que queremos analisar. Comumente, esse padrão são estruturas de comunidades e agrupamentos geradas por métodos de visualização.&lt;/p&gt;





  
  











&lt;figure id=&#34;figure-os-princípios-da-gestalt-são-usados-para-desenvolver-métodos-de-processamento-de-imagens-imagem-retirada-de-&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/edge_graph_filtering/gestalt_cv_example_hucab709b1511f3355857a308628efbe49_158058_2000x2000_fit_lanczos_3.png&#34; data-caption=&#34;Os princípios da &amp;lt;em&amp;gt;Gestalt&amp;lt;/em&amp;gt; são usados para desenvolver métodos de processamento de imagens. Imagem retirada de []&#34;&gt;


  &lt;img data-src=&#34;/post/edge_graph_filtering/gestalt_cv_example_hucab709b1511f3355857a308628efbe49_158058_2000x2000_fit_lanczos_3.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;652&#34; height=&#34;225&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Os princípios da &lt;em&gt;Gestalt&lt;/em&gt; são usados para desenvolver métodos de processamento de imagens. Imagem retirada de []
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;Na imagem acima é mostrado o resultado de um método baseado na &lt;em&gt;Gestalt&lt;/em&gt; para simplificar uma imagem. Em grafos temos o conceito de &lt;em&gt;backbones&lt;/em&gt; que são uma espécie de espinha dorsal, esqueleto, que representa as relações entres os vértices.&lt;/p&gt;
&lt;h3 id=&#34;reduzindo-custo-computacional-por-filtragem&#34;&gt;Reduzindo custo computacional por filtragem&lt;/h3&gt;
&lt;p&gt;Embora a filtragem possa ser usada para remover uma contaminação em um dado e/ou facilitar termos &lt;em&gt;insights&lt;/em&gt;  conseguimos também reduzir o custo computacional de algoritmos que atuam nesses dados. Um exemplo simples é mostrado no código abaixo:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import numpy as np
import io

X, Y = np.meshgrid(
    np.linspace(-5, 5, 100), np.linspace(-5, 5, 100))

z = np.exp(-0.1*(X**2 + Y**2))
z_noise = z + np.random.normal(0, 0.1, z.shape)

z = (z / z.max()*255).astype(np.uint8)
z_noise = (z_noise / z_noise.max()*255).astype(np.uint8)

data_noisy = io.BytesIO()
data = io.BytesIO()   
np.savez_compressed(data_noisy, z_noise)
np.savez_compressed(data, z)

print(f&amp;quot;Noisy {data_noisy.getbuffer().nbytes/10**6:.1f} MB&amp;quot;)
print(f&amp;quot;Original {data.getbuffer().nbytes/10**6:.1f} MB&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Noisy 3.6 MB
Original 0.2 MB
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O output indica que &lt;strong&gt;o resultado de contaminação por ruído aumenta o custo de armazenamento de um mesmo padrão de dados.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Em grafos,  filtrar para reduzir custo computacional costuma ser essencial. Por exemplo, muitos algorítimos  dependem escalam com o número de arestas. Portanto, um grafo em que cada par de vértices tem uma aresta teria custo computacional $O(numero\ \ de\ \ vértices^2)$ o que é impraticável para apenas algumas dezenas de milhares de vértices. Portanto, tornando a ánalise de dados inútil.&lt;/p&gt;
&lt;h2 id=&#34;o-que-é-um-processo-de-filtragem-em-um-grafo&#34;&gt;O que é um processo de filtragem em um grafo?&lt;/h2&gt;
&lt;p&gt;Vamos entrar agora no tema central do post. Mas antes é bom você ler com calma a seguinte desambiguação para que não fique perdido na literatura.&lt;/p&gt;
&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Desambiguação.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A área de processamento de sinais em grafos e a área de analise de redes sociais costumam usar termos distintos para a mesma coisa.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Graph coarsening&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;em ciência da computação:&lt;/em&gt; o processo de obter uma representação mais grosseira de um grafo removendo arestas e/ou vértices.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;outras disciplinas:&lt;/em&gt; termo não muito utilizado.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Edge filtering&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;em ciência da computação: o processo de aplicar um filtro (processamento de sinais) em valores definidos nas arestas. &lt;strong&gt;Uma filtragem nos valores associados as arestas!&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;outras disciplinas:&lt;/em&gt;  o processo de remover arestas que não se adequam a um dado padrão.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Graph sparsification&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;esse termo também costuma ser usado, mais por matemáticos e engenheiros. E pode representar tanto a remoção de vértices quanto arestas. Por exemplo: “spectral edge sparsification”. Contudo, é mais utilizado quando você parte de um grafo vazio (sem relações) e vai adicionando tentando preservar as propriedades espectrais do grafo original.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Você pode encontrar trabalhos com o termo  spectral filtering ou spectral coarsening , ambos significando a  mesma coisa. Contudo, spectral filters  costuma ser usado mais em trabalhos de processamento de sinal em grafos.&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Quando você aplica um filtro em uma foto para te deixar mais bonito você obviamente objetiva que as pessoas ainda te reconhençam. Isto é, as formas e aspectos mais importantes do seu rosto devem ser preservadas ou pouco alteradas. Vamos representar essas considerações por:
$$
\begin{eqnarray}
\mathcal P_{forma}(foto\ \ orignal) \sim \mathcal P_{forma}(foto\ \ filtrada)\newline
\mathcal P_{cor}(foto\ \ orignal) \sim \mathcal P_{cor}(foto\ \ filtrada)\newline
&amp;hellip;etc
\end{eqnarray}
$$
Também espera-se que  o ruído da câmera, rugas e imperfeições sejam reduzidas $\mathcal P_{rugas}(foto\ \ orignal) \neq \mathcal P_{rugas}(foto\ \ filtrada)$  e $|rugas\  \ foto \  \ original| \ll  |rugas\  \ foto \  \ filtrada|$.  O simbolo $|.|$ significa que estamos contando o número de rugas da foto, do conjunto de rugas, e $\ll$ significa muito menor.&lt;/p&gt;
&lt;p&gt;Da mesma maneira que no caso de fotos, se temos um grafo, $G$, queremos que sua versão filtrada, $\tilde G$, tenha uma ou mais  propriedades (definido de antemão) preservadas após efetuar a filtragem, isto é
$$
\mathcal P_{algo} (G) \sim \mathcal P_{algo} (\tilde G)
$$&lt;/p&gt;
&lt;p&gt;Sendo que o objetivo principal  costumar ser uma redução drástica no número de relações (arestas), $|E| \le |\tilde E|$. OK, então antes de entrar nos métodos de filtragem precisamos discorrer sobre quais seriam essas propriedades que queremos preservar.&lt;/p&gt;
&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;Diferente de uma imagem em que filtros só ocorrem nos valores definidos na posição dos pixels em um grafo podemos filtrar tanto os valores definidos nos vértices quando a própria estrutura do grafo em sí.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;filtrar a estrutura de um grafo $\neq$ filtrar valores definidos na estrutura de um grafo&lt;/li&gt;
&lt;/ul&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;algumas-propriedades-de-grafos&#34;&gt;Algumas propriedades de grafos&lt;/h3&gt;
&lt;h4 id=&#34;componentes-e-comunidades&#34;&gt;Componentes e Comunidades&lt;/h4&gt;
&lt;h5 id=&#34;componentes&#34;&gt;Componentes&lt;/h5&gt;
&lt;p&gt;Uma propriedade importante de um grafo é o número de componentes. Um grafo é fortemente conectado quando é possível sair de qualquer vértice e chegar em qualquer outro. &lt;strong&gt;Um grafo fortemente conectado tem apenas uma componente&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Por exemplo,  abaixo é apresentado um grafo fortemente conectado&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
  A---B;
  D---A;
  B---C
  A---C;
  D---E;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ao remover a aresta $(D , A)$ obtemos o seguinte grafo&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
  A---B;
  B---C
  A---C;
  D---E;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como é impossível sair de $D$ ou $E$ e chegar em $A$, $B$ ou $C$ após a disconexão o grafo não é mais fortemente conectado e tem duas componentes. Qual a relação disso com filtragem?&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;Esperamos que métodos de filtragem sejam bons em preservar o número de componentes. Pois isso afeta em muito  dinâmicas ocorrendo no grafo. Assim como algorítimos de análise de dados.&lt;/p&gt;
&lt;p&gt;Imagina se ao realizar uma filtragem você remova uma aresta que impede a contaminação por um vírus entre duas cidades no seu modelo?&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h5 id=&#34;comunidades&#34;&gt;Comunidades&lt;/h5&gt;
&lt;p&gt;Dentro de cada componente de um grafo temos o conceito de comunidade. Intuitivamente, quando pensamos em comunidade no ambito das relações pessoais imaginamos um grupo de pessoas que tem fortes relações entre si, muito mais fortes que as relações com outras pessoas fora do grupo. Por exemplo, família, colegas de trabalho etc. Nesse contexto qual é a tarefa de detecção de comunidades? Como efetuar tal tarefa?&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Em certos casos queremos que a filtragem não altere a identificação das estruturas de comunidade no nosso grafo.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Suponha que você queira modelar o grupo de pessoas pertecentes a dois partidos políticos,  opostos na ideologia. Você pode representar as relações entre as pessoas usando grafos. Colocando uma aresta entre uma pessoa e outra se elas concordaram majoritariamente em relação a um conjunto de questões. O que seria um algoritmo de detecção de comunidade em tal caso? Se temos o &lt;em&gt;ground thruth&lt;/em&gt;, isto é, o partido que cada pessoa se identifica, o algoritmo é uma caixa, $f$, que recebendo apenas as relações , $E$, gospe  um indíce  que associa cada pessoa um partido  $f: (Pesssoa, E) \mapsto \{Esquerda,Direita\}$. Mas como construir essa  $f$?  &lt;strong&gt;Na minha opinião existem três caminhos principais:&lt;/strong&gt;&lt;/p&gt;
&lt;h6 id=&#34;caminho-1-inferir&#34;&gt;&lt;strong&gt;Caminho 1: Inferir&lt;/strong&gt;&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;Pegue por exemplo a distribuição normal. Quando trabalhamos com dados que acreditamos que podem ser modelados por tal distribuição realizamos um processo de ajuste de parâmetros, tentando estimar a média e o desvio padrão da população. A ideia aqui é similar. Propõe-se um modelo generativo definido por um conjunto de parâmetros.. O objetivo é otimizar tais parâmetros tal que o modelo generativo seja um bom candidato para &lt;em&gt;gerador&lt;/em&gt; do grafo.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O modelo generativo mais famoso é conhecido como &lt;strong&gt;S&lt;/strong&gt;tocahastic  &lt;strong&gt;B&lt;/strong&gt;lock &lt;strong&gt;M&lt;/strong&gt;odel (&lt;strong&gt;SBM&lt;/strong&gt;).  Em português, Modelo de Bloco Estocástico. Usando o networkx você pode gerar uma amostra de um grafo através desse modelo usando o seguinte código&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import networkx as nx
import matplotlib.pyplot as plt

# esses são os parâmetros que definiram o número de indíviduos 
# dentro de cada comunidade
n1, n2, n3 = 30, 40, 60
# esses são os parâmetros que definem a probabilidade
# de conexão entre indivíduos da mesma comunidade
p11, p22, p33 = 0.4, 0.3, 0.7
# esses são os parâmetros que definem a probabilidade
# de conexão entre indíviduos de comunidades distintas
p12 = .01
p13 = .1
p23 = .01

sizes = [n1, n2, n3]
probs = [[p11, p12, p13], [p12, p22, p23], [p13, p23, p33]]

g_sbm = nx.stochastic_block_model(sizes, probs, seed=0)
W = nx.adjacency_matrix(g_sbm).todense()

plt.imshow(W)
plt.show()
&lt;/code&gt;&lt;/pre&gt;





  
  











&lt;figure id=&#34;figure-a-matriz-de-pesos-adjacência-pois-todos-os-pesos-são-1-do-grafo-gerado-por-nosso-modelo&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/edge_graph_filtering/adj_sbm_hu380ec109c1e87742774ae36834bf5302_53660_2000x2000_fit_lanczos_3.png&#34; data-caption=&#34;A matriz de pesos (adjacência pois todos os pesos são 1) do grafo gerado por nosso modelo.&#34;&gt;


  &lt;img data-src=&#34;/post/edge_graph_filtering/adj_sbm_hu380ec109c1e87742774ae36834bf5302_53660_2000x2000_fit_lanczos_3.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;286&#34; height=&#34;280&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    A matriz de pesos (adjacência pois todos os pesos são 1) do grafo gerado por nosso modelo.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;A ideia da inferência com o método mais simples de SBM  é a seguinte:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Extraia a matriz de adjacência de um grafo qualquer: uma rede social, uma rede de transações financeiras, etc.&lt;/li&gt;
&lt;li&gt;Pegue um SBM, com a matriz de peso tente estimar o número de partições, probabilidade de conexões intra e entre grupos e em qual bloco cada vértice pertence tal que os grafos gerados pelo SBM melhor represente o seu grafo original.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;O SBM é poderoso e ao contrário dos outros métodos te fornece uma maneira de checar a qualidade das comunidades encontradas. Isto é, se fazem sentido ou só são frutos de algo aleatório. Contudo, por ser uma técnica mais recente com uma implementação  difícil não são todas as bibliotecas que fornecem esse recurso. A biblioteca mais famosa para SBM é o &lt;code&gt;graph tool&lt;/code&gt; que consegue estimar comunidades para  grafos com centenas de milhares de vértices. Não poderei discorrer mais ou mostrar como usar o SBM pois é um tema bem  complexo.  Mas o importante agora é você ter conseguido absorver pelo menos a ideia.&lt;/p&gt;
&lt;h6 id=&#34;caminho-2-quantificardescrever&#34;&gt;&lt;strong&gt;Caminho 2: Quantificar&lt;/strong&gt;/Descrever&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;Você parte de um função $f$ qualquer. Exemplo, $f$ é uma função que identifica todo mundo como esquerda ou direita, um sorteio aleatório, etc.&lt;/li&gt;
&lt;li&gt;Com tal identificação você estipula uma grandeza que vai mensurar o quão forte é a coesão entre as pessoas de cada grupo e quão fraca é entre os grupos. Um exemplo de grandeza que mensura isso é a &lt;strong&gt;modularidade&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Você ira alterar a sua $f$ tentando maximizar tal grandeza.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O networkx por exemplo possui um método de maximização de modularidade usando um algoritmo guloso. Vamos usar o o grafo gerado pelo sbm para testar esse método usando o seguinte script:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from networkx.algorithms import community

def find_where(n, p):
    return [i for i in range(len(p)) if n in p[i]][0]

def plot(g, community_index, p):
    labels = [chr(ord(&#39;A&#39;) + i) for i in range(len(p))]

	plt.scatter(range(len(g.nodes)), community_index)
    plt.ylabel(&#39;Community&#39;)
    plt.xlabel(&#39;Vertex Id&#39;)
    plt.yticks(range(len(p)), labels)
    plt.show()

p = community.greedy_modularity_communities(g_sbm)
g_sbm_community_index = [find_where(n, p) for n in g_sbm.nodes]
print(f&amp;quot;Found {len(set(g_sbm_community_index))} communities&amp;quot;)

plot(g_sbm, g_sbm_community_index, p)
&lt;/code&gt;&lt;/pre&gt;





  
  











&lt;figure id=&#34;figure-resultado-da-identificação-de-comunidades-usando-o-algoritmo-guloso-parece-ok&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/edge_graph_filtering/modularity_sbm_hua729e93d844903006ce0633d9d38c615_6901_2000x2000_fit_lanczos_3.png&#34; data-caption=&#34;Resultado da identificação de comunidades usando o algoritmo guloso. Parece Ok&#34;&gt;


  &lt;img data-src=&#34;/post/edge_graph_filtering/modularity_sbm_hua729e93d844903006ce0633d9d38c615_6901_2000x2000_fit_lanczos_3.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;380&#34; height=&#34;265&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Resultado da identificação de comunidades usando o algoritmo guloso. Parece Ok
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;Temos um resultado muito bom. Mas será que podemos empregar isso em qualquer caso? Vejamos o que acontece quando aplicamos o mesmo algoritmo para um grafo aleatório.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# erdos_reyni é um modelo de grafo aleatório
g = nx.erdos_renyi_graph(150, 0.1, seed=0)
p = community.greedy_modularity_communities(g)
g_community_index = [find_where(n, p) for n in g.nodes]
plot(g, g_community_index, p)
&lt;/code&gt;&lt;/pre&gt;





  
  











&lt;figure id=&#34;figure-resultado-da-identificação-de-comunidades-usando-o-algoritmo-guloso-para-o-modelo-er&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/post/edge_graph_filtering/modularity_er_hua0225a683f6ec7064832fd57e19328a2_9455_2000x2000_fit_lanczos_3.png&#34; data-caption=&#34;Resultado da identificação de comunidades usando o algoritmo guloso para o modelo ER.&#34;&gt;


  &lt;img data-src=&#34;/post/edge_graph_filtering/modularity_er_hua0225a683f6ec7064832fd57e19328a2_9455_2000x2000_fit_lanczos_3.png&#34; class=&#34;lazyload&#34; alt=&#34;&#34; width=&#34;380&#34; height=&#34;265&#34;&gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Resultado da identificação de comunidades usando o algoritmo guloso para o modelo ER.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;O algoritmo guloso encontrou 4 comunidades e o ponto ruim é que não temos como saber o quão confiável é essa resposta. Mas podemos dizer que provavelmente ela não deveria ser usada pois partimos de um modelo de grafo aleatório.&lt;/p&gt;
&lt;h6 id=&#34;caminho-3-visualizar&#34;&gt;&lt;strong&gt;Caminho 3: Visualizar&lt;/strong&gt;&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;Você utiliza um método que mapeia  cada vértice do seu grafo em um espaço vetorial. Por exemplo &lt;strong&gt;t-sne&lt;/strong&gt;, &lt;strong&gt;UMAP&lt;/strong&gt;, &lt;strong&gt;force-directed&lt;/strong&gt;, etc. Com sua visualizção você realiza uma inspeção (totalmente subjetiva)  para identificar as comunidades (agrupamentos). Em alguns casos é aceitável realizar um k-means nesse espaço para encontrar os &lt;em&gt;clusters&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;strong&gt;Não existe uma única definição formal para comunidade. Esse conceito muda dependendo da abordagem que você escolheu para encontrar as comunidades dentro de cada componente&lt;/strong&gt;.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;É  importante ressaltar que devemos tomar muito cuidado com métodos de visualização e detecção por maximização de modularidade. Recomendo ver alguns trabalhos sobre modelos de bloco estocástico especialmente os feitos pelo Tiago Peixoto.&lt;/p&gt;
&lt;!-- &lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;New blog post! This time, on something tame and uncontroversial:&lt;br&gt;&lt;br&gt;&amp;quot;Modularity maximization considered harmful&amp;quot;&lt;br&gt;&lt;br&gt;It&amp;#39;s the most popular method used for community detection. It is also one of the most problematic. 1/11&lt;br&gt;&lt;br&gt;(Based on &lt;a href=&#34;https://t.co/iCxFjKOIT1&#34;&gt;https://t.co/iCxFjKOIT1&lt;/a&gt;)&lt;a href=&#34;https://t.co/IRdCFwttQL&#34;&gt;https://t.co/IRdCFwttQL&lt;/a&gt;&lt;/p&gt;&amp;mdash; Tiago Peixoto (@tiagopeixoto) &lt;a href=&#34;https://twitter.com/tiagopeixoto/status/1467798790346260484?ref_src=twsrc%5Etfw&#34;&gt;December 6, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
--&gt;
&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    &lt;strong&gt;Métodos de detecção de comunidade usando modularidade (Gelphi) são úteis. Contudo, podemos identificar comunidades mesmo no caso de um grafo totalmente aleatório!&lt;/strong&gt;.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;O tema de comunidades merece alguns posts separados para cada caminho, pois é um assunto denso e com debates e muitos métodos diferentes.&lt;/p&gt;
&lt;h4 id=&#34;matrizes-associadas-a-um-grafo-e-propriedades-espectrais&#34;&gt;Matrizes associadas a um grafo e propriedades espectrais&lt;/h4&gt;
&lt;p&gt;Sinto muito, mas o estudo de propriedades espectrais de um grafo é um tópico extremamente extenso.&lt;/p&gt;
&lt;p&gt;Pegue o seguinte grafo&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
  A---|1|B;
  B---|1/2|C;
  C---|2|A;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;podemos associar com esse grafo uma matriz $3\times 3$ onde as entradas da matriz representam os valores associados as arestas. Essa matriz é conhecida como matriz de pesos,&lt;/p&gt;
&lt;p&gt;$$
W=\begin{pmatrix}
- &amp;amp; A &amp;amp; B &amp;amp; C\\
A &amp;amp; 0 &amp;amp; 1 &amp;amp; 2\\
B &amp;amp; 1 &amp;amp; 0 &amp;amp; 1/2\\
C &amp;amp; 2 &amp;amp; 1/2 &amp;amp; 0
\end{pmatrix}
$$&lt;/p&gt;
&lt;p&gt;$$
v=\begin{pmatrix}
x\\
y\\
z
\end{pmatrix}
$$&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
  A[y+2z]---|1|B;
  B[x+1/2z]---|0.5|C;
  C[2x+0.5y]---|2|A;
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    A matriz pesos de um grafo pode ser pensada como uma generalização para combinar valores númericos.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;a href=&#34;/post/random_matrix_portfolio&#34;&gt;Variações do teorema do limite central para matrizes aleatórias&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-threshold&#34;&gt;1-Threshold&lt;/h2&gt;
&lt;p&gt;Esse com certeza é o método mais simples e mais rápido, embora o mais controverso. É aplicável somente se cada relação  (aresta) possuir um número real associado. O método de threshold consiste em descartar qualquer aresta cuja a função peso ultrapasse um dado valor.&lt;/p&gt;
&lt;p&gt;O método de threshold é muito utilizado em neurociência (com  críticas) e para análise de dados em  geral quando as arestas representam uma medida de correlação (Pearson) entre dois elementos. Como as medidas de correlações podem ser negativas é comum que o threshold seja aplicado no absoluto dos valores associados as arestas.&lt;/p&gt;
&lt;p&gt;Tome o seguinte grafo como exemplo:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
  A--&amp;gt;|-0.5|B;
  B--&amp;gt;|0.4|C
  C--&amp;gt;|2|A;
  D--&amp;gt;|-1|C;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ao realizar um threshold de $0.5$ iremos remover a relação $(B, C)$ e $(A,B )$. O grafo não é mais fortemente conectado.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR;
  C--&amp;gt;|2|A;
  D--&amp;gt;|-1|C;
  B;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;pontos-positivos&#34;&gt;Pontos positivos&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;custo computacional baixo $O(n)$
&lt;ul&gt;
&lt;li&gt;apenas iterar e comparar os valores.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;paralelizável&lt;/li&gt;
&lt;li&gt;trivial de implementar&lt;/li&gt;
&lt;li&gt;apenas um parâmetro&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pontos-negativos&#34;&gt;Pontos negativos&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;tendência de produzir muitas componentes desconectadas,&lt;/li&gt;
&lt;li&gt;parâmetro arbitrário,
&lt;ul&gt;
&lt;li&gt;chery-picking.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;remoção de uma aresta só depende do valor atribuído a ela.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-estatístico-disparidade&#34;&gt;2-Estatístico: disparidade&lt;/h2&gt;
&lt;h3 id=&#34;pontos-positivos-1&#34;&gt;Pontos positivos&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;é estabelecido dentro de uma formalização matemática robusta&lt;/li&gt;
&lt;li&gt;tenta evitar que o grafo se desconecte&lt;/li&gt;
&lt;li&gt;custo computacional baixo&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pontos-negativos-1&#34;&gt;Pontos negativos&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;podemos argumentar que o teste de hipótese é arbitrário&lt;/li&gt;
&lt;li&gt;parâmetro $\alpha$ precisa ser escolhido, embora mais robusto do que apenas o parâmetro de threshold&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-espectral&#34;&gt;3-Espectral&lt;/h2&gt;
&lt;p&gt;$$
(1-\epsilon)v^TLv \le v^TLv  \le (1+\epsilon)v^T Lv
$$&lt;/p&gt;
&lt;h3 id=&#34;pontos-positivos-2&#34;&gt;Pontos positivos&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;é estabelecido dentro de uma formalização matemática robusta&lt;/li&gt;
&lt;li&gt;dada as restrições garante preservar as propriedades estabelecidas&lt;/li&gt;
&lt;li&gt;muito utilizado para processamento de sinais em grafos&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pontos-negativos-2&#34;&gt;Pontos negativos&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;custo computacional geralmente elevado
&lt;ul&gt;
&lt;li&gt;alguns métodos espectrais tem custo $O(n^2)$ para cada iteração&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;muitas maneiras distintas de fazer para cada tipo de grafo e objetivo.
&lt;ul&gt;
&lt;li&gt;Se o grafo for direcionado ou não, se é livre de escala ou não, se tem um certo padrão específico de conexões, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading&#34;&gt;&lt;/h3&gt;
&lt;h2 id=&#34;conclusão&#34;&gt;Conclusão&lt;/h2&gt;
</description>
    </item>
    
  </channel>
</rss>
