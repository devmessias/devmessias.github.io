<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>nsbm | Bruno Messias</title><link>/tag/nsbm/</link><atom:link href="/tag/nsbm/index.xml" rel="self" type="application/rss+xml"/><description>nsbm</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en</language><copyright>Bruno Messias</copyright><lastBuildDate>Mon, 18 Apr 2022 00:00:00 +0000</lastBuildDate><image><url>/images/icon_hucd6a3d413e7b81060a1d462b35f64cf9_5018_512x512_fill_lanczos_center_2.png</url><title>nsbm</title><link>/tag/nsbm/</link></image><item><title>Grafos e modelo de blocos aninhados para matrizes de correla√ß√£o: clusteriza√ß√£o do mercado de a√ß√µes</title><link>/post/nsbm_sp500_stock_market_disparity_filter/</link><pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate><guid>/post/nsbm_sp500_stock_market_disparity_filter/</guid><description>&lt;details
class="toc-inpage d-print-none d-none d-sm-block d-md-none " open>
&lt;summary class="font-weight-bold">Table of Contents&lt;/summary>
&lt;nav id="TableOfContents">
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>&lt;a href="#introdu√ß√£o">Introdu√ß√£o&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#grafos">Grafos&lt;/a>&lt;/li>
&lt;li>&lt;a href="#matrizes-de-correla√ß√£o">Matrizes de correla√ß√£o&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#baixando-e-criando-nosso-grafo">Baixando e criando nosso grafo&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#extraindo-o-pre√ßo-de-fechamento">Extraindo o pre√ßo de fechamento&lt;/a>&lt;/li>
&lt;li>&lt;a href="#retorno-e-matrizes-de-correla√ß√£o">Retorno e matrizes de correla√ß√£o&lt;/a>&lt;/li>
&lt;li>&lt;a href="#criando-o-grafo-completo-e-filtrando">Criando o grafo completo e filtrando&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#nsbm-buscando-hierarquia-e-comunidades">nSBM: buscando hierarquia e comunidades&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#convertendo-o-igraph-em-graph-tool">Convertendo o iGraph em graph-tool&lt;/a>&lt;/li>
&lt;li>&lt;a href="#infer√™ncia-dos-blocos">Infer√™ncia dos blocos&lt;/a>&lt;/li>
&lt;li>&lt;a href="#como-analisar">Como analisar?&lt;/a>&lt;/li>
&lt;li>&lt;a href="#outras-aplica√ß√µes-de-nsbm">Outras aplica√ß√µes de nSBM&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#extras-mst">Extras: MST&lt;/a>
&lt;ul>
&lt;li>&lt;a href="#convertendo-correla√ß√µes-em-dist√¢ncias">Convertendo correla√ß√µes em dist√¢ncias&lt;/a>&lt;/li>
&lt;li>&lt;a href="#extraindo-o-mst">Extraindo o MST&lt;/a>&lt;/li>
&lt;li>&lt;a href="#visualizando-o-mst">Visualizando o MST&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="#agradecimentos">Agradecimentos&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/nav>
&lt;/details>
&lt;p>Esse post √© da s√©rie sobre filtragem em grafos (esparsifica√ß√£o). O post anterior pode ser acessado em:
&lt;a href="/post/edge_graph_filtering/" title="Grafos e filtragem de arestas I: conceitos e confus√µes.">Grafos e filtragem de arestas: conceitos e confus√µes.&lt;/a>&lt;/p>
&lt;p>O objetivo √© mostrar como usar o modelo de bloco estoc√°stico aninhado (nSBM) para o processo de an√°lise explorat√≥ria do mercado de a√ß√µes. O nSBM e SBM s√£o modelos n√£o-param√©tricos estabelecidos numa s√≥lida base estat√≠stica. Vou te ensinar na pr√°tica como usar eles no python e como analisar os outputs, que a primeira vista podem parecer art√≠sticos ou complexos. Veja s√≥:&lt;/p>
&lt;figure >
&lt;a data-fancybox="" href="/post/nsbm_sp500_stock_market_disparity_filter/nsbm_final_2018-01-01_2018-06-01_hudcff6362c16284ef400b42c5fe2e1b69_266080_0x500_resize_lanczos_2.png" >
&lt;img data-src="/post/nsbm_sp500_stock_market_disparity_filter/nsbm_final_2018-01-01_2018-06-01_hudcff6362c16284ef400b42c5fe2e1b69_266080_0x500_resize_lanczos_2.png" class="lazyload" alt="" width="100%" height="500px">
&lt;/a>
&lt;/figure>
&lt;p>A ordem que seguiremos nesse post √©:&lt;/p>
&lt;ol>
&lt;li>Uma introdu√ß√£o meio longa para te situar em grafos e o porqu√™ usar eles aqui.&lt;/li>
&lt;li>C√≥digo
&lt;ol>
&lt;li>Constru√ß√£o da matriz de correla√ß√£o entre os retornos dos ativos&lt;/li>
&lt;li>Filtragem da matriz de correla√ß√£o via um filtro de grafos&lt;/li>
&lt;li>Infer√™ncia e visualiza√ß√£o do nSBM&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Como analisar o nSBM?&lt;/li>
&lt;li>Extra: MST&lt;/li>
&lt;/ol>
&lt;p>Para reproduzir esse post recomendo usar um ambiente conda, pois uma das bibliotecas depende de diversas coisas al√©m de libs usais do python&lt;/p>
&lt;p>Comece checando se voc√™ tem as seguintes bibliotecas instaladas&lt;/p>
&lt;pre>&lt;code>matplotlib, pandas, yfinance
&lt;/code>&lt;/pre>
&lt;p>Instale o igraph com&lt;/p>
&lt;pre>&lt;code>$ pip install python-igraph
&lt;/code>&lt;/pre>
&lt;p>O graph-tool, do excelente
&lt;a href="https://twitter.com/tiagopeixoto" target="_blank" rel="noopener">Tiago Peixoto&lt;/a> via conda-forge&lt;/p>
&lt;pre>&lt;code>$ conda install -c conda-forge graph-tool
&lt;/code>&lt;/pre>
&lt;p>N√£o menos importante, voc√™ precisa instalar minha biblioteca de filtragem de grafos, o &lt;code>edgeseraser&lt;/code> deixe seu star
&lt;a href="https://github.com/devmessias/edgeseraser" target="_blank" rel="noopener">aqui&lt;/a> :).&lt;/p>
&lt;pre>&lt;code>$ pip install edgeseraser
&lt;/code>&lt;/pre>
&lt;h2 id="introdu√ß√£o">Introdu√ß√£o&lt;/h2>
&lt;p>An√°lise explorat√≥ria √© usada tanto como o objetivo final em si como uma ferramenta que fornece subs√≠dios para melhores tomadas de decis√µes para escolha de modelos preditivos ou pr√©-sele√ß√£o de inst√¢ncias para serem analisadas com mais detalhes.&lt;/p>
&lt;p>Contudo, muitas das t√©cnicas exploradas e ensinadas na web se restringem √†quelas que podem ser empregadas quando o conjunto de dados vive em algum espa√ßo organizado (como o $\mathbb R^n$) e cujos dados n√£o t√™m rela√ß√£o entre si. Um conjunto de pontos. Mas e os dados que n√£o se enquadram nisso?&lt;/p>
&lt;p>Um exemplo de conjunto de dados extremamente complicado s√£o as redes sociais. Redes sociais s√£o conjuntos de pessoas e a exist√™ncia de pelo menos rela√ß√µes pares a pares (hyper-grafos √© um assunto para outro post) podendo ser negativas, positivas ou algo mais complicado. Cada pessoa em uma rede social pode ser identificada por um conjunto de features tais como gostos pessoais, hor√°rio de uso do sistema, etc. Representar uma rede social por pontinhos √© reducionista. √â para isso que grafos podem ser empregados&lt;/p>
&lt;h3 id="grafos">Grafos&lt;/h3>
&lt;p>Um grafo armazena objetos que t√™m rela√ß√µes pares a pares entre si. Sendo poss√≠vel associar a cada objeto ou rela√ß√£o um outro tipo de dado gen√©rico tais como um n√∫mero real, um vetor ou mesmo outro grafo. Mas √© importante ressaltar que grafos est√£o em todo lugar, por exemplo em matrizes de correla√ß√£o. Portanto, usar grafos para analisar correla√ß√µes √© v√°lido, especialmente quando muitas dessas correla√ß√µes podem ou queremos que sejam descartadas.&lt;/p>
&lt;blockquote class="twitter-tweet">&lt;p lang="pt" dir="ltr">At√© onde j√° estudei, toda estrutura de dados pode ser representada como um grafo. Nesse sentido, podemos dizer que o grafo √© a &amp;quot;m√£e&amp;quot; de todas as estruturas de dados. Talvez dev√™ssemos dar mais foco a grafos nos cursos de EDs.&lt;/p>&amp;mdash; psiquiatra de computadores (üå≥, üå≥) (@coproduto) &lt;a href="https://twitter.com/coproduto/status/1514562359007842310?ref_src=twsrc%5Etfw">April 14, 2022&lt;/a>&lt;/blockquote>
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script>
&lt;h3 id="matrizes-de-correla√ß√£o">Matrizes de correla√ß√£o&lt;/h3>
&lt;p>No &lt;em>OpenCode&lt;/em> matrizes de correla√ß√£o j√° apareceram em diversos posts:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>
&lt;a href="https://opencodecom.net/post/2021-12-14-variacoes-do-teorema-central-do-limite-para-matrizes-aleatorias-de-nucleos-atomicos-a-filtragem-de-matrizes-de-correlaca/" target="_blank" rel="noopener">Varia√ß√µes do teorema central do limite para matrizes aleat√≥rias: de n√∫cleos at√¥micos a filtragem de matrizes de correla√ß√£o para constru√ß√£o de carteiras&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>
&lt;a href="https://opencodecom.net/post/2021-09-01-correlacao-entre-ativos-no-python/" target="_blank" rel="noopener">Correla√ß√£o entre Ativos no Python&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Mas o que √© uma matriz de correla√ß√£o se n√£o um conjunto de rela√ß√µes pares a pares com valores reais? Bom, ent√£o a quest√£o aqui fica evidente: &lt;strong>Uma matriz de correla√ß√£o pode ser analisada usando ferramentas feitas para analisar grafos! Ok, isso pode ser feito, mas voc√™ pode se perguntar o porqu√™ de fazer isso.&lt;/strong>&lt;/p>
&lt;p>Uma atividade muito comum quando exploramos matrizes de correla√ß√£o √© tentar encontrar grupos de elementos fortemente/fracamente correlacionados, isso n√£o √© uma tarefa trivial √† medida que o n√∫mero de elementos aumenta. Al√©m disso, √© comum jogarmos fora as rela√ß√µes que s√£o muito fracas. Quando fazemos isso estamos esparsificando a matriz, na terminologia de grafos estamos filtrando arestas!
&lt;a href="/post/edge_graph_filtering/#estrutural-threshold">No post anterior eu discuti o porqu√™ disso poder ser bem perigoso.&lt;/a>.&lt;/p>
&lt;p>Uma maneira mais elaborada de se analisar matrizes de correla√ß√£o √© atrav√©s da constru√ß√£o de
&lt;a href="https://www.youtube.com/watch?v=jMioOe2eTcY" target="_blank" rel="noopener">√°rvores de expans√£o m√≠nima (MST)&lt;/a>, apesar do nome complicado √© um processo bem simples de construir um grafo e voc√™ pode encontrar diversos tutoriais sobre MST e o mercado de a√ß√µes na internet.&lt;/p>
&lt;p>Devido a tutoriais com MST estarem j√° espalhados, decidi fazer algo diferente aqui e propor usar um m√©todo pouco conhecido para explora√ß√£o de grafos e aplicar ele em matrizes de correla√ß√£o de ativos. Esse m√©todo √© conhecido pela sigla &lt;em>nSBM&lt;/em>, modelo de bloco estoc√°stico aninhado (nested Stochastic Block Model) e √© um m√©todo n√£o-param√©trico para infer√™ncia de comunidades em grafos que permite analisar a hierarquia de comunidades.&lt;/p>
&lt;div class="alert alert-">
&lt;div>
No final do post vou mostrar a mesma matriz analisada pelo MST s√≥ para voc√™ ter uma ideia do porqu√™ o nSBM ser bem mais interessante.
&lt;/div>
&lt;/div>
&lt;p>Uma das grandes qualidades dos SBM e variantes √© que eles s√£o constru√≠dos em cima de um arcabou√ßo estat√≠stico rigoroso e ao mesmo tempo √© poss√≠vel detectar comunidades com pouqu√≠ssimos v√©rtices. Isso √© √≥timo, pois duas coisas que n√£o queremos √© que o m√©todo que escolhamos diga que certas coisas formam comunidades mesmo que n√£o passe de um amontoado de coisas aleat√≥rias e que ele bote coisas onde n√£o devia s√≥ porque s√£o pequenas demais, &lt;strong>isso √© uma cr√≠tica aos m√©todos de detec√ß√£o por maximiza√ß√£o de modularidade&lt;/strong>&lt;/p>
&lt;h2 id="baixando-e-criando-nosso-grafo">Baixando e criando nosso grafo&lt;/h2>
&lt;h3 id="extraindo-o-pre√ßo-de-fechamento">Extraindo o pre√ßo de fechamento&lt;/h3>
&lt;p>Vamos come√ßar importando o que for necess√°rio&lt;/p>
&lt;pre>&lt;code class="language-python">import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
import igraph as ig
from edgeseraser.disparity import filter_ig_graph
mpl.rcParams.update(_VSCode_defaultMatplotlib_Params)
plt.style.context('classic')
mpl.rcParams['figure.facecolor'] = 'white'
&lt;/code>&lt;/pre>
&lt;p>Usaremos uma tabela contendo os simbolos de um conjunto de ativos e os setores. O csv tem a seguinte organiza√ß√£o, e est√° dispon√≠vel
&lt;a href="https://raw.githubusercontent.com/datasets/s-and-p-500-companies/master/data/constituents.csv" target="_blank" rel="noopener">aqui&lt;/a>.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Symbol&lt;/th>
&lt;th>Name&lt;/th>
&lt;th>Sector&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>MMM&lt;/td>
&lt;td>3M&lt;/td>
&lt;td>Industrials&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>AOS&lt;/td>
&lt;td>A. O. Smith&lt;/td>
&lt;td>Industrials&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ABT&lt;/td>
&lt;td>Abbott Laboratories&lt;/td>
&lt;td>Health Care&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ABBV&lt;/td>
&lt;td>AbbVie&lt;/td>
&lt;td>Health Care&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;pre>&lt;code class="language-python">!wget https://raw.githubusercontent.com/datasets/s-and-p-500-companies/master/data/constituents.csv
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-python">df = pd.read_csv(&amp;quot;constituents.csv&amp;quot;)
all_symbols = df['Symbol'].values
all_sectors = df['Sector'].values
all_names = df['Name'].values
# Criaremos um dicion√°rio para mapear um simbolo para seu
# setor e uma cor
symbol2sector = dict(zip(all_symbols, all_sectors))
symbol2name = dict(zip(all_symbols, all_names))
&lt;/code>&lt;/pre>
&lt;p>Hora de baixar as informa√ß√µes sobre os ativos. Iremos computar as correla√ß√µes numa janela de um semestre.&lt;/p>
&lt;pre>&lt;code class="language-python">start_date = '2018-01-01'
end_date = '2018-06-01'
try:
prices = pd.read_csv(
f&amp;quot;sp500_prices_{start_date}_{end_date}.csv&amp;quot;, index_col=&amp;quot;Date&amp;quot;)
tickers_available = prices.columns.values
except FileNotFoundError:
df = yf.download(
list(all_symbols),
start=start_date,
end=end_date,
interval=&amp;quot;1d&amp;quot;,
group_by='ticker',
progress=True
)
tickers_available = list(
set([ticket for ticket, _ in df.columns.T.to_numpy()]))
prices = pd.DataFrame.from_dict(
{
ticker: df[ticker][&amp;quot;Adj Close&amp;quot;].to_numpy()
for ticker in tickers_available
}
)
prices.index = df.index
prices = prices.iloc[:-1]
del df
prices.to_csv(
f&amp;quot;sp500_prices_{start_date}_{end_date}.csv&amp;quot;)
&lt;/code>&lt;/pre>
&lt;h3 id="retorno-e-matrizes-de-correla√ß√£o">Retorno e matrizes de correla√ß√£o&lt;/h3>
&lt;p>A correla√ß√£o ser√° calculada para todos os ativos considerando o retorno. O retorno que estamos calculando aqui √© simplesmente a mudan√ßa percentual do pre√ßo de fechamento do ativo.&lt;/p>
&lt;pre>&lt;code class="language-python">returns_all = prices.pct_change()
# a primeira linha n√£o faz sentido, n√£o existe retorno no primeiro dia
returns_all = returns_all.iloc[1:, :]
returns_all.dropna(axis=1, thresh=len(returns_all.index)//2., inplace=True)
returns_all.dropna(axis=0, inplace=True)
symbols = returns_all.columns.values
&lt;/code>&lt;/pre>
&lt;p>Para calcular a correla√ß√£o √© f√°cil&lt;/p>
&lt;pre>&lt;code class="language-python"># plot the correlation matrix with ticks at each item
correlation_matrix = returns_all.corr()
plt.title(f&amp;quot;Correlation matrix from {start_date} to {end_date}&amp;quot;)
plt.imshow(correlation_matrix)
plt.colorbar()
plt.savefig(&amp;quot;correlation.png&amp;quot;, dpi=150)
plt.clf()
&lt;/code>&lt;/pre>
&lt;figure id="figure-matriz-de-correla√ß√£o-entre-ativos-do-sp500-para-o-primeiro-semestre-de-2018-sim-uma-bagun√ßa">
&lt;a data-fancybox="" href="/post/nsbm_sp500_stock_market_disparity_filter/correlation_hu6c68fc9d1aa2b5f7307017b57ffa4d90_521823_0x500_resize_lanczos_2.png" data-caption="Matriz de correla√ß√£o entre ativos do s&amp;amp;amp;p500 para o primeiro semestre de 2018. Sim, uma bagun√ßa!">
&lt;img data-src="/post/nsbm_sp500_stock_market_disparity_filter/correlation_hu6c68fc9d1aa2b5f7307017b57ffa4d90_521823_0x500_resize_lanczos_2.png" class="lazyload" alt="" width="100%" height="500px">
&lt;/a>
&lt;figcaption>
Matriz de correla√ß√£o entre ativos do s&amp;amp;p500 para o primeiro semestre de 2018. Sim, uma bagun√ßa!
&lt;/figcaption>
&lt;/figure>
&lt;p>Ok, voc√™ seria louco de analisar essa matriz manualmente. Vamos partir para o motivo desse post que √© usar nSBM.&lt;/p>
&lt;h3 id="criando-o-grafo-completo-e-filtrando">Criando o grafo completo e filtrando&lt;/h3>
&lt;p>Como queremos explorar as comunidades usaremos apenas as correla√ß√µes positivas,&lt;/p>
&lt;pre>&lt;code class="language-python">pos_correlation = correlation_matrix.copy()
# vamos considerar apenas as correla√ß√µes positivas pois queremos
# apenas as comunidades
pos_correlation[pos_correlation &amp;lt; 0.] = 0
# diagonal principal √© setada a 0 para evitar auto-arestas
np.fill_diagonal(pos_correlation.values, 0)
&lt;/code>&lt;/pre>
&lt;p>Agora basta construir o grafo n√£o direcionado associando os pesos das arestas com a correla√ß√£o entre os ativos.&lt;/p>
&lt;pre>&lt;code class="language-python">g = ig.Graph.Weighted_Adjacency(pos_correlation.values, mode='undirected')
# criamos uma feature symbol para cada v√©rtice
g.vs[&amp;quot;symbol&amp;quot;] = returns_all.columns
# o grafo pode estar desconectado. Portanto, extra√≠mos a componente gigante
cl = g.clusters()
g = cl.giant()
n_edges_before = g.ecount()
&lt;/code>&lt;/pre>
&lt;p>Agora iremos aplicar o
&lt;a href="/post/edge_graph_filtering/#estatistico" title="Grafos e filtragem de arestas I: conceitos e confus√µes. Filtro estat√≠stico">filtro de disparidade&lt;/a>
do edgeseraser para remover as arestas que n√£o s√£o significativas&lt;/p>
&lt;pre>&lt;code class="language-python">_ = filter_ig_graph(g, .25, cond=&amp;quot;both&amp;quot;, field=&amp;quot;weight&amp;quot;)
cl = g.clusters()
g = cl.giant()
n_edges_after = g.ecount()
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-python">print(f&amp;quot;Percentage of edges removed: {(n_edges_before - n_edges_after)/n_edges_before*100:.2f}%&amp;quot;)
print(f&amp;quot;Number of remained stocks: {len(symbols)}&amp;quot;)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>Percentage of edges removed: 95.76%
Number of remained stocks: 492
&lt;/code>&lt;/pre>
&lt;p>A maior parte das arestas foi removida. Ser√° que conseguimos fazer algo com esse grafo compactado?&lt;/p>
&lt;h2 id="nsbm-buscando-hierarquia-e-comunidades">nSBM: buscando hierarquia e comunidades&lt;/h2>
&lt;h3 id="convertendo-o-igraph-em-graph-tool">Convertendo o iGraph em graph-tool&lt;/h3>
&lt;p>O graph-tool √© um pacote com excelente desempenho, mas para ganhar essa performance ele
exige um pouquinho mais de trabalho tais como declarar o tipo dos dados. O primeiro
passo para usar o graph-tool √© converter nosso grafo iGraph para uma inst√¢ncia dele&lt;/p>
&lt;pre>&lt;code class="language-python">import graph_tool.all as gt
gnsbm = gt.Graph(directed=False)
# iremos adicionar os v√©rtices
for v in g.vs:
gnsbm.add_vertex()
# e as arestas
for e in g.es:
gnsbm.add_edge(e.source, e.target)
&lt;/code>&lt;/pre>
&lt;h3 id="infer√™ncia-dos-blocos">Infer√™ncia dos blocos&lt;/h3>
&lt;p>Com o grafo constru√≠do iremos executar o algoritmo de infer√™ncia de blocos.
Esse algoritmo executa uma minimiza√ß√£o do que √© conhecido como &lt;em>&amp;ldquo;description length&amp;rdquo;&lt;/em> do modelo Bayesiano. Em um post futuro falarei um pouco sobre a matem√°tica se voc√™ se j√° estiver interessado d√™ uma olhada no artigo original do Tiago Peixoto
&lt;a href="https://dx.doi.org/10.1103/PhysRevX.4.011047" target="_blank" rel="noopener">aqui&lt;/a>.&lt;/p>
&lt;pre>&lt;code class="language-python">state = gt.minimize_nested_blockmodel_dl(gnsbm)
&lt;/code>&lt;/pre>
&lt;p>O c√≥digo abaixo √© s√≥ para gerar as cores para nosso plot&lt;/p>
&lt;pre>&lt;code class="language-python">symbols = g.vs[&amp;quot;symbol&amp;quot;]
sectors = [symbol2sector[symbol] for symbol in symbols]
u_sectors = np.sort(np.unique(sectors))
u_colors = [plt.cm.tab10(i/len(u_sectors))
for i in range(len(u_sectors))]
# a primeira cor da lista era muito similar a segunda,
u_colors[0] = [0, 1, 0, 1]
sector2color = {sector: color for sector, color in zip(u_sectors, u_colors)}
rgba = gnsbm.new_vertex_property(&amp;quot;vector&amp;lt;double&amp;gt;&amp;quot;)
gnsbm.vertex_properties['rgba'] = rgba
for i, symbol in enumerate(symbols):
c = sector2color[symbol2sector[symbol]]
rgba[i] = [c[0], c[1], c[2], .5]
&lt;/code>&lt;/pre>
&lt;p>Executaremos o m√©todo draw para gerar o plot. O par√¢metro que talvez voc√™ queira brincar um pouco √© o $\beta \in (0, 1)$. Tal par√¢metro √© respons√°vel pela for√ßa do &lt;strong>edge-bundling&lt;/strong>, ou seja, a for√ßa com que as arestas ser√£o atra√≠das uma √† outra. Este par√¢metro tem finalidades apenas para facilitar a visualiza√ß√£o, n√£o existe nenhuma rela√ß√£o com o nSBM.&lt;/p>
&lt;pre>&lt;code class="language-python">options = {
'output': f'nsbm_{start_date}_{end_date}.png',
'beta': .9,
'bg_color': 'w',
#'output_size': (1500, 1500),
'vertex_color': gnsbm.vertex_properties['rgba'],
'vertex_fill_color': gnsbm.vertex_properties['rgba'],
'hedge_pen_width': 2,
'hvertex_fill_color': np.array([0., 0., 0., .5]),
'hedge_color': np.array([0., 0., 0., .5]),
'hedge_marker_size': 20,
'hvertex_size':20
}
state.draw(**options)
&lt;/code>&lt;/pre>
&lt;p>Finalmente, agora √© s√≥ ver o resultado da nossa filtragem e infer√™ncia&lt;/p>
&lt;pre>&lt;code class="language-python">plt.figure(dpi=150)
plt.title(f&amp;quot;Sectors of the S&amp;amp;P 500 from {start_date} to {end_date}&amp;quot;)
legend = plt.legend(
[plt.Line2D([0], [0], color=c, lw=10)
for c in list(sector2color.values())],
list(sector2color.keys()),
bbox_to_anchor=(1.05, 1),
loc=2,
borderaxespad=0.)
plt.imshow(plt.imread(f'nsbm_{start_date}_{end_date}.png'))
plt.xticks([])
plt.yticks([])
plt.axis('off')
plt.savefig(f'nsbm_final_{start_date}_{end_date}.png', bbox_inches='tight',
dpi=150, bbox_extra_artists=(legend,), facecolor='w', edgecolor='w')
plt.show()
&lt;/code>&lt;/pre>
&lt;figure id="figure-resultado-do-modelo-de-blocos-aninhados-para-o-primeiro-semestre-de-2018-de-ativos-do-sp500-art√≠stico">
&lt;a data-fancybox="" href="/post/nsbm_sp500_stock_market_disparity_filter/nsbm_final_2018-01-01_2018-06-01_hudcff6362c16284ef400b42c5fe2e1b69_266080_0x500_resize_lanczos_2.png" data-caption="Resultado do modelo de blocos aninhados para o primeiro semestre de 2018 de ativos do s&amp;amp;amp;p500. Art√≠stico?">
&lt;img data-src="/post/nsbm_sp500_stock_market_disparity_filter/nsbm_final_2018-01-01_2018-06-01_hudcff6362c16284ef400b42c5fe2e1b69_266080_0x500_resize_lanczos_2.png" class="lazyload" alt="" width="100%" height="500px">
&lt;/a>
&lt;figcaption>
Resultado do modelo de blocos aninhados para o primeiro semestre de 2018 de ativos do s&amp;amp;p500. Art√≠stico?
&lt;/figcaption>
&lt;/figure>
&lt;p>Ok, muito bonito! Conseguimos ver agrupamentos de certos setores, algumas misturas, muitas conex√µes entre o &lt;em>Financials&lt;/em> e &lt;em>Industrials&lt;/em>, etc. Se voc√™ n√£o consegue ver isso agora vou tentar te explicar como interpretar esse gr√°fico.&lt;/p>
&lt;h3 id="como-analisar">Como analisar?&lt;/h3>
&lt;figure >
&lt;a data-fancybox="" href="/post/nsbm_sp500_stock_market_disparity_filter/descripition_nsbm_sp500_hufe6166112f10aa58541f55447fe95bbb_1458779_0x500_resize_lanczos_2.png" >
&lt;img data-src="/post/nsbm_sp500_stock_market_disparity_filter/descripition_nsbm_sp500_hufe6166112f10aa58541f55447fe95bbb_1458779_0x500_resize_lanczos_2.png" class="lazyload" alt="" width="100%" height="500px">
&lt;/a>
&lt;/figure>
&lt;ul>
&lt;li>Cada c√≠rculo no conjunto que parece a escova de uma vassoura √© um ativo, um v√©rtice do grafo original.&lt;/li>
&lt;li>Cada escova √© uma comunidade de ativos. Podemos navegar na hierarquia seguindo o caminho reverso apontado pelas setinhas no grafo em preto. Veja que na imagem eu coloquei como exemplo tr√™s comunidades que pertencem √† mesma comunidade pai.
Uma coisa interessante que podemos observar √© que a maior parte dos ativos relacionados a &lt;strong>Consumer staples&lt;/strong> forma uma comunidade com &lt;strong>Real state&lt;/strong> e &lt;strong>Utilities&lt;/strong> no segundo n√≠vel.&lt;/li>
&lt;/ul>
&lt;p>E as arestas?&lt;/p>
&lt;ul>
&lt;li>Podemos notar que um grande n√∫mero de conex√µes entre &lt;strong>Financials&lt;/strong>, &lt;strong>Industrials&lt;/strong> e &lt;strong>Information technology&lt;/strong> sobreviveram ao filtro de disparidade. Sendo um indicativo que esses ativos t√™m uma forte rela√ß√£o nos retornos.
Ok, antes eu falei que o $\beta$ controla o efeito de atra√ß√£o entre as arestas, veja o que acontece se eu reduzir o $\beta$ para $0.5$:&lt;/li>
&lt;/ul>
&lt;figure id="figure-horr√≠vel-n√£o-√©-mesmo">
&lt;a data-fancybox="" href="/post/nsbm_sp500_stock_market_disparity_filter/nsbm_2018-01-01_2018-06-01_beta_0.5_hu63a031e361e4cd7a15f51f9db9995b63_1589031_0x400_resize_lanczos_2.png" data-caption="Horr√≠vel n√£o √© mesmo?">
&lt;img src="/post/nsbm_sp500_stock_market_disparity_filter/nsbm_2018-01-01_2018-06-01_beta_0.5_hu63a031e361e4cd7a15f51f9db9995b63_1589031_0x400_resize_lanczos_2.png" alt="" height="400px">
&lt;/a>
&lt;figcaption>
Horr√≠vel n√£o √© mesmo?
&lt;/figcaption>
&lt;/figure>
&lt;p>Voc√™ tamb√©m pode explorar o resultado do nSBM manualmente. Para obter um sum√°rio da hierarquia das comunidades obtidas pelo nSBM podemos invocar o m√©todo &lt;code>print_summary&lt;/code>&lt;/p>
&lt;pre>&lt;code class="language-python">state.print_summary()
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>l: 0, N: 483, B: 25
l: 1, N: 25, B: 6
l: 2, N: 6, B: 2
l: 3, N: 2, B: 1
l: 4, N: 1, B: 1
&lt;/code>&lt;/pre>
&lt;p>No n√≠vel de folhas temos os ativos. No primeiro n√≠vel temos &lt;strong>21&lt;/strong> comunidades para os &lt;strong>11&lt;/strong> setores.&lt;/p>
&lt;p>Supondo que voc√™ queira obter quais comunidades um dado ativo pertence, no caso &amp;ldquo;TSLA&amp;rdquo;,&lt;/p>
&lt;pre>&lt;code class="language-python"># esse √© o indice da TSLA no nosso grafo original
symbol = &amp;quot;TSLA&amp;quot;
index_tesla = symbols.index(symbol)
symbol, symbol2sector[symbol], symbol2name[symbol]
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>('TSLA', 'Consumer Discretionary', 'Tesla')
&lt;/code>&lt;/pre>
&lt;p>Para obter as comunidades que o TSLA pertence percorremos a hierarquia de baixo para cima, at√© a raiz&lt;/p>
&lt;pre>&lt;code class="language-python"># para obter os indices
r0 = state.levels[0].get_blocks()[index_tesla]
r1 = state.levels[1].get_blocks()[r0]
r2 = state.levels[2].get_blocks()[r1]
r3 = state.levels[3].get_blocks()[r2]
(r1, r2, r3)
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>(19, 0, 0)
&lt;/code>&lt;/pre>
&lt;p>Voc√™ pode explorar as comunidades usando essa abordagem. Contudo, eu recomendo voc√™ usar o THREE.js ou D3 para realizar essa explora√ß√£o. Futuramente disponibilizarei meu c√≥digo para permitir uma visualiza√ß√£o interativa do nsbm usando threejs direto no browser!&lt;/p>
&lt;h3 id="outras-aplica√ß√µes-de-nsbm">Outras aplica√ß√µes de nSBM&lt;/h3>
&lt;p>nSBM&amp;rsquo;s e SBM&amp;rsquo;s encontram diversas aplica√ß√µes como
&lt;a href="https://www.science.org/doi/10.1126/sciadv.aaq1360" target="_blank" rel="noopener">NLP&lt;/a> e em um trabalho recente meu em an√°lise de
&lt;a href="https://arxiv.org/abs/2110.01421" target="_blank" rel="noopener">surveys&lt;/a>.
&lt;figure id="figure-um-jaba-pr√≥prio-nsbm-do-censo-escolar-pense">
&lt;a data-fancybox="" href="/post/nsbm_sp500_stock_market_disparity_filter/allDummyAUC_alpha=0-05_hu1c20d905c5634e6a84f02ee440a1f7e5_1616945_0x400_resize_lanczos_2.png" data-caption="Um jaba pr√≥prio. nSBM do censo escolar PeNSE.">
&lt;img src="/post/nsbm_sp500_stock_market_disparity_filter/allDummyAUC_alpha=0-05_hu1c20d905c5634e6a84f02ee440a1f7e5_1616945_0x400_resize_lanczos_2.png" alt="" height="400px">
&lt;/a>
&lt;figcaption>
Um jaba pr√≥prio. nSBM do censo escolar PeNSE.
&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h2 id="extras-mst">Extras: MST&lt;/h2>
&lt;p>Eu prometi mostrar como ficaria o mesmo universo de dados usando MST (√°rvores de expans√£o m√≠nima). A intui√ß√£o por tr√°s do MST √© que queremos construir um grafo esparso de um grafo original, tal que as somas dos pesos das arestas seja a menor poss√≠vel sem desconectar os v√©rtices do grafo. Veja mais aprofundado
&lt;a href="https://hudsonthames.org/networks-with-mlfinlab-minimum-spanning-tree-mst/" target="_blank" rel="noopener">aqui&lt;/a>.&lt;/p>
&lt;h3 id="convertendo-correla√ß√µes-em-dist√¢ncias">Convertendo correla√ß√µes em dist√¢ncias&lt;/h3>
&lt;p>A primeira coisa que precisamos fazer √© converter a matriz de correla√ß√£o em uma matriz de dist√¢ncia. Isso pode ser feito usando a seguinte fun√ß√£o&lt;/p>
&lt;p>$d(\mathrm{stock}_1, \mathrm{stock}_2) = \sqrt{2(1-\mathrm{corr}(\mathrm{stock_1}, \mathrm{stock}_2))}$&lt;/p>
&lt;pre>&lt;code class="language-python">dist_matrix = np.sqrt(2*(1-correlation_matrix))
dist_matrix = dist_matrix.fillna(0)
np.fill_diagonal(dist_matrix.values, 0)
&lt;/code>&lt;/pre>
&lt;h3 id="extraindo-o-mst">Extraindo o MST&lt;/h3>
&lt;p>O &lt;code>igraph&lt;/code> j√° implementa um algoritmo para extrair o MST de um grafo de forma eficiente, mesmo que o grafo seja completo. Nossa matriz de correla√ß√£o √© um grafo completo!&lt;/p>
&lt;pre>&lt;code class="language-python">
g = ig.Graph.Weighted_Adjacency(dist_matrix.values, mode='undirected')
g = g.spanning_tree(weights=&amp;quot;weight&amp;quot;, return_tree=True)
g.vs[&amp;quot;symbol&amp;quot;] = returns_all.columns
sectors = [symbol2sector[symbol] for symbol in returns_all.columns]
colors = [
sector2color[sector] for sector in sectors
]
&lt;/code>&lt;/pre>
&lt;h3 id="visualizando-o-mst">Visualizando o MST&lt;/h3>
&lt;p>Agora com nosso MST vamos usar um layout de grafos bem simples para visualizar nosso grafo&lt;/p>
&lt;pre>&lt;code class="language-python">g.vs[&amp;quot;color&amp;quot;] = colors
pos = g.layout_fruchterman_reingold(niter=10000, weights=&amp;quot;weight&amp;quot;)
pos = np.array(pos.coords)
&lt;/code>&lt;/pre>
&lt;p>Finalmente, nosso resultado:&lt;/p>
&lt;pre>&lt;code class="language-python">from matplotlib.collections import LineCollection
lines = []
colors = []
for s, t in g.get_edgelist():
x0, y0 = pos[s]
x1, y1 = pos[t]
lines.append([(x0, y0), (x1, y1)])
colors.append(&amp;quot;black&amp;quot;)
lc = LineCollection(lines, colors=colors, zorder=0, alpha=.5)
fig = plt.figure(figsize=(10, 10))
ax = fig.add_subplot(1, 1, 1)
ax.scatter(
pos[:, 0],
pos[:, 1],
c=g.vs[&amp;quot;color&amp;quot;],
s=25,
marker=&amp;quot;d&amp;quot;,
alpha=.8,
zorder=1
)
ax.add_collection(lc)
ax.axis('off')
legend = ax.legend(
[plt.Line2D([0], [0], color=c, lw=10)
for c in list(sector2color.values())],
list(sector2color.keys()),
bbox_to_anchor=(1.05, 1),
loc=2,
borderaxespad=0.)
plt.savefig(f'mst_{start_date}_{end_date}.png', bbox_inches='tight',)
plt.show()
&lt;/code>&lt;/pre>
&lt;figure id="figure-mst-para-ativos-do-sp500-no-primeiro-semestre-de-2018">
&lt;a data-fancybox="" href="/post/nsbm_sp500_stock_market_disparity_filter/mst_2018-01-01_2018-06-01_huc06590f539d2bf35f6546a367d158c6d_73932_0x500_resize_lanczos_2.png" data-caption="MST para ativos do S&amp;amp;amp;P500 no primeiro semestre de 2018">
&lt;img data-src="/post/nsbm_sp500_stock_market_disparity_filter/mst_2018-01-01_2018-06-01_huc06590f539d2bf35f6546a367d158c6d_73932_0x500_resize_lanczos_2.png" class="lazyload" alt="" width="100%" height="500px">
&lt;/a>
&lt;figcaption>
MST para ativos do S&amp;amp;P500 no primeiro semestre de 2018
&lt;/figcaption>
&lt;/figure>
&lt;p>Alguns padr√µes aparecem, mas o MST √© muito menos rico de informa√ß√µes que o nSBM, exploraremos mais essas vantagens em posts futuros.&lt;/p>
&lt;h2 id="agradecimentos">Agradecimentos&lt;/h2>
&lt;p>Agrade√ßo ao
&lt;a href="https://www.linkedin.com/in/maikereis/" target="_blank" rel="noopener">Maike Reis&lt;/a> e
&lt;a href="https://www.linkedin.com/in/felipe-alves-dos-santos/" target="_blank" rel="noopener">Felipe Santos&lt;/a> pelas dicas e corre√ß√µes.&lt;/p></description></item></channel></rss>