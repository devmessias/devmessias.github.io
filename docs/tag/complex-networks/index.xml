<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Complex Networks | Bruno Messias</title>
    <link>/tag/complex-networks/</link>
      <atom:link href="/tag/complex-networks/index.xml" rel="self" type="application/rss+xml" />
    <description>Complex Networks</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en</language><copyright>Bruno Messias</copyright><lastBuildDate>Mon, 13 Sep 2021 17:43:22 +0000</lastBuildDate>
    <image>
      <url>/images/icon_hucd6a3d413e7b81060a1d462b35f64cf9_5018_512x512_fill_lanczos_center_3.png</url>
      <title>Complex Networks</title>
      <link>/tag/complex-networks/</link>
    </image>
    
    <item>
      <title>Helios: graph layout viz and streaming</title>
      <link>/project/helios/</link>
      <pubDate>Mon, 13 Sep 2021 17:43:22 +0000</pubDate>
      <guid>/project/helios/</guid>
      <description>&lt;a href=&#34;https://github.com/fury-gl/helios&#34;&gt;
Helios repo
&lt;/a&gt;
&lt;p&gt;Helios is a Python library aiming to provide an easy way to visualize huge networks dynamically. Helios also provides visualizations through an interactive Stadia-like streaming system in which users can be collaboratively access (and share) visualizations created in a server or through Jupyter Notebook/Lab environments. It incorporates state-of-the-art layout algorithms and optimized rendering techniques (powered by 
&lt;a href=&#34;https://github.com/fury-gl/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;FURY&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/6979335/125310065-a3a9f480-e308-11eb-98d9-0ff5406a0e96.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/6979335/126175583-c7d85f0a-3d0c-400e-bbdd-4cbcd2a36fed.gif&#34; alt=&#34;...&#34; height=&#34;300&#34;/&gt;&lt;/center&gt;
&lt;p align=&#34;center&#34;&gt;
  &lt;a href=&#34;#general-information&#34;&gt;General Information&lt;/a&gt; •
  &lt;a href=&#34;#key-features&#34;&gt;Key Features&lt;/a&gt; •
  &lt;a href=&#34;#installation&#34;&gt;Installation&lt;/a&gt; •
  &lt;a href=&#34;#how-to-use&#34;&gt;Usage&lt;/a&gt; •
  &lt;a href=&#34;#history&#34;&gt;History&lt;/a&gt; •
  &lt;a href=&#34;#credits&#34;&gt;Credits&lt;/a&gt; 
&lt;/p&gt;
&lt;h1 id=&#34;general-information&#34;&gt;General Information&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Website and Documentation:&lt;/strong&gt;  
&lt;a href=&#34;https://heliosnetwork.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://heliosnetwork.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Examples:&lt;/strong&gt; 
&lt;a href=&#34;https://heliosnetwork.io/examples_gallery/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://heliosnetwork.io/examples_gallery/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Blog:&lt;/strong&gt;  
&lt;a href=&#34;https://heliosnetwork.io/blog.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://heliosnetwork.io/blog.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Free software:&lt;/strong&gt; MIT license&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Community:&lt;/strong&gt; Come to chat on 
&lt;a href=&#34;https://discord.gg/6btFPPj&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Discord&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;key-features&#34;&gt;Key Features&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Force-directed layout using octrees&lt;/li&gt;
&lt;li&gt;Minimum-distortion embeddings&lt;/li&gt;
&lt;li&gt;ForceAtlas2 using cugraph&lt;/li&gt;
&lt;li&gt;Interactive local and Remote rendering in Jupyter Notebooks&lt;/li&gt;
&lt;li&gt;WebRTC or MJPEG interactive streaming system&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;installation&#34;&gt;Installation&lt;/h1&gt;
&lt;p&gt;Use pip install pointed to this repository:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pip git+https://github.com/fury-gl/helios.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As an alternative, Helios can be installed from the source code through the following steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Step 1.&lt;/strong&gt; Get the latest source by cloning this repo:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/fury-gl/helios.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Step 2.&lt;/strong&gt; Install requirements:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pip install -r requirements.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Step 3.&lt;/strong&gt; Install Helios&lt;/p&gt;
&lt;p&gt;As a 
&lt;a href=&#34;https://pip.pypa.io/en/stable/reference/pip_install/#id44&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;local project installation&lt;/a&gt; using:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  pip install .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or as an 
&lt;a href=&#34;https://pip.pypa.io/en/stable/reference/pip_install/#id44&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&amp;ldquo;editable&amp;rdquo; installation&lt;/a&gt; using:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  pip install -e .
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Step 4:&lt;/strong&gt; Enjoy!&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For more information, see also 
&lt;a href=&#34;https://heliosnetwork.io/latest/installation.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;installation page on heliosnetwork.io&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;dependencies&#34;&gt;Dependencies&lt;/h2&gt;
&lt;p&gt;Helios requires Python 3.7+ and the following mandatory dependencies:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;numpy &amp;gt;= 1.7.1&lt;/li&gt;
&lt;li&gt;vtk &amp;gt;= 8.1.0&lt;/li&gt;
&lt;li&gt;fury&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To enable WebRTC streaming and enable optimizations to the streaming system, install the following optional packages:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Required for WebRTC streaming&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;aiohttp&lt;/li&gt;
&lt;li&gt;aiortc&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Optional packages that may improve performance&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cython&lt;/li&gt;
&lt;li&gt;opencv&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;testing&#34;&gt;Testing&lt;/h2&gt;
&lt;p&gt;After installation, you can install test suite requirements:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pip install -r requirements_dev.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And to launch test suite:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pytest -svv helios
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;usage&#34;&gt;Usage&lt;/h1&gt;
&lt;p&gt;There are many ways to start using Helios:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Go to 
&lt;a href=&#34;https://heliosnetwork.io/getting_started.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Getting Started&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Explore our 
&lt;a href=&#34;https://heliosnetwork.io/examples_gallery/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Examples&lt;/a&gt; or 
&lt;a href=&#34;https://heliosnetwork.io/latest/auto_examples/index.htmlhttps://heliosnetwork.io/api.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example usage:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;   from helios import NetworkDraw
   from helios.layouts import HeliosFr
   import numpy as np
   
   vertex_count = 8
   
   edges = np.array([
      [0,1],
      [0,2],
      [1,2],
      [2,3],
      [3,4],
      [3,5],
      [4,5],
      [5,6],
      [6,7],
      [7,0]
   ]);
   
  centers = np.random.normal(size=(vertex_count, 3))

  network_draw = NetworkDraw(
          positions=centers,
          edges=edges,
          colors=(0.25,0.25,0.25),
          scales=1,
          node_edge_width=0,
          marker=&#39;s&#39;,
          edge_line_color=(0.5,0.5,0.5),
          window_size=(600, 600)
  )
  
  layout = HeliosFr(edges, network_draw)
  layout.start()
  network_draw.showm.initialize()
  network_draw.showm.start()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;history&#34;&gt;History&lt;/h1&gt;
&lt;p&gt;Helios project started as a replacement to the desktop version of the 
&lt;a href=&#34;https://filipinascimento.github.io/networks3d/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Networks 3D&lt;/a&gt; tools. The project evolved quickly along the summer of 2021 due to the GSoC’21 under the responsibility of the Python Software Foundation and the FURY team. The majority of the initial work has been done by 
&lt;a href=&#34;https://github.com/devmessias&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@devmessias&lt;/a&gt; mentored by 
&lt;a href=&#34;https://github.com/filipinascimento&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@filipinascimento&lt;/a&gt; and 
&lt;a href=&#34;https://github.com/skoudoro&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@skoudoro&lt;/a&gt;. The GSoC’21 project associated with Helios is “A system for collaborative visualization of large network layouts using FURY”. Check out the 
&lt;a href=&#34;https://gist.github.com/devmessias/1cb802efb0a094686c129259498710b3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;final report&lt;/a&gt; for more information.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>eMaTe</title>
      <link>/project/emate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/project/emate/</guid>
      <description>&lt;p&gt;eMaTe it is a python package which the main goal is to provide  methods capable of estimating the spectral densities and trace
functions of large sparse matrices. eMaTe can run in both CPU and GPU and can estimate the spectral density and related trace functions, such as entropy and Estrada index, even in directed or undirected networks with million of nodes.&lt;/p&gt;
&lt;h2 id=&#34;install&#34;&gt;Install&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;pip install emate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you a have a GPU you should also install cupy.&lt;/p&gt;
&lt;h2 id=&#34;kernel-polynomial-method-kpm&#34;&gt;Kernel Polynomial Method (KPM)&lt;/h2&gt;
&lt;p&gt;The Kernel Polynomial Method can estimate the spectral density of large sparse Hermitan matrices with a computational cost almost linear. This method combines three key ingredients: the Chebyshev expansion + the stochastic trace estimator + kernel smoothing.&lt;/p&gt;
&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import networkx as nx
import numpy as np

n = 3000
g = nx.erdos_renyi_graph(n , 3/n)
W = nx.adjacency_matrix(g)

vals  = np.linalg.eigvals(W.todense()).real
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from emate.hermitian import tfkpm


num_moments = 40
num_vecs = 40
extra_points = 10
ek, rho = tfkpm(W, num_moments, num_vecs, extra_points)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import matplotlib.pyplot as plt
plt.hist(vals, density=True, bins=100, alpha=.9, color=&amp;quot;steelblue&amp;quot;)
plt.scatter(ek, rho, c=&amp;quot;tomato&amp;quot;, zorder=999, alpha=0.9, marker=&amp;quot;d&amp;quot;)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the CUPY package it is available in your machine, you can also use the cupy implementation. When compared to tf-kpm, the
Cupy-kpm is slower for median matrices (100k) and faster for larger matrices (&amp;gt; 10^6). The main reason it&amp;rsquo;s because the tf-kpm was implemented in order to calc all te moments in a single step.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import matplotlib.pyplot as plt
from emate.hermitian import cupykpm

num_moments = 40
num_vecs = 40
extra_points = 10
ek, rho = cupykpm(W.tocsr(), num_moments, num_vecs, extra_points)
plt.hist(vals, density=True, bins=100, alpha=.9, color=&amp;quot;steelblue&amp;quot;)
plt.scatter(ek.get(), rho.get(), c=&amp;quot;tomato&amp;quot;, zorder=999, alpha=0.9, marker=&amp;quot;d&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;docs/source/imgs/kpm.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;stochastic-lanczos-quadrature-slq&#34;&gt;Stochastic Lanczos Quadrature (SLQ)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;The problem of estimating the trace of matrix functions appears in applications ranging from machine learning and scientific computing, to computational biology.[2]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;example-1&#34;&gt;Example&lt;/h3&gt;
&lt;h4 id=&#34;computing-the-estrada-index&#34;&gt;Computing the Estrada index&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from emate.symmetric.slq import pyslq
import tensorflow as tf

def trace_function(eig_vals):
    return tf.exp(eig_vals)

num_vecs = 100
num_steps = 50
approximated_estrada_index, _ = pyslq(L_sparse, num_vecs, num_steps,  trace_function)
exact_estrada_index =  np.sum(np.exp(vals_laplacian))
approximated_estrada_index, exact_estrada_index
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above code returns&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(3058.012, 3063.16457163222)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;entropy&#34;&gt;Entropy&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import scipy
import scipy.sparse

def entropy(eig_vals):
  s = 0.
  for val in eig_vals:
    if val &amp;gt; 0:
      s += -val*np.log(val)
  return s

L = np.array(G.laplacian(normalized=True), dtype=np.float64)
vals_laplacian = np.linalg.eigvalsh(L).real

exact_entropy =  entropy(vals_laplacian)


def trace_function(eig_vals):
  def entropy(val):
    return tf.cond(val&amp;gt;0, lambda:-val*tf.log(val), lambda: 0.)
  
  return tf.map_fn(entropy, eig_vals)
 
L_sparse = scipy.sparse.coo_matrix(L)
    
num_vecs = 100
num_steps = 50
approximated_entropy, _ = pyslq(L_sparse, num_vecs, num_steps,  trace_function)

approximated_entropy, exact_entropy
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(-509.46283, -512.5283224633046)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.tandfonline.com/doi/abs/10.1080/03610919008812866&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;[1] Hutchinson, M. F. (1990). A stochastic estimator of the trace of the influence matrix for laplacian smoothing splines. Communications in Statistics-Simulation and Computation, 19(2), 433-450.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://epubs.siam.org/doi/abs/10.1137/16M1104974&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;[2] Ubaru, S., Chen, J., &amp;amp; Saad, Y. (2017). Fast Estimation of tr(f(A)) via Stochastic Lanczos Quadrature. SIAM Journal on Matrix Analysis and Applications, 38(4), 1075-1099.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;&#34;&gt;[3] The Kernel Polynomial Method applied to
tight binding systems with
time-dependence&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
